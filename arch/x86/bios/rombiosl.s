! 1 
! 1 # 1 "_rombiosl_.c"
! 1 #asm
!BCC_ASM
.rom
.org 0x0000
use16 386
MACRO HALT
  ;; the HALT macro is called with the line number of the HALT call.
  ;; The line number is then sent to the 0x400, causing Bochs/Plex
  ;; to print a BX_PANIC message. This will normally halt the simulation
  ;; with a message such as "BIOS panic at rombios.c, line 4091".
  ;; However, users can choose to make panics non-fatal and continue.
  mov dx,#0x400
  mov ax,#?1
  out dx,ax
MEND
MACRO JMP_AP
  db 0xea
  dw ?2
  dw ?1
MEND
MACRO SET_INT_VECTOR
  mov ax, ?3
  mov ?1*4, ax
  mov ax, ?2
  mov ?1*4+2, ax
MEND
! 26 endasm
!BCC_ENDASM
! 27 typedef unsigned char Bit8u;
!BCC_EOS
! 28 typedef unsigned short Bit16u;
!BCC_EOS
! 29 typedef unsigned short bx_bool;
!BCC_EOS
! 30 typedef unsigned long Bit32u;
!BCC_EOS
! 31   void memsetb(seg,offset,value,count);
!BCC_EOS
! 32   void memcpyb(dseg,doffset,sseg,soffset,count);
!BCC_EOS
! 33   void memcpyd(dseg,doffset,sseg,soffset,count);
!BCC_EOS
! 34     void
! 35   memsetb(seg,offset,value,count)
! 36     Bit16u seg;
export	_memsetb
_memsetb:
!BCC_EOS
! 37     Bit16u offset;
!BCC_EOS
! 38     Bit16u value;
!BCC_EOS
! 39     Bit16u count;
!BCC_EOS
! 40   {
! 41 #asm
!BCC_ASM
_memsetb.count	set	8
_memsetb.seg	set	2
_memsetb.value	set	6
_memsetb.offset	set	4
    push bp
    mov bp, sp
      push ax
      push cx
      push es
      push di
      mov cx, 10[bp] ; count
      test cx, cx
      je memsetb_end
      mov ax, 4[bp] ; segment
      mov es, ax
      mov ax, 6[bp] ; offset
      mov di, ax
      mov al, 8[bp] ; value
      cld
      rep
       stosb
  memsetb_end:
      pop di
      pop es
      pop cx
      pop ax
    pop bp
! 65 endasm
!BCC_ENDASM
! 66   }
ret
! 67     void
! 68   memcpyb(dseg,doffset,sseg,soffset,count)
! 69     Bit16u dseg;
export	_memcpyb
_memcpyb:
!BCC_EOS
! 70     Bit16u doffset;
!BCC_EOS
! 71     Bit16u sseg;
!BCC_EOS
! 72     Bit16u soffset;
!BCC_EOS
! 73     Bit16u count;
!BCC_EOS
! 74   {
! 75 #asm
!BCC_ASM
_memcpyb.count	set	$A
_memcpyb.sseg	set	6
_memcpyb.soffset	set	8
_memcpyb.dseg	set	2
_memcpyb.doffset	set	4
    push bp
    mov bp, sp
      push ax
      push cx
      push es
      push di
      push ds
      push si
      mov cx, 12[bp] ; count
      test cx, cx
      je memcpyb_end
      mov ax, 4[bp] ; dsegment
      mov es, ax
      mov ax, 6[bp] ; doffset
      mov di, ax
      mov ax, 8[bp] ; ssegment
      mov ds, ax
      mov ax, 10[bp] ; soffset
      mov si, ax
      cld
      rep
       movsb
  memcpyb_end:
      pop si
      pop ds
      pop di
      pop es
      pop cx
      pop ax
    pop bp
! 106 endasm
!BCC_ENDASM
! 107   }
ret
! 108     void
! 109 
! 109   memcpyd(dseg,doffset,sseg,soffset,count)
! 110     Bit16u dseg;
export	_memcpyd
_memcpyd:
!BCC_EOS
! 111     Bit16u doffset;
!BCC_EOS
! 112     Bit16u sseg;
!BCC_EOS
! 113     Bit16u soffset;
!BCC_EOS
! 114     Bit16u count;
!BCC_EOS
! 115   {
! 116 #asm
!BCC_ASM
_memcpyd.count	set	$A
_memcpyd.sseg	set	6
_memcpyd.soffset	set	8
_memcpyd.dseg	set	2
_memcpyd.doffset	set	4
    push bp
    mov bp, sp
      push ax
      push cx
      push es
      push di
      push ds
      push si
      mov cx, 12[bp] ; count
      test cx, cx
      je memcpyd_end
      mov ax, 4[bp] ; dsegment
      mov es, ax
      mov ax, 6[bp] ; doffset
      mov di, ax
      mov ax, 8[bp] ; ssegment
      mov ds, ax
      mov ax, 10[bp] ; soffset
      mov si, ax
      cld
      rep
       movsd
  memcpyd_end:
      pop si
      pop ds
      pop di
      pop es
      pop cx
      pop ax
    pop bp
! 147 endasm
!BCC_ENDASM
! 148   }
ret
! 149   static Bit32u read_dword();
!BCC_EOS
! 150   static void write_dword();
!BCC_EOS
! 151     Bit32u
! 152   read_dword(seg, offset)
! 153     Bit16u seg;
export	_read_dword
_read_dword:
!BCC_EOS
! 154     Bit16u offset;
!BCC_EOS
! 155   {
! 156 #asm
!BCC_ASM
_read_dword.seg	set	2
_read_dword.offset	set	4
    push bp
    mov bp, sp
      push bx
      push ds
      mov ax, 4[bp] ; segment
      mov ds, ax
      mov bx, 6[bp] ; offset
      mov ax, [bx]
      add bx, #2
      mov dx, [bx]
      ;; ax = return value (word)
      ;; dx = return value (word)
      pop ds
      pop bx
    pop bp
! 172 endasm
!BCC_ENDASM
! 173   }
ret
! 174     void
! 175   write_dword(seg, offset, data)
! 176     Bit16u seg;
export	_write_dword
_write_dword:
!BCC_EOS
! 177     Bit16u offset;
!BCC_EOS
! 178     Bit32u data;
!BCC_EOS
! 179   {
! 180 #asm
!BCC_ASM
_write_dword.seg	set	2
_write_dword.data	set	6
_write_dword.offset	set	4
    push bp
    mov bp, sp
      push ax
      push bx
      push ds
      mov ax, 4[bp] ; segment
      mov ds, ax
      mov bx, 6[bp] ; offset
      mov ax, 8[bp] ; data word
      mov [bx], ax ; write data word
      add bx, #2
      mov ax, 10[bp] ; data word
      mov [bx], ax ; write data word
      pop ds
      pop bx
      pop ax
    pop bp
! 198 endasm
!BCC_ENDASM
! 199   }
ret
! 200 #asm
!BCC_ASM
_write_dword.seg	set	2
_write_dword.data	set	6
_write_dword.offset	set	4
  ;; and function
  landl:
  landul:
    SEG SS
      and ax,[di]
    SEG SS
      and bx,2[di]
    ret
  ;; add function
  laddl:
  laddul:
    SEG SS
      add ax,[di]
    SEG SS
      adc bx,2[di]
    ret
  ;; cmp function
  lcmpl:
  lcmpul:
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
    shr ebx, #16
    SEG SS
      cmp eax, dword ptr [di]
    ret
  ;; sub function
  lsubl:
  lsubul:
    SEG SS
    sub ax,[di]
    SEG SS
    sbb bx,2[di]
    ret
  ;; mul function
  lmull:
  lmulul:
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
    SEG SS
    mul eax, dword ptr [di]
    mov ebx, eax
    shr ebx, #16
    ret
  ;; dec function
  ldecl:
  ldecul:
    SEG SS
    dec dword ptr [bx]
    ret
  ;; or function
  lorl:
  lorul:
    SEG SS
    or ax,[di]
    SEG SS
    or bx,2[di]
    ret
  ;; inc function
  lincl:
  lincul:
    SEG SS
    inc dword ptr [bx]
    ret
  ;; tst function
  ltstl:
  ltstul:
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
    shr ebx, #16
    test eax, eax
    ret
  ;; sr function
  lsrul:
    mov cx,di
    jcxz lsr_exit
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
  lsr_loop:
    shr eax, #1
    loop lsr_loop
    mov ebx, eax
    shr ebx, #16
  lsr_exit:
    ret
  ;; sl function
  lsll:
  lslul:
    mov cx,di
    jcxz lsl_exit
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
  lsl_loop:
    shl eax, #1
    loop lsl_loop
    mov ebx, eax
    shr ebx, #16
  lsl_exit:
    ret
  idiv_:
    cwd
    idiv bx
    ret
  idiv_u:
    xor dx,dx
    div bx
    ret
  ldivul:
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
    xor edx, edx
    SEG SS
    mov bx, 2[di]
    shl ebx, #16
    SEG SS
    mov bx, [di]
    div ebx
    mov ebx, eax
    shr ebx, #16
    ret
! 326 endasm
!BCC_ENDASM
! 327 typedef struct {
! 328   unsigned char filler1[0x400];
!BCC_EOS
! 329   unsigned char filler2[0x6c];
!BCC_EOS
! 330   Bit16u ticks_low;
!BCC_EOS
! 331   Bit16u ticks_high;
!BCC_EOS
! 332   Bit8u midnight_flag;
!BCC_EOS
! 333 } bios_data_t;
!BCC_EOS
! 334   typedef struct {
! 335     Bit16u heads;
!BCC_EOS
! 336     Bit16u cylinders;
!BCC_EOS
! 337     Bit16u spt;
!BCC_EOS
! 338   } chs_t;
!BCC_EOS
! 339   typedef struct {
! 340     Bit16u iobase1;
!BCC_EOS
! 341     Bit16u iobase2;
!BCC_EOS
! 342     Bit8u prefix;
!BCC_EOS
! 343     Bit8u unused;
!BCC_EOS
! 344     Bit8u irq;
!BCC_EOS
! 345     Bit8u blkcount;
!BCC_EOS
! 346     Bit8u dma;
!BCC_EOS
! 347     Bit8u pio;
!BCC_EOS
! 348     Bit16u options;
!BCC_EOS
! 349     Bit16u reserved;
!BCC_EOS
! 350     Bit8u revision;
!BCC_EOS
! 351     Bit8u checksum;
!BCC_EOS
! 352   } dpte_t;
!BCC_EOS
! 353   typedef struct {
! 354     Bit8u iface;
!BCC_EOS
! 355     Bit16u iobase1;
!BCC_EOS
! 356     Bit16u iobase2;
!BCC_EOS
! 357     Bit8u irq;
!BCC_EOS
! 358   } ata_channel_t;
!BCC_EOS
! 359   typedef struct {
! 360     Bit8u type;
!BCC_EOS
! 361     Bit8u device;
!BCC_EOS
! 362     Bit8u removable;
!BCC_EOS
! 363     Bit8u lock;
!BCC_EOS
! 364     Bit8u mode;
!BCC_EOS
! 365     Bit16u blksize;
!BCC_EOS
! 366     Bit8
! 366 u translation;
!BCC_EOS
! 367     chs_t lchs;
!BCC_EOS
! 368     chs_t pchs;
!BCC_EOS
! 369     Bit32u sectors_low;
!BCC_EOS
! 370     Bit32u sectors_high;
!BCC_EOS
! 371   } ata_device_t;
!BCC_EOS
! 372   typedef struct {
! 373     ata_channel_t channels[4];
!BCC_EOS
! 374     ata_device_t devices[(4*2)];
!BCC_EOS
! 375     Bit8u hdcount, hdidmap[(4*2)];
!BCC_EOS
! 376     Bit8u cdcount, cdidmap[(4*2)];
!BCC_EOS
! 377     dpte_t dpte;
!BCC_EOS
! 378     Bit16u trsfsectors;
!BCC_EOS
! 379     Bit32u trsfbytes;
!BCC_EOS
! 380   } ata_t;
!BCC_EOS
! 381   typedef struct {
! 382     Bit8u active;
!BCC_EOS
! 383     Bit8u media;
!BCC_EOS
! 384     Bit8u emulated_drive;
!BCC_EOS
! 385     Bit8u controller_index;
!BCC_EOS
! 386     Bit16u device_spec;
!BCC_EOS
! 387     Bit32u ilba;
!BCC_EOS
! 388     Bit16u buffer_segment;
!BCC_EOS
! 389     Bit16u load_segment;
!BCC_EOS
! 390     Bit16u sector_count;
!BCC_EOS
! 391     chs_t vdevice;
!BCC_EOS
! 392   } cdemu_t;
!BCC_EOS
! 393   typedef struct {
! 394     unsigned char filler1[0x3D];
!BCC_EOS
! 395     unsigned char fdpt0[0x10];
!BCC_EOS
! 396     unsigned char fdpt1[0x10];
!BCC_EOS
! 397     unsigned char filler2[0xC4];
!BCC_EOS
! 398     ata_t ata;
!BCC_EOS
! 399     cdemu_t cdemu;
!BCC_EOS
! 400   } ebda_data_t;
!BCC_EOS
! 401   typedef struct {
! 402     Bit8u size;
!BCC_EOS
! 403     Bit8u reserved;
!BCC_EOS
! 404     Bit16u count;
!BCC_EOS
! 405     Bit16u offset;
!BCC_EOS
! 406     Bit16u segment;
!BCC_EOS
! 407     Bit32u lba1;
!BCC_EOS
! 408     Bit32u lba2;
!BCC_EOS
! 409   } int13ext_t;
!BCC_EOS
! 410   typedef struct {
! 411     Bit16u size;
!BCC_EOS
! 412     Bit16u infos;
!BCC_EOS
! 413     Bit32u cylinders;
!BCC_EOS
! 414     Bit32u heads;
!BCC_EOS
! 415     Bit32u spt;
!BCC_EOS
! 416     Bit32u sector_count1;
!BCC_EOS
! 417     Bit32u sector_count2;
!BCC_EOS
! 418     Bit16u blksize;
!BCC_EOS
! 419     Bit16u dpte_offset;
!BCC_EOS
! 420     Bit16u dpte_segment;
!BCC_EOS
! 421     Bit16u key;
!BCC_EOS
! 422     Bit8u dpi_length;
!BCC_EOS
! 423     Bit8u reserved1;
!BCC_EOS
! 424     Bit16u reserved2;
!BCC_EOS
! 425     Bit8u host_bus[4];
!BCC_EOS
! 426     Bit8u iface_type[8];
!BCC_EOS
! 427     Bit8u iface_path[8];
!BCC_EOS
! 428     Bit8u device_path[8];
!BCC_EOS
! 429     Bit8u reserved3;
!BCC_EOS
! 430     Bit8u checksum;
!BCC_EOS
! 431   } dpt_t;
!BCC_EOS
! 432 typedef struct {
! 433   union {
! 434     struct {
! 435       Bit16u di, si, bp, sp;
!BCC_EOS
! 436       Bit16u bx, dx, cx, ax;
!BCC_EOS
! 437     } r16;
!BCC_EOS
! 438     struct {
! 439       Bit16u filler[4];
!BCC_EOS
! 440       Bit8u bl, bh, dl, dh, cl, ch, al, ah;
!BCC_EOS
! 441     } r8;
!BCC_EOS
! 442   } u;
!BCC_EOS
! 443 } pusha_regs_t;
!BCC_EOS
! 444 typedef struct {
! 445  union {
! 446   struct {
! 447     Bit32u edi, esi, ebp, esp;
!BCC_EOS
! 448     Bit32u ebx, edx, ecx, eax;
!BCC_EOS
! 449   } r32;
!BCC_EOS
! 450   struct {
! 451     Bit16u di, filler1, si, filler2, bp, filler3, sp, filler4;
!BCC_EOS
! 452     Bit16u bx, filler5, dx, filler6, cx, filler7, ax, filler8;
!BCC_EOS
! 453   } r16;
!BCC_EOS
! 454   struct {
! 455     Bit32u filler[4];
!BCC_EOS
! 456     Bit8u bl, bh;
!BCC_EOS
! 457     Bit16u filler1;
!BCC_EOS
! 458     Bit8u dl, dh;
!BCC_EOS
! 459     Bit16u filler2;
!BCC_EOS
! 460     Bit8u cl, ch;
!BCC_EOS
! 461     Bit16u filler3;
!BCC_EOS
! 462   
! 462   Bit8u al, ah;
!BCC_EOS
! 463     Bit16u filler4;
!BCC_EOS
! 464   } r8;
!BCC_EOS
! 465  } u;
!BCC_EOS
! 466 } pushad_regs_t;
!BCC_EOS
! 467 typedef struct {
! 468   union {
! 469     struct {
! 470       Bit16u flags;
!BCC_EOS
! 471     } r16;
!BCC_EOS
! 472     struct {
! 473       Bit8u flagsl;
!BCC_EOS
! 474       Bit8u flagsh;
!BCC_EOS
! 475     } r8;
!BCC_EOS
! 476   } u;
!BCC_EOS
! 477 } flags_t;
!BCC_EOS
! 478 typedef struct {
! 479   Bit16u ip;
!BCC_EOS
! 480   Bit16u cs;
!BCC_EOS
! 481   flags_t flags;
!BCC_EOS
! 482 } iret_addr_t;
!BCC_EOS
! 483 typedef struct {
! 484   Bit16u type;
!BCC_EOS
! 485   Bit16u flags;
!BCC_EOS
! 486   Bit32u vector;
!BCC_EOS
! 487   Bit32u description;
!BCC_EOS
! 488   Bit32u reserved;
!BCC_EOS
! 489 } ipl_entry_t;
!BCC_EOS
! 490 static Bit8u inb();
!BCC_EOS
! 491 static Bit8u inb_cmos();
!BCC_EOS
! 492 static void outb();
!BCC_EOS
! 493 static void outb_cmos();
!BCC_EOS
! 494 static Bit16u inw();
!BCC_EOS
! 495 static void outw();
!BCC_EOS
! 496 static void init_rtc();
!BCC_EOS
! 497 static bx_bool rtc_updating();
!BCC_EOS
! 498 static Bit8u read_byte();
!BCC_EOS
! 499 static Bit16u read_word();
!BCC_EOS
! 500 static void write_byte();
!BCC_EOS
! 501 static void write_word();
!BCC_EOS
! 502 static void bios_printf();
!BCC_EOS
! 503 static Bit8u inhibit_mouse_int_and_events();
!BCC_EOS
! 504 static void enable_mouse_int_and_events();
!BCC_EOS
! 505 static Bit8u send_to_mouse_ctrl();
!BCC_EOS
! 506 static Bit8u get_mouse_data();
!BCC_EOS
! 507 static void set_kbd_command_byte();
!BCC_EOS
! 508 static void int09_function();
!BCC_EOS
! 509 static void int13_harddisk();
!BCC_EOS
! 510 static void int13_cdrom();
!BCC_EOS
! 511 static void int13_cdemu();
!BCC_EOS
! 512 static void int13_eltorito();
!BCC_EOS
! 513 static void int13_diskette_function();
!BCC_EOS
! 514 static void int14_function();
!BCC_EOS
! 515 static void int15_function();
!BCC_EOS
! 516 static void int16_function();
!BCC_EOS
! 517 static void int17_function();
!BCC_EOS
! 518 static void int19_function();
!BCC_EOS
! 519 static void int1a_function();
!BCC_EOS
! 520 static void int70_function();
!BCC_EOS
! 521 static void int74_function();
!BCC_EOS
! 522 static Bit16u get_CS();
!BCC_EOS
! 523 static Bit16u get_SS();
!BCC_EOS
! 524 static unsigned int enqueue_key();
!BCC_EOS
! 525 static unsigned int dequeue_key();
!BCC_EOS
! 526 static void get_hd_geometry();
!BCC_EOS
! 527 static void set_diskette_ret_status();
!BCC_EOS
! 528 static void set_diskette_current_cyl();
!BCC_EOS
! 529 static void determine_floppy_media();
!BCC_EOS
! 530 static bx_bool floppy_drive_exists();
!BCC_EOS
! 531 static bx_bool floppy_drive_recal();
!BCC_EOS
! 532 static bx_bool floppy_media_known();
!BCC_EOS
! 533 static bx_bool floppy_media_sense();
!BCC_EOS
! 534 static bx_bool set_enable_a20();
!BCC_EOS
! 535 static void debugger_on();
!BCC_EOS
! 536 static void debugger_off();
!BCC_EOS
! 537 static void keyboard_init();
!BCC_EOS
! 538 static void keyboard_panic();
!BCC_EOS
! 539 static void shutdown_status_panic();
!BCC_EOS
! 540 static void nmi_handler_msg();
!BCC_EOS
! 541 static void delay_ticks();
!BCC_EOS
! 542 static void delay_ticks_and_check_for_keystro
! 542 ke();
!BCC_EOS
! 543 static void interactive_bootkey();
!BCC_EOS
! 544 static void print_bios_banner();
!BCC_EOS
! 545 static void print_boot_device();
!BCC_EOS
! 546 static void print_boot_failure();
!BCC_EOS
! 547 static void print_cdromboot_failure();
!BCC_EOS
! 548 void ata_init();
!BCC_EOS
! 549 void ata_detect();
!BCC_EOS
! 550 void ata_reset();
!BCC_EOS
! 551 Bit16u ata_cmd_non_data();
!BCC_EOS
! 552 Bit16u ata_cmd_data_in();
!BCC_EOS
! 553 Bit16u ata_cmd_data_out();
!BCC_EOS
! 554 Bit16u ata_cmd_packet();
!BCC_EOS
! 555 Bit16u atapi_get_sense();
!BCC_EOS
! 556 Bit16u atapi_is_ready();
!BCC_EOS
! 557 Bit16u atapi_is_cdrom();
!BCC_EOS
! 558 void cdemu_init();
!BCC_EOS
! 559 Bit8u cdemu_isactive();
!BCC_EOS
! 560 Bit8u cdemu_emulated_drive();
!BCC_EOS
! 561 Bit16u cdrom_boot();
!BCC_EOS
! 562 static char bios_cvs_version_string[] = "$Revision: 1.231.2.1 $ $Date: 2009/06/07 07:49:09 $";
.data
_bios_cvs_version_string:
.1:
.ascii	"$Revision: 1.231.2.1 $ $Date: 2009/06/07"
.ascii	" 07:49:09 $"
.byte	0
!BCC_EOS
! 563 static struct {
! 564   Bit16u normal;
!BCC_EOS
! 565   Bit16u shift;
!BCC_EOS
! 566   Bit16u control;
!BCC_EOS
! 567   Bit16u alt;
!BCC_EOS
! 568   Bit8u lock_flags;
!BCC_EOS
! 569   } scan_to_scanascii[0x58 + 1] = {
_scan_to_scanascii:
! 570       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 571       { 0x011b, 0x011b, 0x011b, 0x0100, 0 },
.word	$11B
.word	$11B
.word	$11B
.word	$100
.byte	0
.blkb	1
! 572       { 0x0231, 0x0221, 0, 0x7800, 0 },
.word	$231
.word	$221
.word	0
.word	$7800
.byte	0
.blkb	1
! 573       { 0x0332, 0x0340, 0x0300, 0x7900, 0 },
.word	$332
.word	$340
.word	$300
.word	$7900
.byte	0
.blkb	1
! 574       { 0x0433, 0x0423, 0, 0x7a00, 0 },
.word	$433
.word	$423
.word	0
.word	$7A00
.byte	0
.blkb	1
! 575       { 0x0534, 0x0524, 0, 0x7b00, 0 },
.word	$534
.word	$524
.word	0
.word	$7B00
.byte	0
.blkb	1
! 576       { 0x0635, 0x0625, 0, 0x7c00, 0 },
.word	$635
.word	$625
.word	0
.word	$7C00
.byte	0
.blkb	1
! 577       { 0x0736, 0x075e, 0x071e, 0x7d00, 0 },
.word	$736
.word	$75E
.word	$71E
.word	$7D00
.byte	0
.blkb	1
! 578       { 0x0837, 0x0826, 0, 0x7e00, 0 },
.word	$837
.word	$826
.word	0
.word	$7E00
.byte	0
.blkb	1
! 579       { 0x0938, 0x092a, 0, 0x7f00, 0 },
.word	$938
.word	$92A
.word	0
.word	$7F00
.byte	0
.blkb	1
! 580       { 0x0a39, 0x0a28, 0, 0x8000, 0 },
.word	$A39
.word	$A28
.word	0
.word	$8000
.byte	0
.blkb	1
! 581       { 0x0b30, 0x0b29, 0, 0x8100, 0 },
.word	$B30
.word	$B29
.word	0
.word	$8100
.byte	0
.blkb	1
! 582       { 0x0c2d, 0x0c5f, 0x0c1f, 0x8200, 0 },
.word	$C2D
.word	$C5F
.word	$C1F
.word	$8200
.byte	0
.blkb	1
! 583       { 0x0d3d, 0x0d2b, 0, 0x8300, 0 },
.word	$D3D
.word	$D2B
.word	0
.word	$8300
.byte	0
.blkb	1
! 584       { 0x0e08, 0x0e08, 0x0e7f, 0, 0 },
.word	$E08
.word	$E08
.word	$E7F
.word	0
.byte	0
.blkb	1
! 585       { 0x0f09, 0x0f00, 0, 0, 0 },
.word	$F09
.word	$F00
.word	0
.word	0
.byte	0
.blkb	1
! 586       { 0x1071, 0x1051, 0x1011, 0x1000, 0x40 },
.word	$1071
.word	$1051
.word	$1011
.word	$1000
.byte	$40
.blkb	1
! 587       { 0x1177, 0x1157, 0x1117, 0x1100, 0x40 },
.word	$1177
.word	$1157
.word	$1117
.word	$1100
.byte	$40
.blkb	1
! 588       { 0x1265, 0x1245, 0x1205, 0x1200, 0x40 },
.word	$1265
.word	$1245
.word	$1205
.word	$1200
.byte	$40
.blkb	1
! 589       { 0x1372, 0x1352, 0x1312, 0x1300, 0x40 },
.word	$1372
.word	$1352
.word	$1312
.word	$1300
.byte	$40
.blkb	1
! 590       { 0x1474, 0x1454, 0x1414, 0x1400, 0x40 },
.word	$1474
.word	$1454
.word	$1414
.word	$1400
.byte	$40
.blkb	1
! 591       { 0x1579, 0x1559, 0x1519, 0x1500, 0x40 },
.word	$1579
.word	$1559
.word	$1519
.word	$1500
.byte	$40
.blkb	1
! 592       { 0x1675, 0x1655, 0x1615, 0x1600, 0x40 },
.word	$1675
.word	$1655
.word	$1615
.word	$1600
.byte	$40
.blkb	1
! 593       { 0x1769, 0x1749, 0x1709, 0x1700, 0x40 },
.word	$1769
.word	$1749
.word	$1709
.word	$1700
.byte	$40
.blkb	1
! 594       { 0x186f, 0x184f, 0x180f, 0x1800, 0x40 },
.word	$186F
.word	$184F
.word	$180F
.word	$1800
.byte	$40
.blkb	1
! 595       { 0x1970, 0x1950, 0x1910, 0x1900, 0x40 },
.word	$1970
.word	$1950
.word	$1910
.word	$1900
.byte	$40
.blkb	1
! 596       { 0x1a5b, 0x1a7b, 0x1a1b, 0, 0 },
.word	$1A5B
.word	$1A7B
.word	$1A1B
.word	0
.byte	0
.blkb	1
! 597       { 0x1b5d, 0x1b7d, 0x1b1d, 0, 0 },
.word	$1B5D
.word	$1B7D
.word	$1B1D
.word	0
.byte	0
.blkb	1
! 598       { 0x1c0d, 0x1c0d, 0x1c0a, 0, 0 },
.word	$1C0D
.word	$1C0D
.word	$1C0A
.word	0
.byte	0
.blkb	1
! 599       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 600       { 0x1e61, 0x1e41, 0x1e01, 0x1e00, 0x
.word	$1E61
.word	$1E41
.word	$1E01
.word	$1E00
! 600 40 },
.byte	$40
.blkb	1
! 601       { 0x1f73, 0x1f53, 0x1f13, 0x1f00, 0x40 },
.word	$1F73
.word	$1F53
.word	$1F13
.word	$1F00
.byte	$40
.blkb	1
! 602       { 0x2064, 0x2044, 0x2004, 0x2000, 0x40 },
.word	$2064
.word	$2044
.word	$2004
.word	$2000
.byte	$40
.blkb	1
! 603       { 0x2166, 0x2146, 0x2106, 0x2100, 0x40 },
.word	$2166
.word	$2146
.word	$2106
.word	$2100
.byte	$40
.blkb	1
! 604       { 0x2267, 0x2247, 0x2207, 0x2200, 0x40 },
.word	$2267
.word	$2247
.word	$2207
.word	$2200
.byte	$40
.blkb	1
! 605       { 0x2368, 0x2348, 0x2308, 0x2300, 0x40 },
.word	$2368
.word	$2348
.word	$2308
.word	$2300
.byte	$40
.blkb	1
! 606       { 0x246a, 0x244a, 0x240a, 0x2400, 0x40 },
.word	$246A
.word	$244A
.word	$240A
.word	$2400
.byte	$40
.blkb	1
! 607       { 0x256b, 0x254b, 0x250b, 0x2500, 0x40 },
.word	$256B
.word	$254B
.word	$250B
.word	$2500
.byte	$40
.blkb	1
! 608       { 0x266c, 0x264c, 0x260c, 0x2600, 0x40 },
.word	$266C
.word	$264C
.word	$260C
.word	$2600
.byte	$40
.blkb	1
! 609       { 0x273b, 0x273a, 0, 0, 0 },
.word	$273B
.word	$273A
.word	0
.word	0
.byte	0
.blkb	1
! 610       { 0x2827, 0x2822, 0, 0, 0 },
.word	$2827
.word	$2822
.word	0
.word	0
.byte	0
.blkb	1
! 611       { 0x2960, 0x297e, 0, 0, 0 },
.word	$2960
.word	$297E
.word	0
.word	0
.byte	0
.blkb	1
! 612       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 613       { 0x2b5c, 0x2b7c, 0x2b1c, 0, 0 },
.word	$2B5C
.word	$2B7C
.word	$2B1C
.word	0
.byte	0
.blkb	1
! 614       { 0x2c7a, 0x2c5a, 0x2c1a, 0x2c00, 0x40 },
.word	$2C7A
.word	$2C5A
.word	$2C1A
.word	$2C00
.byte	$40
.blkb	1
! 615       { 0x2d78, 0x2d58, 0x2d18, 0x2d00, 0x40 },
.word	$2D78
.word	$2D58
.word	$2D18
.word	$2D00
.byte	$40
.blkb	1
! 616       { 0x2e63, 0x2e43, 0x2e03, 0x2e00, 0x40 },
.word	$2E63
.word	$2E43
.word	$2E03
.word	$2E00
.byte	$40
.blkb	1
! 617       { 0x2f76, 0x2f56, 0x2f16, 0x2f00, 0x40 },
.word	$2F76
.word	$2F56
.word	$2F16
.word	$2F00
.byte	$40
.blkb	1
! 618       { 0x3062, 0x3042, 0x3002, 0x3000, 0x40 },
.word	$3062
.word	$3042
.word	$3002
.word	$3000
.byte	$40
.blkb	1
! 619       { 0x316e, 0x314e, 0x310e, 0x3100, 0x40 },
.word	$316E
.word	$314E
.word	$310E
.word	$3100
.byte	$40
.blkb	1
! 620       { 0x326d, 0x324d, 0x320d, 0x3200, 0x40 },
.word	$326D
.word	$324D
.word	$320D
.word	$3200
.byte	$40
.blkb	1
! 621       { 0x332c, 0x333c, 0, 0, 0 },
.word	$332C
.word	$333C
.word	0
.word	0
.byte	0
.blkb	1
! 622       { 0x342e, 0x343e, 0, 0, 0 },
.word	$342E
.word	$343E
.word	0
.word	0
.byte	0
.blkb	1
! 623       { 0x352f, 0x353f, 0, 0, 0 },
.word	$352F
.word	$353F
.word	0
.word	0
.byte	0
.blkb	1
! 624       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 625       { 0x372a, 0x372a, 0, 0, 0 },
.word	$372A
.word	$372A
.word	0
.word	0
.byte	0
.blkb	1
! 626       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 627       { 0x3920, 0x3920, 0x3920, 0x3920, 0 },
.word	$3920
.word	$3920
.word	$3920
.word	$3920
.byte	0
.blkb	1
! 628       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 629       { 0x3b00, 0x5400, 0x5e00, 0x6800, 0 },
.word	$3B00
.word	$5400
.word	$5E00
.word	$6800
.byte	0
.blkb	1
! 630       { 0x3c00, 0x5500, 0x5f00, 0x6900, 0 },
.word	$3C00
.word	$5500
.word	$5F00
.word	$6900
.byte	0
.blkb	1
! 631       { 0x3d00, 0x5600, 0x6000, 0x6a00, 0 },
.word	$3D00
.word	$5600
.word	$6000
.word	$6A00
.byte	0
.blkb	1
! 632       { 0x3e00, 0x5700, 0x6100, 0x6b00, 0 },
.word	$3E00
.word	$5700
.word	$6100
.word	$6B00
.byte	0
.blkb	1
! 633       { 0x3f00, 0x5800, 0x6200, 0x6c00, 0 },
.word	$3F00
.word	$5800
.word	$6200
.word	$6C00
.byte	0
.blkb	1
! 634       { 0x4000, 0x5900, 0x6300, 0x6d00, 0 },
.word	$4000
.word	$5900
.word	$6300
.word	$6D00
.byte	0
.blkb	1
! 635       { 0x4100, 0x5a00, 0x6400, 0x6e00, 0 },
.word	$4100
.word	$5A00
.word	$6400
.word	$6E00
.byte	0
.blkb	1
! 636       { 0x4200, 0x5b00, 0x6500, 0x6f00, 0 },
.word	$4200
.word	$5B00
.word	$6500
.word	$6F00
.byte	0
.blkb	1
! 637       { 0x4300, 0x5c00, 0x6600, 0x7000, 0 },
.word	$4300
.word	$5C00
.word	$6600
.word	$7000
.byte	0
.blkb	1
! 638       { 0x4400, 0x5d00, 0x6700, 0x7100, 0 },
.word	$4400
.word	$5D00
.word	$6700
.word	$7100
.byte	0
.blkb	1
! 639       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 640       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 641       { 0x4700, 0x4737, 0x7700, 0, 0x20 },
.word	$4700
.word	$4737
.word	$7700
.word	0
.byte	$20
.blkb	1
! 642       { 0x4800, 0x4838, 0, 0, 0x20 },
.word	$4800
.word	$4838
.word	0
.word	0
.byte	$20
.blkb	1
! 643       { 0x4900, 0x4939, 0x8400, 0, 0x20 },
.word	$4900
.word	$4939
.word	$8400
.word	0
.byte	$20
.blkb	1
! 644       { 0x4a2d, 0x4a2d, 0, 0, 0 },
.word	$4A2D
.word	$4A2D
.word	0
.word	0
.byte	0
.blkb	1
! 645       { 0x4b00, 0x4b34, 0x7300, 0, 0x20 },
.word	$4B00
.word	$4B34
.word	$7300
.word	0
.byte	$20
.blkb	1
! 646       { 0x4c00, 0x4c35, 0, 0, 0x20 },
.word	$4C00
.word	$4C35
.word	0
.word	0
.byte	$20
.blkb	1
! 647       { 0x4d00, 0x4d36, 0x7400, 0, 0x20 },
.word	$4D00
.word	$4D36
.word	$7400
.word	0
.byte	$20
.blkb	1
! 648       { 0x4e2b, 0x4e2b, 0, 0, 0 },
.word	$4E2B
.word	$4E2B
.word	0
.word	0
.byte	0
.blkb	1
! 649       { 0x4f00, 0x4f31, 0x7500, 0, 0x20 },
.word	$4F00
.word	$4F31
.word	$7500
.word	0
.byte	$20
.blkb	1
! 650       { 0x5000, 0x5032, 0, 0, 0
.word	$5000
.word	$5032
.word	0
.word	0
! 650 x20 },
.byte	$20
.blkb	1
! 651       { 0x5100, 0x5133, 0x7600, 0, 0x20 },
.word	$5100
.word	$5133
.word	$7600
.word	0
.byte	$20
.blkb	1
! 652       { 0x5200, 0x5230, 0, 0, 0x20 },
.word	$5200
.word	$5230
.word	0
.word	0
.byte	$20
.blkb	1
! 653       { 0x5300, 0x532e, 0, 0, 0x20 },
.word	$5300
.word	$532E
.word	0
.word	0
.byte	$20
.blkb	1
! 654       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 655       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 656       { 0x565c, 0x567c, 0, 0, 0 },
.word	$565C
.word	$567C
.word	0
.word	0
.byte	0
.blkb	1
! 657       { 0x8500, 0x8700, 0x8900, 0x8b00, 0 },
.word	$8500
.word	$8700
.word	$8900
.word	$8B00
.byte	0
.blkb	1
! 658       { 0x8600, 0x8800, 0x8a00, 0x8c00, 0 },
.word	$8600
.word	$8800
.word	$8A00
.word	$8C00
.byte	0
.blkb	1
! 659       };
!BCC_EOS
! 660   Bit8u
! 661 inb(port)
! 662   Bit16u port;
.text
export	_inb
_inb:
!BCC_EOS
! 663 {
! 664 #asm
!BCC_ASM
_inb.port	set	2
  push bp
  mov bp, sp
    push dx
    mov dx, 4[bp]
    in al, dx
    pop dx
  pop bp
! 672 endasm
!BCC_ENDASM
! 673 }
ret
! 674   Bit16u
! 675 inw(port)
! 676   Bit16u port;
export	_inw
_inw:
!BCC_EOS
! 677 {
! 678 #asm
!BCC_ASM
_inw.port	set	2
  push bp
  mov bp, sp
    push dx
    mov dx, 4[bp]
    in ax, dx
    pop dx
  pop bp
! 686 endasm
!BCC_ENDASM
! 687 }
ret
! 688   void
! 689 outb(port, val)
! 690   Bit16u port;
export	_outb
_outb:
!BCC_EOS
! 691   Bit8u val;
!BCC_EOS
! 692 {
! 693 #asm
!BCC_ASM
_outb.val	set	4
_outb.port	set	2
  push bp
  mov bp, sp
    push ax
    push dx
    mov dx, 4[bp]
    mov al, 6[bp]
    out dx, al
    pop dx
    pop ax
  pop bp
! 704 endasm
!BCC_ENDASM
! 705 }
ret
! 706   void
! 707 outw(port, val)
! 708   Bit16u port;
export	_outw
_outw:
!BCC_EOS
! 709   Bit16u val;
!BCC_EOS
! 710 {
! 711 #asm
!BCC_ASM
_outw.val	set	4
_outw.port	set	2
  push bp
  mov bp, sp
    push ax
    push dx
    mov dx, 4[bp]
    mov ax, 6[bp]
    out dx, ax
    pop dx
    pop ax
  pop bp
! 722 endasm
!BCC_ENDASM
! 723 }
ret
! 724   void
! 725 outb_cmos(cmos_reg, val)
! 726   Bit8u cmos_reg;
export	_outb_cmos
_outb_cmos:
!BCC_EOS
! 727   Bit8u val;
!BCC_EOS
! 728 {
! 729 #asm
!BCC_ASM
_outb_cmos.cmos_reg	set	2
_outb_cmos.val	set	4
  push bp
  mov bp, sp
    mov al, 4[bp] ;; cmos_reg
    out 0x70, al
    mov al, 6[bp] ;; val
    out 0x71, al
  pop bp
! 737 endasm
!BCC_ENDASM
! 738 }
ret
! 739   Bit8u
! 740 inb_cmos(cmos_reg)
! 741   Bit8u cmos_reg;
export	_inb_cmos
_inb_cmos:
!BCC_EOS
! 742 {
! 743 #asm
!BCC_ASM
_inb_cmos.cmos_reg	set	2
  push bp
  mov bp, sp
    mov al, 4[bp] ;; cmos_reg
    out 0x70, al
    in al, 0x71
  pop bp
! 750 endasm
!BCC_ENDASM
! 751 }
ret
! 752   void
! 753 init_rtc()
! 754 {
export	_init_rtc
_init_rtc:
! 755   outb_cmos(0x0a, 0x26);
push	bp
mov	bp,sp
! Debug: list int = const $26 (used reg = )
mov	ax,*$26
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
mov	sp,bp
!BCC_EOS
! 756   outb_cmos(0x0b, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
mov	sp,bp
!BCC_EOS
! 757   inb_cmos(0x0c);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
mov	sp,bp
!BCC_EOS
! 758   inb_cmos(0x0d);
! Debug: list int = const $D (used reg = )
mov	ax,*$D
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
mov	sp,bp
!BCC_EOS
! 759 }
pop	bp
ret
! 760   bx_bool
! 761 rtc_updating()
! 762 {
export	_rtc_updating
_rtc_updating:
! 763   Bit16u count;
!BCC_EOS
! 764   count = 25000;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: eq int = const $61A8 to unsigned short count = [S+4-4] (used reg = )
mov	ax,#$61A8
mov	-2[bp],ax
!BCC_EOS
! 765   while (--count != 0) {
jmp .3
.4:
! 766     if ( (inb_cmos(0x0a) & 0x80) == 0 )
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.5
.6:
! 767       return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 768     }
.5:
! 769   return(1);
.3:
! Debug: predec unsigned short count = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.4
.7:
.2:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 770 }
! 771   Bit8u
! 772 read_byte(seg, offset)
! 773   Bit16u seg;
export	_read_byte
_read_byte:
!BCC_EOS
! 774   Bit16u offset;
!BCC_EOS
! 775 {
! 776 #asm
!BCC_ASM
_read_byte.seg	set	2
_read_byte.offset	set	4
  push bp
  mov bp, sp
    push bx
    push ds
    mov ax, 4[bp] ; segment
    mov ds, ax
    mov bx, 6[bp] ; offset
    mov al, [bx]
    ;; al = return value (byte)
    pop ds
    pop bx
  pop bp
! 789 endasm
!BCC_ENDASM
! 790 }
ret
! 791   Bit16u
! 792 read_word(seg, offset)
! 793   Bit16u seg;
export	_read_word
_read_word:
!BCC_EOS
! 794   Bit16u offset;
!BCC_EOS
! 795 {
! 796 #asm
!BCC_ASM
_read_word.seg	set	2
_read_word.offset	set	4
  push bp
  mov bp, sp
    push bx
    push ds
    mov ax, 4[bp] ; segment
    mov ds, ax
    mov bx, 6[bp] ; offset
    mov ax, [bx]
    ;; ax = return value (word)
    pop ds
    pop bx
  pop bp
! 809 endasm
!BCC_ENDASM
! 810 }
ret
! 811   void
! 812 write_byte(seg, offset, data)
! 813   Bit16u seg;
export	_write_byte
_write_byte:
!BCC_EOS
! 814   Bit16u offset;
!BCC_EOS
! 815   Bit8u data;
!BCC_EOS
! 816 {
! 817 #asm
!BCC_ASM
_write_byte.seg	set	2
_write_byte.data	set	6
_write_byte.offset	set	4
  push bp
  mov bp, sp
    push ax
    push bx
    push ds
    mov ax, 4[bp] ; segment
    mov ds, ax
    mov bx, 6[bp] ; offset
    mov al, 8[bp] ; data byte
    mov [bx], al ; write data byte
    pop ds
    pop bx
    pop ax
  pop bp
! 832 endasm
!BCC_ENDASM
! 833 }
ret
! 834   void
! 835 write_word(seg, offset, data)
! 836   Bit16u seg;
export	_write_word
_write_word:
!BCC_EOS
! 837   Bit16u offset;
!BCC_EOS
! 838   Bit16u data;
!BCC_EOS
! 839 {
! 840 #asm
!BCC_ASM
_write_word.seg	set	2
_write_word.data	set	6
_write_word.offset	set	4
  push bp
  mov bp, sp
    push ax
    push bx
    push ds
    mov ax, 4[bp] ; segment
    mov ds, ax
    mov bx, 6[bp] ; offset
    mov ax, 8[bp] ; data word
    mov [bx], ax ; write data word
    pop ds
    pop bx
    pop ax
  pop bp
! 855 endasm
!BCC_ENDASM
! 856 }
ret
! 857   Bit16u
! 858 get_CS()
! 859 {
export	_get_CS
_get_CS:
! 860 #asm
!BCC_ASM
  mov ax, cs
! 862 endasm
!BCC_ENDASM
! 863 }
ret
! 864   Bit16u
! 865 get_SS()
! 866 {
export	_get_SS
_get_SS:
! 867 #asm
!BCC_ASM
  mov ax, ss
! 869 endasm
!BCC_ENDASM
! 870 }
ret
! 871   void
! 872 wrch(c)
! 873   Bit8u c;
export	_wrch
_wrch:
!BCC_EOS
! 874 {
! 875 #asm
!BCC_ASM
_wrch.c	set	2
  push bp
  mov bp, sp
  push bx
  mov ah, #0x0e
  mov al, 4[bp]
  xor bx,bx
  int #0x10
  pop bx
  pop bp
! 885 endasm
!BCC_ENDASM
! 886 }
ret
! 887   void
! 888 send(action, c)
! 889   Bit16u action;
export	_send
_send:
!BCC_EOS
! 890   Bit8u c;
!BCC_EOS
! 891 {
! 892   if (action & 8) outb(0x403, c);
push	bp
mov	bp,sp
! Debug: and int = const 8 to unsigned short action = [S+2+2] (used reg = )
mov	al,4[bp]
and	al,*8
test	al,al
je  	.8
.9:
! Debug: list unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $403 (used reg = )
mov	ax,#$403
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 893   if (action & 4) outb(0x402, c);
.8:
! Debug: and int = const 4 to unsigned short action = [S+2+2] (used reg = )
mov	al,4[bp]
and	al,*4
test	al,al
je  	.A
.B:
! Debug: list unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $402 (used reg = )
mov	ax,#$402
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 894   if (action & 2) {
.A:
! Debug: and int = const 2 to unsigned short action = [S+2+2] (used reg = )
mov	al,4[bp]
and	al,*2
test	al,al
je  	.C
.D:
! 895     if (c == '\n') wrch('\r');
! Debug: logeq int = const $A to unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
cmp	al,*$A
jne 	.E
.F:
! Debug: list int = const $D (used reg = )
mov	ax,*$D
push	ax
! Debug: func () void = wrch+0 (used reg = )
call	_wrch
mov	sp,bp
!BCC_EOS
! 896     wrch(c);
.E:
! Debug: list unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: func () void = wrch+0 (used reg = )
call	_wrch
mov	sp,bp
!BCC_EOS
! 897   }
! 898 }
.C:
pop	bp
ret
! 899   void
! 900 put_int(action, val, width, neg)
! 901   Bit16u action;
export	_put_int
_put_int:
!BCC_EOS
! 902   short val, width;
!BCC_EOS
! 903   bx_bool neg;
!BCC_EOS
! 904 {
! 905   short nval = val / 10;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: div int = const $A to short val = [S+4+4] (used reg = )
mov	ax,6[bp]
mov	bx,*$A
cwd
idiv	bx
! Debug: eq int = ax+0 to short nval = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 906   if (nval)
mov	ax,-2[bp]
test	ax,ax
je  	.10
.11:
! 907     put_int(action, nval, width - 1, neg);
! Debug: list unsigned short neg = [S+4+8] (used reg = )
push	$A[bp]
! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
mov	ax,8[bp]
! Debug: list int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list short nval = [S+8-4] (used reg = )
push	-2[bp]
! Debug: list unsigned short action = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () void = put_int+0 (used reg = )
call	_put_int
add	sp,*8
!BCC_EOS
! 908   else {
jmp .12
.10:
! 909     while (--width > 0) send(action, ' ');
jmp .14
.15:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 910     if (neg) send(action, '-');
.14:
! Debug: predec short width = [S+4+6] (used reg = )
mov	ax,8[bp]
dec	ax
mov	8[bp],ax
! Debug: gt int = const 0 to short = ax+0 (used reg = )
test	ax,ax
jg 	.15
.16:
.13:
mov	ax,$A[bp]
test	ax,ax
je  	.17
.18:
! Debug: list int = const $2D (used reg = )
mov	ax,*$2D
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 911   }
.17:
! 912   send(action, val - (nval * 10) + '0');
.12:
! Debug: mul int = const $A to short nval = [S+4-4] (used reg = )
mov	ax,-2[bp]
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
! Debug: sub int = ax+0 to short val = [S+4+4] (used reg = )
push	ax
mov	ax,6[bp]
sub	ax,-4[bp]
inc	sp
inc	sp
! Debug: add int = const $30 to int = ax+0 (used reg = )
! Debug: list int = ax+$30 (used reg = )
add	ax,*$30
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 913 }
mov	sp,bp
pop	bp
ret
! 914   void
! Register BX used in function put_int
! 915 put_uint(action, val, width, neg)
! 916   Bit16u action;
export	_put_uint
_put_uint:
!BCC_EOS
! 917   unsigned short val;
!BCC_EOS
! 918   short width;
!BCC_EOS
! 919   bx_bool neg;
!BCC_EOS
! 920 {
! 921   unsigned short nval = val / 10;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: div int = const $A to unsigned short val = [S+4+4] (used reg = )
mov	ax,6[bp]
mov	bx,*$A
call	idiv_u
! Debug: eq unsigned int = ax+0 to unsigned short nval = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 922   if (nval)
mov	ax,-2[bp]
test	ax,ax
je  	.19
.1A:
! 923     put_uint(action, nval, width - 1, neg);
! Debug: list unsigned short neg = [S+4+8] (used reg = )
push	$A[bp]
! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
mov	ax,8[bp]
! Debug: list int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list unsigned short nval = [S+8-4] (used reg = )
push	-2[bp]
! Debug: list unsigned short action = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () void = put_uint+0 (used reg = )
call	_put_uint
add	sp,*8
!BCC_EOS
! 924   else {
jmp .1B
.19:
! 925     while (--width > 0) send(action, ' ');
jmp .1D
.1E:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 926     if (neg) send(action, '-');
.1D:
! Debug: predec short width = [S+4+6] (used reg = )
mov	ax,8[bp]
dec	ax
mov	8[bp],ax
! Debug: gt int = const 0 to short = ax+0 (used reg = )
test	ax,ax
jg 	.1E
.1F:
.1C:
mov	ax,$A[bp]
test	ax,ax
je  	.20
.21:
! Debug: list int = const $2D (used reg = )
mov	ax,*$2D
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 927   }
.20:
! 928   send(action, val - (nval * 10) + '0');
.1B:
! Debug: mul int = const $A to unsigned short nval = [S+4-4] (used reg = )
mov	ax,-2[bp]
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
! Debug: sub unsigned int = ax+0 to unsigned short val = [S+4+4] (used reg = )
push	ax
mov	ax,6[bp]
sub	ax,-4[bp]
inc	sp
inc	sp
! Debug: add int = const $30 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax+$30 (used reg = )
add	ax,*$30
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 929 }
mov	sp,bp
pop	bp
ret
! 930   void
! Register BX used in function put_uint
! 931 put_luint(action, val, width, neg)
! 932   Bit16u action;
export	_put_luint
_put_luint:
!BCC_EOS
! 933   unsigned long val;
!BCC_EOS
! 934   short width;
!BCC_EOS
! 935   bx_bool neg;
!BCC_EOS
! 936 {
! 937   unsigned long nval = val / 10;
push	bp
mov	bp,sp
add	sp,*-4
! Debug: div unsigned long = const $A to unsigned long val = [S+6+4] (used reg = )
mov	ax,*$A
xor	bx,bx
push	bx
push	ax
mov	ax,6[bp]
mov	bx,8[bp]
lea	di,-8[bp]
call	ldivul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long nval = [S+6-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 938   if (nval)
mov	ax,-4[bp]
mov	bx,-2[bp]
call	ltstl
je  	.22
.23:
! 939     put_luint(action, nval, wid
! 939 th - 1, neg);
! Debug: list unsigned short neg = [S+6+$A] (used reg = )
push	$C[bp]
! Debug: sub int = const 1 to short width = [S+8+8] (used reg = )
mov	ax,$A[bp]
! Debug: list int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list unsigned long nval = [S+$A-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list unsigned short action = [S+$E+2] (used reg = )
push	4[bp]
! Debug: func () void = put_luint+0 (used reg = )
call	_put_luint
add	sp,*$A
!BCC_EOS
! 940   else {
jmp .24
.22:
! 941     while (--width > 0) send(action, ' ');
jmp .26
.27:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned short action = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 942     if (neg) send(action, '-');
.26:
! Debug: predec short width = [S+6+8] (used reg = )
mov	ax,$A[bp]
dec	ax
mov	$A[bp],ax
! Debug: gt int = const 0 to short = ax+0 (used reg = )
test	ax,ax
jg 	.27
.28:
.25:
mov	ax,$C[bp]
test	ax,ax
je  	.29
.2A:
! Debug: list int = const $2D (used reg = )
mov	ax,*$2D
push	ax
! Debug: list unsigned short action = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 943   }
.29:
! 944   send(action, val - (nval * 10) + '0');
.24:
! Debug: mul unsigned long = const $A to unsigned long nval = [S+6-6] (used reg = )
! Debug: expression subtree swapping
mov	ax,*$A
xor	bx,bx
lea	di,-4[bp]
call	lmulul
! Debug: sub unsigned long = bx+0 to unsigned long val = [S+6+4] (used reg = )
push	bx
push	ax
mov	ax,6[bp]
mov	bx,8[bp]
lea	di,-8[bp]
call	lsubul
add	sp,*4
! Debug: add unsigned long = const $30 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$30
xor	bx,bx
push	bx
push	ax
mov	ax,-8[bp]
mov	bx,-6[bp]
lea	di,-$C[bp]
call	laddul
add	sp,*8
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short action = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*6
!BCC_EOS
! 945 }
mov	sp,bp
pop	bp
ret
! 946 void put_str(action, segment, offset)
! Register BX used in function put_luint
! 947   Bit16u action;
export	_put_str
_put_str:
!BCC_EOS
! 948   Bit16u segment;
!BCC_EOS
! 949   Bit16u offset;
!BCC_EOS
! 950 {
! 951   Bit8u c;
!BCC_EOS
! 952   while (c = read_byte(segment, offset)) {
push	bp
mov	bp,sp
dec	sp
dec	sp
jmp .2C
.2D:
! 953     send(action, c);
! Debug: list unsigned char c = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 954     offset++;
! Debug: postinc unsigned short offset = [S+4+6] (used reg = )
mov	ax,8[bp]
inc	ax
mov	8[bp],ax
!BCC_EOS
! 955   }
! 956 }
.2C:
! Debug: list unsigned short offset = [S+4+6] (used reg = )
push	8[bp]
! Debug: list unsigned short segment = [S+6+4] (used reg = )
push	6[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+4-3] (used reg = )
mov	-1[bp],al
test	al,al
jne	.2D
.2E:
.2B:
mov	sp,bp
pop	bp
ret
! 957   void
! 958 delay_ticks(ticks)
! 959   Bit16u ticks;
export	_delay_ticks
_delay_ticks:
!BCC_EOS
! 960 {
! 961   long ticks_to_wait, delta;
!BCC_EOS
! 962   Bit32u prev_ticks, t;
!BCC_EOS
! 963 #asm
push	bp
mov	bp,sp
add	sp,*-$10
!BCC_EOS
!BCC_ASM
_delay_ticks.ticks	set	$14
.delay_ticks.ticks	set	4
_delay_ticks.t	set	0
.delay_ticks.t	set	-$10
_delay_ticks.prev_ticks	set	4
.delay_ticks.prev_ticks	set	-$C
_delay_ticks.delta	set	8
.delay_ticks.delta	set	-8
_delay_ticks.ticks_to_wait	set	$C
.delay_ticks.ticks_to_wait	set	-4
  pushf
  sti
! 966 endasm
!BCC_ENDASM
!BCC_EOS
! 967   ticks_to_wait = ticks;
! Debug: eq unsigned short ticks = [S+$12+2] to long ticks_to_wait = [S+$12-6] (used reg = )
mov	ax,4[bp]
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 968   prev_ticks = read_dword(0x0, 0x46c);
! Debug: list int = const $46C (used reg = )
mov	ax,#$46C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long prev_ticks = [S+$12-$E] (used reg = )
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! 969   do
! 970   {
.31:
! 971 #asm
!BCC_EOS
!BCC_ASM
_delay_ticks.ticks	set	$14
.delay_ticks.ticks	set	4
_delay_ticks.t	set	0
.delay_ticks.t	set	-$10
_delay_ticks.prev_ticks	set	4
.delay_ticks.prev_ticks	set	-$C
_delay_ticks.delta	set	8
.delay_ticks.delta	set	-8
_delay_ticks.ticks_to_wait	set	$C
.delay_ticks.ticks_to_wait	set	-4
    hlt
! 973 endasm
!BCC_ENDASM
!BCC_EOS
! 974     t = read_dword(0x0, 0x46c);
! Debug: list int = const $46C (used reg = )
mov	ax,#$46C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long t = [S+$12-$12] (used reg = )
mov	-$10[bp],ax
mov	-$E[bp],bx
!BCC_EOS
! 975     if (t > prev_ticks)
! Debug: gt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
mov	ax,-$C[bp]
mov	bx,-$A[bp]
lea	di,-$10[bp]
call	lcmpul
jae 	.32
.33:
! 976     {
! 977       delta = t - prev_ticks;
! Debug: sub unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
mov	ax,-$10[bp]
mov	bx,-$E[bp]
lea	di,-$C[bp]
call	lsubul
! Debug: eq unsigned long = bx+0 to long delta = [S+$12-$A] (used reg = )
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 978       ticks_to_wait -= delta;
! Debug: subab long delta = [S+$12-$A] to long ticks_to_wait = [S+$12-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-8[bp]
call	lsubl
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 979     }
! 980     else if (t < prev_ticks)
jmp .34
.32:
! Debug: lt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
mov	ax,-$C[bp]
mov	bx,-$A[bp]
lea	di,-$10[bp]
call	lcmpul
jbe 	.35
.36:
! 981     {
! 982       ticks_to_wait -= t;
! Debug: subab unsigned long t = [S+$12-$12] to long ticks_to_wait = [S+$12-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-$10[bp]
call	lsubul
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 983     }
! 984     prev_ticks = t;
.35:
.34:
! Debug: eq unsigned long t = [S+$12-$12] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
mov	ax,-$10[bp]
mov	bx,-$E[bp]
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! 985   } while (ticks_to_wait > 0);
.30:
! Debug: gt long = const 0 to long ticks_to_wait = [S+$12-6] (used reg = )
xor	ax,ax
xor	bx,bx
lea	di,-4[bp]
call	lcmpl
blt 	.31
.37:
!BCC_EOS
! 986 #asm
.2F:
!BCC_EOS
!BCC_ASM
_delay_ticks.ticks	set	$14
.delay_ticks.ticks	set	4
_delay_ticks.t	set	0
.delay_ticks.t	set	-$10
_delay_ticks.prev_ticks	set	4
.delay_ticks.prev_ticks	set	-$C
_delay_ticks.delta	set	8
.delay_ticks.delta	set	-8
_delay_ticks.ticks_to_wait	set	$C
.delay_ticks.ticks_to_wait	set	-4
  cli
  popf
! 989 endasm
!BCC_ENDASM
!BCC_EOS
! 990 }
mov	sp,bp
pop	bp
ret
! 991   Bit8u
! Register BX used in function delay_ticks
! 992 check_for_keystroke()
! 993 {
export	_check_for_keystroke
_check_for_keystroke:
! 994 #asm
!BCC_ASM
  mov ax, #0x100
  int #0x16
  jz no_key
  mov al, #1
  jmp done
no_key:
  xor al, al
done:
! 1003 endasm
!BCC_ENDASM
! 1004 }
ret
! 1005   Bit8u
! 1006 get_keystroke()
! 1007 {
export	_get_keystroke
_get_keystroke:
! 1008 #asm
!BCC_ASM
  mov ax, #0x0
  int #0x16
  xchg ah, al
! 1012 endasm
!BCC_ENDASM
! 1013 }
ret
! 1014   void
! 1015 delay_ticks_and_check_for_keystroke(ticks, count)
! 1016   Bit16u ticks, count;
export	_delay_ticks_and_check_for_keystroke
_delay_ticks_and_check_for_keystroke:
!BCC_EOS
! 1017 {
! 1018   Bit16u i;
!BCC_EOS
! 1019   for (i = 1; i <= count; i++) {
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: eq int = const 1 to unsigned short i = [S+4-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
!BCC_EOS
jmp .3A
.3B:
! 1020     delay_ticks(ticks);
! Debug: list unsigned short ticks = [S+4+2] (used reg = )
push	4[bp]
! Debug: func () void = delay_ticks+0 (used reg = )
call	_delay_ticks
inc	sp
inc	sp
!BCC_EOS
! 1021     if (check_for_keystroke())
! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
call	_check_for_keystroke
test	al,al
je  	.3C
.3D:
! 1022       break;
jmp .38
!BCC_EOS
! 1023   }
.3C:
! 1024 }
.39:
! Debug: postinc unsigned short i = [S+4-4] (used reg = )
mov	ax,-2[bp]
inc	ax
mov	-2[bp],ax
.3A:
! Debug: le unsigned short count = [S+4+4] to unsigned short i = [S+4-4] (used reg = )
mov	ax,-2[bp]
cmp	ax,6[bp]
jbe	.3B
.3E:
.38:
mov	sp,bp
pop	bp
ret
! 1025   void
! 1026 bios_printf(action, s)
! 1027   Bit16u action;
export	_bios_printf
_bios_printf:
!BCC_EOS
! 1028   Bit8u *s;
!BCC_EOS
! 1029 {
! 1030   Bit8u c, format_char;
!BCC_EOS
! 1031   bx_bool in_format;
!BCC_EOS
! 1032   short i;
!BCC_EOS
! 1033   Bit16u *arg_ptr;
!BCC_EOS
! 1034   Bit16u arg_seg, arg, nibble, hibyte, shift_count, format_width, hexadd;
!BCC_EOS
! 1035   arg_ptr = &s;
push	bp
mov	bp,sp
add	sp,*-$16
! Debug: eq * * unsigned char s = S+$18+4 to * unsigned short arg_ptr = [S+$18-$A] (used reg = )
lea	bx,6[bp]
mov	-8[bp],bx
!BCC_EOS
! 1036   arg_seg = get_SS();
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short arg_seg = [S+$18-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 1037   in_format = 0;
! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
xor	ax,ax
mov	-4[bp],ax
!BCC_EOS
! 1038   format_width = 0;
! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
xor	ax,ax
mov	-$14[bp],ax
!BCC_EOS
! 1039   if ((action & (2 | 4 | 1)) == (2 | 4 | 1)) {
! Debug: and int = const 7 to unsigned short action = [S+$18+2] (used reg = )
mov	al,4[bp]
and	al,*7
! Debug: logeq int = const 7 to unsigned char = al+0 (used reg = )
cmp	al,*7
jne 	.3F
.40:
! 1040     outb(0x401, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $401 (used reg = )
mov	ax,#$401
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1041     bios_printf (2, "FATAL: ");
! Debug: list * char = .41+0 (used reg = )
mov	bx,#.41
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1042   }
! 1043   while (c = read_byte(get_CS(), s)) {
.3F:
br 	.43
.44:
! 1044     if ( c == '%' ) {
! Debug: logeq int = const $25 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$25
jne 	.45
.46:
! 1045       in_format = 1;
! Debug: eq int = const 1 to unsigned short in_format = [S+$18-6] (used reg = )
mov	ax,*1
mov	-4[bp],ax
!BCC_EOS
! 1046       format_width = 0;
! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
xor	ax,ax
mov	-$14[bp],ax
!BCC_EOS
! 1047     }
! 1048     else if (in_format) {
br 	.47
.45:
mov	ax,-4[bp]
test	ax,ax
beq 	.48
.49:
! 1049       if ( (c>='0') && (c<='9') ) {
! Debug: ge int = const $30 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$30
jb  	.4A
.4C:
! Debug: le int = const $39 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$39
ja  	.4A
.4B:
! 1050         format_width = (format_width * 10) + (c - '0');
! Debug: sub int = const $30 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
add	ax,*-$30
push	ax
! Debug: mul int = const $A to unsigned short format_width = [S+$1A-$16] (used reg = )
mov	ax,-$14[bp]
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
! Debug: add unsigned int (temp) = [S+$1A-$1A] to unsigned int = ax+0 (used reg = )
add	ax,-$18[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	-$14[bp],ax
!BCC_EOS
! 1051       }
! 1052       else {
br 	.4D
.4A:
! 1053         arg_ptr++;
! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
mov	bx,-8[bp]
inc	bx
inc	bx
mov	-8[bp],bx
!BCC_EOS
! 1054         arg = read_word(arg_seg, arg_ptr);
! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
push	-8[bp]
! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 1055         if (c == 'x' || c == 'X') {
! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$78
je  	.4F
.50:
! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$58
jne 	.4E
.4F:
! 1056           if (format_width == 0)
! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,-$14[bp]
test	ax,ax
jne 	.51
.52:
! 1057             format_width = 4;
! 1057 
! Debug: eq int = const 4 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,*4
mov	-$14[bp],ax
!BCC_EOS
! 1058           if (c == 'x')
.51:
! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$78
jne 	.53
.54:
! 1059             hexadd = 'a';
! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
mov	ax,*$61
mov	-$16[bp],ax
!BCC_EOS
! 1060           else
! 1061             hexadd = 'A';
jmp .55
.53:
! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
mov	ax,*$41
mov	-$16[bp],ax
!BCC_EOS
! 1062           for (i=format_width-1; i>=0; i--) {
.55:
! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,-$14[bp]
! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
dec	ax
mov	-6[bp],ax
!BCC_EOS
!BCC_EOS
jmp .58
.59:
! 1063             nibble = (arg >> (4 * i)) & 0x000f;
! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
! Debug: expression subtree swapping
mov	ax,-6[bp]
shl	ax,*1
shl	ax,*1
! Debug: sr int = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
mov	bx,ax
mov	ax,-$C[bp]
mov	cx,bx
shr	ax,cl
! Debug: and int = const $F to unsigned int = ax+0 (used reg = )
and	al,*$F
! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$10] (used reg = )
xor	ah,ah
mov	-$E[bp],ax
!BCC_EOS
! 1064             send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,*9
ja  	.5A
.5B:
! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
add	ax,*$30
jmp .5C
.5A:
! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
add	ax,*-$A
add	ax,-$16[bp]
.5C:
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short action = [S+$1A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 1065           }
! 1066         }
.57:
! Debug: postdec short i = [S+$18-8] (used reg = )
mov	ax,-6[bp]
dec	ax
mov	-6[bp],ax
.58:
! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
mov	ax,-6[bp]
test	ax,ax
jge	.59
.5D:
.56:
! 1067         else if (c == 'u') {
br 	.5E
.4E:
! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$75
jne 	.5F
.60:
! 1068           put_uint(action, arg, format_width, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short action = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: func () void = put_uint+0 (used reg = )
call	_put_uint
add	sp,*8
!BCC_EOS
! 1069         }
! 1070         else if (c == 'l') {
br 	.61
.5F:
! Debug: logeq int = const $6C to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$6C
bne 	.62
.63:
! 1071           s++;
! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
mov	bx,6[bp]
inc	bx
mov	6[bp],bx
!BCC_EOS
! 1072           c = read_byte(get_CS(), s);
! Debug: list * unsigned char s = [S+$18+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = get_CS+0 (used reg = )
call	_get_CS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 1073           arg_ptr++;
! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
mov	bx,-8[bp]
inc	bx
inc	bx
mov	-8[bp],bx
!BCC_EOS
! 1074           hibyte = read_word(arg_seg, arg_ptr);
! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
push	-8[bp]
! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short hibyte = [S+$18-$12] (used reg = )
mov	-$10[bp],ax
!BCC_EOS
! 1075           if (c == 'd') {
! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$64
jne 	.64
.65:
! 1076             if (hibyte & 0x8000)
! Debug: and unsigned int = const $8000 to unsigned short hibyte = [S+$18-$12] (used reg = )
mov	ax,-$10[bp]
and	ax,#$8000
test	ax,ax
je  	.66
.67:
! 1077               put_luint(action, 0L-(((Bit32u) hibyte << 16) | arg), format_width-1, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
mov	ax,-$14[bp]
! Debug: list unsigned int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
lea	di,-$1E[bp]
call	lorul
add	sp,*4
! Debug: sub unsigned long = bx+0 to long = const 0 (used reg = )
push	bx
push	ax
xor	ax,ax
xor	bx,bx
lea	di,-$1E[bp]
call	lsubul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short action = [S+$20+2] (used reg = )
push	4[bp]
! Debug: func () void = put_luint+0 (used reg = )
call	_put_luint
add	sp,*$A
!BCC_EOS
! 1078             else
! 1079               put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
jmp .68
.66:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
lea	di,-$1E[bp]
call	lorul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short action = [S+$20+2] (used reg = )
push	4[bp]
! Debug: func () void = put_luint+0 (used reg = )
call	_put_luint
add	sp,*$A
!BCC_EOS
! 1080           }
.68:
! 1081           else if (c == 'u') {
br 	.69
.64:
! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$75
jne 	.6A
.6B:
! 1082             put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
lea	di,-$1E[bp]
call	lorul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short action = [S+$20+2] (used reg = )
push	4[bp]
! Debug: func () void = put_luint+0 (used reg = )
call	_put_luint
add	sp,*$A
!BCC_EOS
! 1083           }
! 1084           else if (c == 'x' || c == 'X')
br 	.6C
.6A:
! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$78
je  	.6E
.6F:
! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$58
bne 	.6D
.6E:
! 1085           {
! 1086             if (format_width == 0)
! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,-$14[bp]
test	ax,ax
jne 	.70
.71:
! 1087               format_width = 8;
! Debug: eq int = const 8 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,*8
mov	-$14[bp],ax
!BCC_EOS
! 1088             if (c == 'x')
.70:
! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$78
jne 	.72
.73:
! 1089               hexadd = 'a';
! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
mov	ax,*$61
mov	-$16[bp],ax
!BCC_EOS
! 1090             else
! 1091               hexadd = 'A';
jmp .74
.72:
! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
mov	ax,*$41
mov	-$16[bp],ax
!BCC_EOS
! 1092             for (i=format_width-1; i>=0; i--) {
.74:
! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,-$14[bp]
! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
dec	ax
mov	-6[bp],ax
!BCC_EOS
!BCC_EOS
jmp .77
.78:
! 1093               nibble = ((((Bit32u) hibyte <<16) | arg) >> (4 * i)) & 0x000f;
! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
! Debug: expression subtree swapping
mov	ax,-6[bp]
shl	ax,*1
shl	ax,*1
push	ax
! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1A-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$1E-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
lea	di,-$1C[bp]
call	lorul
add	sp,*4
! Debug: sr int (temp) = [S+$1A-$1A] to unsigned long = bx+0 (used reg = )
mov	di,-$18[bp]
call	lsrul
inc	sp
inc	sp
! Debug: and unsigned long = const $F to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$F
xor	bx,bx
push	bx
push	ax
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	landul
add	sp,*8
! Debug: eq unsigned long = bx+0 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	-$E[bp],ax
!BCC_EOS
! 1094               send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,*9
ja  	.79
.7A:
! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
add	ax,*$30
jmp .7B
.79:
! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
add	ax,*-$A
add	ax,-$16[bp]
.7B:
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short action = [S+$1A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 1095             }
! 1096           }
.76:
! Debug: postdec short i = [S+$18-8] (used reg = )
mov	ax,-6[bp]
dec	ax
mov	-6[bp],ax
.77:
! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
mov	ax,-6[bp]
test	ax,ax
jge	.78
.7C:
.75:
! 1097         }
.6D:
.6C:
.69:
! 1098         else if (c == 'd') {
br 	.7D
.62:
! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$64
jne 	.7E
.7F:
! 1099           if (arg & 0x8000)
! Debug: and unsigned int = const $8000 to unsigned short arg = [S+$18-$E] (used reg = )
mov	ax,-$C[bp]
and	ax,#$8000
test	ax,ax
je  	.80
.81:
! 1100             put_int(action, -arg, format_width - 1, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
mov	ax,-$14[bp]
! Debug: list unsigned int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: neg unsigned short arg = [S+$1C-$E] (used reg = )
xor	ax,ax
sub	ax,-$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short action = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: func () void = put_int+0 (used reg = )
call	_put_int
add	sp,*8
!BCC_EOS
! 1101           else
! 1102             put_int(action, arg, format_width, 0);
jmp .82
.80:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short action = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: func () void = put_int+0 (used reg = )
call	_put_int
add	sp,*8
!BCC_EOS
! 1103         }
.82:
! 1104         else if (c == 's') {
jmp .83
.7E:
! Debug: logeq int = const $73 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$73
jne 	.84
.85:
! 1105           put_str(action, get_CS(), arg);
! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
push	-$C[bp]
! Debug: func () unsigned short = get_CS+0 (used reg = )
call	_get_CS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list unsigned short action = [S+$1C+2] (used reg = )
push	4[bp]
! Debug: func () void = put_str+0 (used reg = )
call	_put_str
add	sp,*6
!BCC_EOS
! 1106         }
! 1107         else if (c == 'S') {
jmp .86
.84:
! Debug: logeq int = const $53 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$53
jne 	.87
.88:
! 1108           hibyte = arg;
! Debug: eq unsigned short arg = [S+$18-$E] to unsigned short hibyte = [S+$18-$12] (used reg = )
mov	ax,-$C[bp]
mov	-$10[bp],ax
!BCC_EOS
! 1109           arg_ptr++;
! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
mov	bx,-8[bp]
inc	bx
inc	bx
mov	-8[bp],bx
!BCC_EOS
! 1110           arg = read_word(arg_seg, arg_ptr);
! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
push	-8[bp]
! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 1111           put_str(action, hibyte, arg);
! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short hibyte = [S+$1A-$12] (used reg = )
push	-$10[bp]
! Debug: list unsigned short action = [S+$1C+2] (used reg = )
push	4[bp]
! Debug: func () void = put_str+0 (used reg = )
call	_put_str
add	sp,*6
!BCC_EOS
! 1112         }
! 1113         else if (c == 'c') {
jmp .89
.87:
! Debug: logeq int = const $63 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$63
jne 	.8A
.8B:
! 1114           send(action, arg);
! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short action = [S+$1A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 1115         }
! 1116         else
! 1117           bios_printf((2 | 4 | 1), "bios_printf: unknown format\n");
jmp .8C
.8A:
! Debug: list * char = .8D+0 (used reg = )
mov	bx,#.8D
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1118           in_format = 0;
.8C:
.89:
.86:
.83:
.7D:
.61:
.5E:
! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
xor	ax,ax
mov	-4[bp],ax
!BCC_EOS
! 1119       }
! 1120     }
.4D:
! 1121     else {
jmp .8E
.48:
! 1122       send(action, c);
! Debug: list unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short action = [S+$1A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 1123     }
! 1124     s ++;
.8E:
.47:
! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
mov	bx,6[bp]
inc	bx
mov	6[bp],bx
!BCC_EOS
! 1125   }
! 1126   if (a
.43:
! Debug: list * unsigned char s = [S+$18+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = get_CS+0 (used reg = )
call	_get_CS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
mov	-1[bp],al
test	al,al
bne 	.44
.8F:
.42:
! 1126 ction & 1) {
! Debug: and int = const 1 to unsigned short action = [S+$18+2] (used reg = )
mov	al,4[bp]
and	al,*1
test	al,al
je  	.90
.91:
! 1127 #asm
!BCC_EOS
!BCC_ASM
_bios_printf.format_width	set	2
.bios_printf.format_width	set	-$14
_bios_printf.format_char	set	$14
.bios_printf.format_char	set	-2
_bios_printf.hibyte	set	6
.bios_printf.hibyte	set	-$10
_bios_printf.arg_ptr	set	$E
.bios_printf.arg_ptr	set	-8
_bios_printf.action	set	$1A
.bios_printf.action	set	4
_bios_printf.i	set	$10
.bios_printf.i	set	-6
_bios_printf.arg_seg	set	$C
.bios_printf.arg_seg	set	-$A
_bios_printf.shift_count	set	4
.bios_printf.shift_count	set	-$12
_bios_printf.in_format	set	$12
.bios_printf.in_format	set	-4
_bios_printf.s	set	$1C
.bios_printf.s	set	6
_bios_printf.nibble	set	8
.bios_printf.nibble	set	-$E
_bios_printf.c	set	$15
.bios_printf.c	set	-1
_bios_printf.hexadd	set	0
.bios_printf.hexadd	set	-$16
_bios_printf.arg	set	$A
.bios_printf.arg	set	-$C
    cli
 halt2_loop:
    hlt
    jmp halt2_loop
! 1132 endasm
!BCC_ENDASM
!BCC_EOS
! 1133   }
! 1134 }
.90:
mov	sp,bp
pop	bp
ret
! 1135   void
! Register BX used in function bios_printf
! 1136 keyboard_init()
! 1137 {
export	_keyboard_init
_keyboard_init:
! 1138     Bit16u max;
!BCC_EOS
! 1139     max=0xffff;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1140     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
jmp .93
.94:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1141     max=0x2000;
.93:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.95
.96:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.94
.95:
.92:
! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$2000
mov	-2[bp],ax
!BCC_EOS
! 1142     while (--max > 0) {
jmp .98
.99:
! 1143         outb(0x80, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1144         if (inb(0x64) & 0x01) {
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
test	al,al
je  	.9A
.9B:
! 1145             inb(0x60);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
!BCC_EOS
! 1146             max = 0x2000;
! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$2000
mov	-2[bp],ax
!BCC_EOS
! 1147         }
! 1148     }
.9A:
! 1149     outb(0x64, 0xaa);
.98:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.99
.9C:
.97:
! Debug: list int = const $AA (used reg = )
mov	ax,#$AA
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1150     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1151     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
jmp .9E
.9F:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1152     if (max==0x0) keyboard_panic(00);
.9E:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.A0
.A1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.9F
.A0:
.9D:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.A2
.A3:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1153     max=0xffff;
.A2:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1154     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x01);
jmp .A5
.A6:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1155     if (max==0x0) keyboard_panic(01);
.A5:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.A7
.A8:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.A6
.A7:
.A4:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.A9
.AA:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1156     if ((inb(0x60) != 0x55)){
.A9:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $55 to unsigned char = al+0 (used reg = )
cmp	al,*$55
je  	.AB
.AC:
! 1157         keyboard_panic(991);
! Debug: list int = const $3DF (used reg = )
mov	ax,#$3DF
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1158     }
! 1159     outb(0x64,0xab);
.AB:
! Debug: list int = const $AB (used reg = )
mov	ax,#$AB
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1160     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1161     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x10);
jmp .AE
.AF:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1162     if (max==0x0) keyboard_panic(10);
.AE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.B0
.B1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.AF
.B0:
.AD:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.B2
.B3:
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1163     max=0xffff;
.B2:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1164     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x11);
jmp .B5
.B6:
! Debug: list int = const $11 (used reg = )
mov	ax,*$11
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1165     if (max==0x0) keyboard_panic(11);
.B5:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.B7
.B8:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.B6
.B7:
.B4:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.B9
.BA:
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1166     if ((inb(0x60) != 0x00)) {
.B9:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.BB
.BC:
! 1167         keyboard_panic(992);
! Debug: list int = const $3E0 (used reg = )
mov	ax,#$3E0
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1168     }
! 1169     outb(0x64,0xae);
.BB:
! Debug: list int = const $AE (used reg = )
mov	ax,#$AE
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1170     outb(0x64,0xa8);
! Debug: list int = const $A8 (used reg = )
mov	ax,#$A8
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1171     outb(0x60, 0xff);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1172     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1173     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x20);
jmp .BE
.BF:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1174     if (max==0x0) keyboard_panic(20);
.BE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.C0
.C1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.BF
.C0:
.BD:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.C2
.C3:
! Debug: list int = const $14 (used reg = )
mov	ax,*$14
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1175     max=0xffff;
.C2:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1176     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x21);
jmp .C5
.C6:
! Debug: list int = const $21 (used reg = )
mov	ax,*$21
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1177     if (max==0x0) keyboard_panic(21);
.C5:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.C7
.C8:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.C6
.C7:
.C4:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.C9
.CA:
! Debug: list int = const $15 (used reg = )
mov	ax,*$15
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1178     if ((inb(0x60) != 0xfa)) {
.C9:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
je  	.CB
.CC:
! 1179         keyboard_panic(993);
! Debug: list int = const $3E1 (used reg = )
mov	ax,#$3E1
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1180     }
! 1181     max=0xffff;
.CB:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1182     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x31);
jmp .CE
.CF:
! Debug: list int = const $31 (used reg = )
mov	ax,*$31
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1183     if (max==0x0) keyboard_panic(31);
.CE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.D0
.D1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.CF
.D0:
.CD:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.D2
.D3:
! Debug: list int = const $1F (used reg = )
mov	ax,*$1F
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1184     if ((inb(0x60) != 0xaa)) {
.D2:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $AA to unsigned char = al+0 (used reg = )
cmp	al,#$AA
je  	.D4
.D5:
! 1185         keyboard_panic(994);
! Debug: list int = const $3E2 (used reg = )
mov	ax,#$3E2
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1186     }
! 1187     outb(0x60, 0xf5);
.D4:
! Debug: list int = const $F5 (used reg = )
mov	ax,#$F5
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1188     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1189     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x40);
jmp .D7
.D8:
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1190     if (max==0x0) keyboard_panic(40);
.D7:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.D9
.DA:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.D8
.D9:
.D6:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.DB
.DC:
! Debug: list int = const $28 (used reg = )
mov	ax,*$28
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1191     max=0xffff;
.DB:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1192     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x41);
jmp .DE
.DF:
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1193     if (max==0x0) keyboard_panic(41);
.DE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.E0
.E1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.DF
.E0:
.DD:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.E2
.E3:
! Debug: list int = const $29 (used reg = )
mov	ax,*$29
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1194     if ((inb(0x60) != 0xfa)) {
.E2:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
je  	.E4
.E5:
! 1195         keyboard_panic(995);
! Debug: list int = const $3E3 (used reg = )
mov	ax,#$3E3
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1196     }
! 1197     outb(0x64, 0x60);
.E4:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1198     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1199     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x50);
jmp .E7
.E8:
! Debug: list int = const $50 (used reg = )
mov	ax,*$50
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1200     if (max==0x0) keyboard_panic(50);
.E7:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.E9
.EA:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.E8
.E9:
.E6:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.EB
.EC:
! 1200 
! Debug: list int = const $32 (used reg = )
mov	ax,*$32
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1201     outb(0x60, 0x61);
.EB:
! Debug: list int = const $61 (used reg = )
mov	ax,*$61
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1202     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1203     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x60);
jmp .EE
.EF:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1204     if (max==0x0) keyboard_panic(60);
.EE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.F0
.F1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.EF
.F0:
.ED:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.F2
.F3:
! Debug: list int = const $3C (used reg = )
mov	ax,*$3C
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1205     outb(0x60, 0xf4);
.F2:
! Debug: list int = const $F4 (used reg = )
mov	ax,#$F4
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1206     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1207     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x70);
jmp .F5
.F6:
! Debug: list int = const $70 (used reg = )
mov	ax,*$70
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1208     if (max==0x0) keyboard_panic(70);
.F5:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.F7
.F8:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.F6
.F7:
.F4:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.F9
.FA:
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1209     max=0xffff;
.F9:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1210     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x71);
jmp .FC
.FD:
! Debug: list int = const $71 (used reg = )
mov	ax,*$71
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1211     if (max==0x0) keyboard_panic(70);
.FC:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.FE
.FF:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.FD
.FE:
.FB:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.100
.101:
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1212     if ((inb(0x60) != 0xfa)) {
.100:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
je  	.102
.103:
! 1213         keyboard_panic(996);
! Debug: list int = const $3E4 (used reg = )
mov	ax,#$3E4
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1214     }
! 1215     outb(0x80, 0x77);
.102:
! Debug: list int = const $77 (used reg = )
mov	ax,*$77
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1216 }
mov	sp,bp
pop	bp
ret
! 1217   void
! 1218 keyboard_panic(status)
! 1219   Bit16u status;
export	_keyboard_panic
_keyboard_panic:
!BCC_EOS
! 1220 {
! 1221   bios_printf((2 | 4 | 1), "Keyboard error:%u\n",status);
push	bp
mov	bp,sp
! Debug: list unsigned short status = [S+2+2] (used reg = )
push	4[bp]
! Debug: list * char = .104+0 (used reg = )
mov	bx,#.104
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1222 }
pop	bp
ret
! 1223   void
! Register BX used in function keyboard_panic
! 1224 shutdown_status_panic(status)
! 1225   Bit16u status;
export	_shutdown_status_panic
_shutdown_status_panic:
!BCC_EOS
! 1226 {
! 1227   bios_printf((2 | 4 | 1), "Unimplemented shutdown status: %02x\n",(Bit8u)status);
push	bp
mov	bp,sp
! Debug: list unsigned char status = [S+2+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: list * char = .105+0 (used reg = )
mov	bx,#.105
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1228 }
pop	bp
ret
! 1229 void s3_resume_panic()
! Register BX used in function shutdown_status_panic
! 1230 {
export	_s3_resume_panic
_s3_resume_panic:
! 1231   bios_printf((2 | 4 | 1), "Returned from s3_resume.\n");
push	bp
mov	bp,sp
! Debug: list * char = .106+0 (used reg = )
mov	bx,#.106
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1232 }
pop	bp
ret
! 1233 void
! Register BX used in function s3_resume_panic
! 1234 print_bios_banner()
! 1235 {
export	_print_bios_banner
_print_bios_banner:
! 1236   bios_printf(2, "Bochs"" BIOS - build: %s\n%s\nOptions: ", "10/11/09", bios_cvs_version_string);
push	bp
mov	bp,sp
! Debug: list * char = bios_cvs_version_string+0 (used reg = )
mov	bx,#_bios_cvs_version_string
push	bx
! Debug: list * char = .108+0 (used reg = )
mov	bx,#.108
push	bx
! Debug: list * char = .107+0 (used reg = )
mov	bx,#.107
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1237   bios_printf(2, "apmbios " "pcibios " "eltorito " "\n\n");
! Debug: list * char = .109+0 (used reg = )
mov	bx,#.109
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1238 }
pop	bp
ret
! 1239 static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
! Register BX used in function print_bios_banner
.data
_drivetypes:
.10A:
.byte	0
.blkb	9
.10B:
.ascii	"Floppy"
.byte	0
.blkb	3
.10C:
.ascii	"Hard Disk"
.byte	0
.10D:
.ascii	"CD-Rom"
.byte	0
.blkb	3
.10E:
.ascii	"Network"
.byte	0
.blkb	2
!BCC_EOS
! 1240 static void
! 1241 init_boot_vectors()
! 1242 {
.text
_init_boot_vectors:
! 1243   ipl_entry_t e;
!BCC_EOS
! 1244   Bit16u count = 0;
push	bp
mov	bp,sp
add	sp,*-$12
! Debug: eq int = const 0 to unsigned short count = [S+$14-$14] (used reg = )
xor	ax,ax
mov	-$12[bp],ax
!BCC_EOS
! 1245   Bit16u ss = get_SS();
dec	sp
dec	sp
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$16] (used reg = )
mov	-$14[bp],ax
!BCC_EOS
! 1246   memsetb(0x9ff0, 0x0000, 0, 0xff);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned int = const $9FF0 (used reg = )
mov	ax,#$9FF0
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 1247   write_word(0x9ff0, 0x0084, 0xFFFF);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: list int = const $84 (used reg = )
mov	ax,#$84
push	ax
! Debug: list unsigned int = const $9FF0 (used reg = )
mov	ax,#$9FF0
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1248   e.type = 0x01; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
! Debug: eq int = const 1 to unsigned short e = [S+$16-$12] (used reg = )
mov	ax,*1
mov	-$10[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
xor	ax,ax
mov	-$E[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1249   memcpyb(0x9ff0, 0x0000 + count * sizeof (e), ss, &e, sizeof (e));
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list * struct  e = S+$18-$12 (used reg = )
lea	bx,-$10[bp]
push	bx
! Debug: list unsigned short ss = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: mul int = const $10 to unsigned short count = [S+$1C-$14] (used reg = )
mov	ax,-$12[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned int = const $9FF0 (used reg = )
mov	ax,#$9FF0
push	ax
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1250   count++;
! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
mov	ax,-$12[bp]
inc	ax
mov	-$12[bp],ax
!BCC_EOS
! 1251   e.type = 0x02; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
! Debug: eq int = const 2 to unsigned short e = [S+$16-$12] (used reg = )
mov	ax,*2
mov	-$10[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
xor	ax,ax
mov	-$E[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1252   memcpyb(0x9ff0, 0x0000 + count * sizeof (e), ss, &e, sizeof (e));
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list * struct  e = S+$18-$12 (used reg = )
lea	bx,-$10[bp]
push	bx
! Debug: list unsigned short ss = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: mul int = const $10 to unsigned short count = [S+$1C-$14] (used reg = )
mov	ax,-$12[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned int = const $9FF0 (used reg = )
mov	ax,#$9FF0
push	ax
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1253   count++;
! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
mov	ax,-$12[bp]
inc	ax
mov	-$12[bp],ax
!BCC_EOS
! 1254   e.type = 0x03; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
! Debug: eq int = const 3 to unsigned short e = [S+$16-$12] (used reg = )
mov	ax,*3
mov	-$10[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
xor	ax,ax
mov	-$E[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1255   memcpyb(0x9ff0, 0x0000 + count * sizeof (e), ss, &e, sizeof (e));
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list * struct  e = S+$18-$12 (used reg = )
lea	bx,-$10[bp]
push	bx
! Debug: list unsigned short ss = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: mul int = const $10 to unsigned short count = [S+$1C-$14] (used reg = )
mov	ax,-$12[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned int = const $9FF0 (used reg = )
mov	ax,#$9FF0
push	ax
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1256   count++;
! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
mov	ax,-$12[bp]
inc	ax
mov	-$12[bp],ax
!BCC_EOS
! 1257   write_word(0x9ff0, 0x0080, count);
! Debug: list unsigned short count = [S+$16-$14] (used reg = )
push	-$12[bp]
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: list unsigned int = const $9FF0 (used reg = )
mov	ax,#$9FF0
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1258   write_word(0x9ff0, 0x0082, 0xffff);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: list int = const $82 (used reg = )
mov	ax,#$82
push	ax
! Debug: list unsigned int = const $9FF0 (used reg = )
mov	ax,#$9FF0
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1259 }
mov	sp,bp
pop	bp
ret
! 1260 static Bit8u
! Register BX used in function init_boot_vectors
! 1261 get_boot_vector(i, e)
! 1262 Bit16u i; ipl_entry_t *e;
_get_boot_vector:
!BCC_EOS
!BCC_EOS
! 1263 {
! 1264   Bit16u count;
!BCC_EOS
! 1265   Bit16u ss = get_SS();
push	bp
mov	bp,sp
add	sp,*-4
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 1266   count = read_word(0x9ff0, 0x0080);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: list unsigned int = const $9FF0 (used reg = )
mov	ax,#$9FF0
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+6-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1267   if (i >= count) return 0;
! Debug: ge unsigned short count = [S+6-4] to unsigned short i = [S+6+2] (used reg = )
mov	ax,4[bp]
cmp	ax,-2[bp]
jb  	.10F
.110:
xor	al,al
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1268   memcpyb(ss, e, 0x9ff0, 0x0000 + i * sizeof (*e), sizeof (*e));
.10F:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: mul int = const $10 to unsigned short i = [S+8+2] (used reg = )
mov	ax,4[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned int = const $9FF0 (used reg = )
mov	ax,#$9FF0
push	ax
! Debug: list * struct  e = [S+$C+4] (used reg = )
push	6[bp]
! Debug: list unsigned short ss = [S+$E-6] (used reg = )
push	-4[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1269   re
! 1269 turn 1;
mov	al,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1270 }
! 1271   void
! 1272 interactive_bootkey()
! 1273 {
export	_interactive_bootkey
_interactive_bootkey:
! 1274   ipl_entry_t e;
!BCC_EOS
! 1275   Bit16u count;
!BCC_EOS
! 1276   char description[33];
!BCC_EOS
! 1277   Bit8u scan_code;
!BCC_EOS
! 1278   Bit8u i;
!BCC_EOS
! 1279   Bit16u ss = get_SS();
push	bp
mov	bp,sp
add	sp,*-$38
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$3A-$3A] (used reg = )
mov	-$38[bp],ax
!BCC_EOS
! 1280   Bit16u valid_choice = 0;
dec	sp
dec	sp
! Debug: eq int = const 0 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
xor	ax,ax
mov	-$3A[bp],ax
!BCC_EOS
! 1281   while (check_for_keystroke())
! 1282     get_keystroke();
jmp .112
.113:
! Debug: func () unsigned char = get_keystroke+0 (used reg = )
call	_get_keystroke
!BCC_EOS
! 1283   bios_printf(2, "Press F12 for boot menu.\n\n");
.112:
! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
call	_check_for_keystroke
test	al,al
jne	.113
.114:
.111:
! Debug: list * char = .115+0 (used reg = )
mov	bx,#.115
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1284   delay_ticks_and_check_for_keystroke(11, 5);
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = delay_ticks_and_check_for_keystroke+0 (used reg = )
call	_delay_ticks_and_check_for_keystroke
add	sp,*4
!BCC_EOS
! 1285   if (check_for_keystroke())
! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
call	_check_for_keystroke
test	al,al
beq 	.116
.117:
! 1286   {
! 1287     scan_code = get_keystroke();
! Debug: func () unsigned char = get_keystroke+0 (used reg = )
call	_get_keystroke
! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3C-$36] (used reg = )
mov	-$34[bp],al
!BCC_EOS
! 1288     if (scan_code == 0x86)
! Debug: logeq int = const $86 to unsigned char scan_code = [S+$3C-$36] (used reg = )
mov	al,-$34[bp]
cmp	al,#$86
bne 	.118
.119:
! 1289     {
! 1290       while (check_for_keystroke())
! 1291         get_keystroke();
jmp .11B
.11C:
! Debug: func () unsigned char = get_keystroke+0 (used reg = )
call	_get_keystroke
!BCC_EOS
! 1292       bios_printf(2, "Select boot device:\n\n");
.11B:
! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
call	_check_for_keystroke
test	al,al
jne	.11C
.11D:
.11A:
! Debug: list * char = .11E+0 (used reg = )
mov	bx,#.11E
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1293       count = read_word(0x9ff0, 0x0080);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: list unsigned int = const $9FF0 (used reg = )
mov	ax,#$9FF0
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$3C-$14] (used reg = )
mov	-$12[bp],ax
!BCC_EOS
! 1294       for (i = 0; i < count; i++)
! Debug: eq int = const 0 to unsigned char i = [S+$3C-$37] (used reg = )
xor	al,al
mov	-$35[bp],al
!BCC_EOS
!BCC_EOS
! 1295       {
br 	.121
.122:
! 1296         memcpyb(ss, &e, 0x9ff0, 0x0000 + i * sizeof (e), sizeof (e));
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: mul int = const $10 to unsigned char i = [S+$3E-$37] (used reg = )
mov	al,-$35[bp]
xor	ah,ah
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned int = const $9FF0 (used reg = )
mov	ax,#$9FF0
push	ax
! Debug: list * struct  e = S+$42-$12 (used reg = )
lea	bx,-$10[bp]
push	bx
! Debug: list unsigned short ss = [S+$44-$3A] (used reg = )
push	-$38[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1297         bios_printf(2, "%d. ", i+1);
! Debug: add int = const 1 to unsigned char i = [S+$3C-$37] (used reg = )
mov	al,-$35[bp]
xor	ah,ah
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * char = .123+0 (used reg = )
mov	bx,#.123
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1298         switch(e.type)
mov	ax,-$10[bp]
! 1299         {
br 	.126
! 1300           case 0x01:
! 1301           case 0x02:
.127:
! 1302           case 0x03:
.128:
! 1303             bios_printf(2, "%s\n", drivetypes[e.type]);
.129:
! Debug: ptradd unsigned short e = [S+$3C-$12] to [5] [$A] char = drivetypes+0 (used reg = )
mov	bx,-$10[bp]
mov	dx,bx
shl	bx,*1
shl	bx,*1
add	bx,dx
shl	bx,*1
! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
! Debug: list * char = bx+_drivetypes+0 (used reg = )
add	bx,#_drivetypes
push	bx
! Debug: list * char = .12A+0 (used reg = )
mov	bx,#.12A
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1304             break;
br 	.124
!BCC_EOS
! 1305           case 0x80:
! 1306             bios_printf(2, "%s", drivetypes[4]);
.12B:
! Debug: list * char = drivetypes+$28 (used reg = )
mov	bx,#_drivetypes+$28
push	bx
! Debug: list * char = .12C+0 (used reg = )
mov	bx,#.12C
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1307             if (e.description != 0)
! Debug: ne unsigned long = const 0 to unsigned long e = [S+$3C-$A] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
xor	bx,bx
push	bx
push	ax
mov	ax,-8[bp]
mov	bx,-6[bp]
lea	di,-2+..FFFF[bp]
call	lcmpul
lea	sp,2+..FFFF[bp]
je  	.12D
.12E:
! 1308             {
! 1309               memcpyb(ss, &description, (Bit16u)(e.description >> 16), (Bit16u)(e.description & 0xffff), 32);
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$3E-$A] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FFFF
xor	bx,bx
lea	di,-8[bp]
call	landul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: sr int = const $10 to unsigned long e = [S+$40-$A] (used reg = )
mov	ax,-8[bp]
mov	bx,-6[bp]
xchg	bx,ax
xor	bx,bx
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list * [$21] char description = S+$42-$35 (used reg = )
lea	bx,-$33[bp]
push	bx
! Debug: list unsigned short ss = [S+$44-$3A] (used reg = )
push	-$38[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1310               description[32] = 0;
! Debug: eq int = const 0 to char description = [S+$3C-$15] (used reg = )
xor	al,al
mov	-$13[bp],al
!BCC_EOS
! 1311               bios_printf(2, " [%S]", ss, description);
! Debug: list * char description = S+$3C-$35 (used reg = )
lea	bx,-$33[bp]
push	bx
! Debug: list unsigned short ss = [S+$3E-$3A] (used reg = )
push	-$38[bp]
! Debug: list * char = .12F+0 (used reg = )
mov	bx,#.12F
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1312            }
! 1313            bios_printf(2, "\n");
.12D:
! Debug: list * char = .130+0 (used reg = )
mov	bx,#.130
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1314            break;
jmp .124
!BCC_EOS
! 1315         }
! 1316       }
jmp .124
.126:
sub	ax,*1
beq 	.127
sub	ax,*1
beq 	.128
sub	ax,*1
beq 	.129
sub	ax,*$7D
beq 	.12B
.124:
..FFFF	=	-$3C
! 1317       count++;
.120:
! Debug: postinc unsigned char i = [S+$3C-$37] (used reg = )
mov	al,-$35[bp]
inc	ax
mov	-$35[bp],al
.121:
! Debug: lt unsigned short count = [S+$3C-$14] to unsigned char i = [S+$3C-$37] (used reg = )
mov	al,-$35[bp]
xor	ah,ah
cmp	ax,-$12[bp]
blo 	.122
.131:
.11F:
! Debug: postinc unsigned short count = [S+$3C-$14] (used reg = )
mov	ax,-$12[bp]
inc	ax
mov	-$12[bp],ax
!BCC_EOS
! 1318       while (!valid_choice) {
jmp .133
.134:
! 1319         scan_code = get_keystroke();
! Debug: func () unsigned char = get_keystroke+0 (used reg = )
call	_get_keystroke
! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3C-$36] (used reg = )
mov	-$34[bp],al
!BCC_EOS
! 1320         if (scan_code == 0x01 || scan_code == 0x58)
! Debug: logeq int = const 1 to unsigned char scan_code = [S+$3C-$36] (used reg = )
mov	al,-$34[bp]
cmp	al,*1
je  	.136
.137:
! Debug: logeq int = const $58 to unsigned char scan_code = [S+$3C-$36] (used reg = )
mov	al,-$34[bp]
cmp	al,*$58
jne 	.135
.136:
! 1321         {
! 1322           valid_choice = 1;
! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
mov	ax,*1
mov	-$3A[bp],ax
!BCC_EOS
! 1323         }
! 1324         else if (scan_code <= count)
jmp .138
.135:
! Debug: le unsigned short count = [S+$3C-$14] to unsigned char scan_code = [S+$3C-$36] (used reg = )
mov	al,-$34[bp]
xor	ah,ah
cmp	ax,-$12[bp]
ja  	.139
.13A:
! 1325         {
! 1326           valid_choice = 1;
! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
mov	ax,*1
mov	-$3A[bp],ax
!BCC_EOS
! 1327           scan_code -= 1;
! Debug: subab int = const 1 to unsigned char scan_code = [S+$3C-$36] (used reg = )
mov	al,-$34[bp]
xor	ah,ah
dec	ax
mov	-$34[bp],al
!BCC_EOS
! 1328           write_word(0x9ff0, 0x0084, scan_code);
! Debug: list unsigned char scan_code = [S+$3C-$36] (used reg = )
mov	al,-$34[bp]
xor	ah,ah
push	ax
! Debug: list int = const $84 (used reg = )
mov	ax,#$84
push	ax
! Debug: list unsigned int = const $9FF0 (used reg = )
mov	ax,#$9FF0
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1329         }
! 1330       }
.139:
.138:
! 1331       bios_printf(2, "\n");
.133:
mov	ax,-$3A[bp]
test	ax,ax
je 	.134
.13B:
.132:
! Debug: list * char = .13C+0 (used reg = )
mov	bx,#.13C
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1332     }
! 1333   }
.118:
! 1334 }
.116:
mov	sp,bp
pop	bp
ret
! 1335 void
! Register BX used in function interactive_bootkey
! 1336 print_boot_device(e)
! 1337   ipl_entry_t *e;
export	_print_boot_device
_print_boot_device:
!BCC_EOS
! 1338 {
! 1339   Bit16u type;
!BCC_EOS
! 1340   char description[33];
!BCC_EOS
! 1341   Bit16u ss = get_SS();
push	bp
mov	bp,sp
add	sp,*-$26
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$28-$28] (used reg = )
mov	-$26[bp],ax
!BCC_EOS
! 1342   type = e->type;
mov	bx,4[bp]
! Debug: eq unsigned short = [bx+0] to unsigned short type = [S+$28-4] (used reg = )
mov	bx,[bx]
mov	-2[bp],bx
!BCC_EOS
! 1343   if (type == 0x80) type = 0x4;
! Debug: logeq int = const $80 to unsigned short type = [S+$28-4] (used reg = )
mov	ax,-2[bp]
cmp	ax,#$80
jne 	.13D
.13E:
! Debug: eq int = const 4 to unsigned short type = [S+$28-4] (used reg = )
mov	ax,*4
mov	-2[bp],ax
!BCC_EOS
! 1344   if (type == 0 || type > 0x4) bios_printf((2 | 4 | 1), "Bad drive type\n");
.13D:
! Debug: logeq int = const 0 to unsigned short type = [S+$28-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
je  	.140
.141:
! Debug: gt int = const 4 to unsigned short type = [S+$28-4] (used reg = )
mov	ax,-2[bp]
cmp	ax,*4
jbe 	.13F
.140:
! Debug: list * char = .142+0 (used reg = )
mov	bx,#.142
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1345   bios_printf(2, "Booting from %s", drivetypes[type]);
.13F:
! Debug: ptradd unsigned short type = [S+$28-4] to [5] [$A] char = drivetypes+0 (used reg = )
mov	bx,-2[bp]
mov	dx,bx
shl	bx,*1
shl	bx,*1
add	bx,dx
shl	bx,*1
! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
! Debug: list * char = bx+_drivetypes+0 (used reg = )
add	bx,#_drivetypes
push	bx
! Debug: list * char = .143+0 (used reg = )
mov	bx,#.143
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1346   if (type == 4 && e->description != 0) {
! Debug: logeq int = const 4 to unsigned short type = [S+$28-4] (used reg = )
mov	ax,-2[bp]
cmp	ax,*4
jne 	.144
.146:
mov	bx,4[bp]
! Debug: ne unsigned long = const 0 to unsigned long = [bx+8] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
xor	si,si
push	si
push	ax
mov	ax,8[bx]
mov	bx,$A[bx]
lea	di,-$2A[bp]
call	lcmpul
lea	sp,-$26[bp]
je  	.144
.145:
! 1347     memcpyb(ss, &descrip
! 1347 tion, (Bit16u)(e->description >> 16), (Bit16u)(e->description & 0xffff), 32);
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
mov	bx,4[bp]
! Debug: and unsigned long = const $FFFF to unsigned long = [bx+8] (used reg = )
! Debug: expression subtree swapping
push	$A[bx]
push	8[bx]
mov	ax,#$FFFF
xor	bx,bx
lea	di,-$2C[bp]
call	landul
add	sp,*4
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
mov	bx,4[bp]
! Debug: sr int = const $10 to unsigned long = [bx+8] (used reg = )
mov	ax,8[bx]
mov	bx,$A[bx]
xchg	bx,ax
xor	bx,bx
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list * [$21] char description = S+$2E-$25 (used reg = )
lea	bx,-$23[bp]
push	bx
! Debug: list unsigned short ss = [S+$30-$28] (used reg = )
push	-$26[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1348     description[32] = 0;
! Debug: eq int = const 0 to char description = [S+$28-5] (used reg = )
xor	al,al
mov	-3[bp],al
!BCC_EOS
! 1349     bios_printf(2, " [%S]", ss, description);
! Debug: list * char description = S+$28-$25 (used reg = )
lea	bx,-$23[bp]
push	bx
! Debug: list unsigned short ss = [S+$2A-$28] (used reg = )
push	-$26[bp]
! Debug: list * char = .147+0 (used reg = )
mov	bx,#.147
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1350   }
! 1351   bios_printf(2, "...\n");
.144:
! Debug: list * char = .148+0 (used reg = )
mov	bx,#.148
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1352 }
mov	sp,bp
pop	bp
ret
! 1353   void
! Register BX used in function print_boot_device
! 1354 print_boot_failure(type, reason)
! 1355   Bit16u type; Bit8u reason;
export	_print_boot_failure
_print_boot_failure:
!BCC_EOS
!BCC_EOS
! 1356 {
! 1357   if (type == 0 || type > 0x3) bios_printf((2 | 4 | 1), "Bad drive type\n");
push	bp
mov	bp,sp
! Debug: logeq int = const 0 to unsigned short type = [S+2+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
je  	.14A
.14B:
! Debug: gt int = const 3 to unsigned short type = [S+2+2] (used reg = )
mov	ax,4[bp]
cmp	ax,*3
jbe 	.149
.14A:
! Debug: list * char = .14C+0 (used reg = )
mov	bx,#.14C
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1358   bios_printf(2, "Boot failed");
.149:
! Debug: list * char = .14D+0 (used reg = )
mov	bx,#.14D
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1359   if (type < 4) {
! Debug: lt int = const 4 to unsigned short type = [S+2+2] (used reg = )
mov	ax,4[bp]
cmp	ax,*4
jae 	.14E
.14F:
! 1360     if (reason==0)
! Debug: logeq int = const 0 to unsigned char reason = [S+2+4] (used reg = )
mov	al,6[bp]
test	al,al
jne 	.150
.151:
! 1361       bios_printf(2, ": not a bootable disk");
! Debug: list * char = .152+0 (used reg = )
mov	bx,#.152
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1362     else
! 1363       bios_printf(2, ": could not read the boot disk");
jmp .153
.150:
! Debug: list * char = .154+0 (used reg = )
mov	bx,#.154
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1364   }
.153:
! 1365   bios_printf(2, "\n\n");
.14E:
! Debug: list * char = .155+0 (used reg = )
mov	bx,#.155
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1366 }
pop	bp
ret
! 1367   void
! Register BX used in function print_boot_failure
! 1368 print_cdromboot_failure( code )
! 1369   Bit16u code;
export	_print_cdromboot_failure
_print_cdromboot_failure:
!BCC_EOS
! 1370 {
! 1371   bios_printf(2 | 4, "CDROM boot failure code : %04x\n",code);
push	bp
mov	bp,sp
! Debug: list unsigned short code = [S+2+2] (used reg = )
push	4[bp]
! Debug: list * char = .156+0 (used reg = )
mov	bx,#.156
push	bx
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1372   return;
pop	bp
ret
!BCC_EOS
! 1373 }
! 1374 void
! Register BX used in function print_cdromboot_failure
! 1375 nmi_handler_msg()
! 1376 {
export	_nmi_handler_msg
_nmi_handler_msg:
! 1377   bios_printf((2 | 4 | 1), "NMI Handler called\n");
push	bp
mov	bp,sp
! Debug: list * char = .157+0 (used reg = )
mov	bx,#.157
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1378 }
pop	bp
ret
! 1379 void
! Register BX used in function nmi_handler_msg
! 1380 int18_panic_msg()
! 1381 {
export	_int18_panic_msg
_int18_panic_msg:
! 1382   bios_printf((2 | 4 | 1), "INT18: BOOT FAILURE\n");
push	bp
mov	bp,sp
! Debug: list * char = .158+0 (used reg = )
mov	bx,#.158
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1383 }
pop	bp
ret
! 1384 void
! Register BX used in function int18_panic_msg
! 1385 log_bios_start()
! 1386 {
export	_log_bios_start
_log_bios_start:
! 1387   bios_printf(4, "%s\n", bios_cvs_version_string);
push	bp
mov	bp,sp
! Debug: list * char = bios_cvs_version_string+0 (used reg = )
mov	bx,#_bios_cvs_version_string
push	bx
! Debug: list * char = .159+0 (used reg = )
mov	bx,#.159
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1388 }
pop	bp
ret
! 1389   bx_bool
! Register BX used in function log_bios_start
! 1390 set_enable_a20(val)
! 1391   bx_bool val;
export	_set_enable_a20
_set_enable_a20:
!BCC_EOS
! 1392 {
! 1393   Bit8u oldval;
!BCC_EOS
! 1394   oldval = inb(0x92);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $92 (used reg = )
mov	ax,#$92
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char oldval = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 1395   if (val)
mov	ax,4[bp]
test	ax,ax
je  	.15A
.15B:
! 1396     outb(0x92, oldval | 0x02);
! Debug: or int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
mov	al,-1[bp]
or	al,*2
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $92 (used reg = )
mov	ax,#$92
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1397   else
! 1398     outb(0x92, oldval & 0xfd);
jmp .15C
.15A:
! Debug: and int = const $FD to unsigned char oldval = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$FD
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $92 (used reg = )
mov	ax,#$92
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1399   return((oldval & 0x02) != 0);
.15C:
! Debug: and int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*2
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je 	.15D
mov	al,*1
jmp	.15E
.15D:
xor	al,al
.15E:
! Debug: cast unsigned short = const 0 to char = al+0 (used reg = )
xor	ah,ah
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1400 }
! 1401   void
! 1402 debugger_on()
! 1403 {
export	_debugger_on
_debugger_on:
! 1404   outb(0xfedc, 0x01);
push	bp
mov	bp,sp
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list unsigned int = const $FEDC (used reg = )
mov	ax,#$FEDC
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1405 }
pop	bp
ret
! 1406   void
! 1407 debugger_off()
! 1408 {
export	_debugger_off
_debugger_off:
! 1409   outb(0xfedc, 0x00);
push	bp
mov	bp,sp
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned int = const $FEDC (used reg = )
mov	ax,#$FEDC
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1410 }
pop	bp
ret
! 1411 int
! 1412 s3_resume()
! 1413 {
export	_s3_resume
_s3_resume:
! 1414     Bit32u s3_wakeup_vector;
!BCC_EOS
! 1415     Bit8u s3_resume_flag;
!BCC_EOS
! 1416     s3_resume_flag = read_byte(0x40, 0xb0);
push	bp
mov	bp,sp
add	sp,*-6
! Debug: list int = const $B0 (used reg = )
mov	ax,#$B0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char s3_resume_flag = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 1417     s3_wakeup_vector = read_dword(0x40, 0xb2);
! Debug: list int = const $B2 (used reg = )
mov	ax,#$B2
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1418     bios_printf(4, "S3 resume called %x 0x%lx\n", s3_resume_flag, s3_wakeup_vector);
! Debug: list unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list unsigned char s3_resume_flag = [S+$C-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list * char = .15F+0 (used reg = )
mov	bx,#.15F
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*$A
!BCC_EOS
! 1419     if (s3_resume_flag != 0xFE || !s3_wakeup_vector)
! Debug: ne int = const $FE to unsigned char s3_resume_flag = [S+8-7] (used reg = )
mov	al,-5[bp]
cmp	al,#$FE
jne 	.161
.162:
mov	ax,-4[bp]
mov	bx,-2[bp]
call	ltstl
jne 	.160
.161:
! 1420      return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1421     write_byte(0x40, 0xb0, 0);
.160:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $B0 (used reg = )
mov	ax,#$B0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1422     write_word(0x40, 0xb6, (s3_wakeup_vector & 0xF));
! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
! Debug: expression subtree swapping
mov	ax,*$F
xor	bx,bx
lea	di,-4[bp]
call	landul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const $B6 (used reg = )
mov	ax,#$B6
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*8
!BCC_EOS
! 1423     write_word(0x40, 0xb8, (s3_wakeup_vector >> 4));
! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
mov	di,*4
call	lsrul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const $B8 (used reg = )
mov	ax,#$B8
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*8
!BCC_EOS
! 1424     bios_printf(4, "S3 resume jump to %x:%x\n", (s3_wakeup_vector >> 4), (s3_wakeup_vector & 0xF));
! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
! Debug: expression subtree swapping
mov	ax,*$F
xor	bx,bx
lea	di,-4[bp]
call	landul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+$C-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
mov	di,*4
call	lsrul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list * char = .163+0 (used reg = )
mov	bx,#.163
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*$C
!BCC_EOS
! 1425 #asm
!BCC_EOS
!BCC_ASM
_s3_resume.s3_resume_flag	set	1
.s3_resume.s3_resume_flag	set	-5
_s3_resume.s3_wakeup_vector	set	2
.s3_resume.s3_wakeup_vector	set	-4
    jmpf [0x04b6]
! 1427 endasm
!BCC_ENDASM
!BCC_EOS
! 1428     return 1;
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1429 }
! 1430 void ata_init( )
! Register BX used in function s3_resume
! 1431 {
export	_ata_init
_ata_init:
! 1432   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1433   Bit8u channel, device;
!BCC_EOS
! 1434   for (channel=0; channel<4; channel++) {
dec	sp
dec	sp
! Debug: eq int = const 0 to unsigned char channel = [S+6-5] (used reg = )
xor	al,al
mov	-3[bp],al
!BCC_EOS
!BCC_EOS
br 	.166
.167:
! 1435     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iface,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$122] (used reg = )
! Debug: list * unsigned char = bx+$122 (used reg = )
add	bx,#$122
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1436     write_word(ebda_seg,&((ebd
! 1436 a_data_t *) 0)->ata.channels[channel].iobase1,0x0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1437     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2,0x0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1438     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].irq,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$128] (used reg = )
! Debug: list * unsigned char = bx+$128 (used reg = )
add	bx,#$128
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1439   }
! 1440   for (device=0; device<(4*2); device++) {
.165:
! Debug: postinc unsigned char channel = [S+6-5] (used reg = )
mov	al,-3[bp]
inc	ax
mov	-3[bp],al
.166:
! Debug: lt int = const 4 to unsigned char channel = [S+6-5] (used reg = )
mov	al,-3[bp]
cmp	al,*4
jb 	.167
.168:
.164:
! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
xor	al,al
mov	-4[bp],al
!BCC_EOS
!BCC_EOS
br 	.16B
.16C:
! 1441     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1442     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1443     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$144] (used reg = )
! Debug: list * unsigned char = bx+$144 (used reg = )
add	bx,#$144
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1444     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lock,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1445     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1446     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1447     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$14A] (used reg = )
! Debug: list * unsigned char = bx+$14A (used reg = )
add	bx,#$14A
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1448     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1449     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1450     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1451     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$152] (used reg = )
! Debug: list * unsigned short = bx+$152 (used reg = )
add	bx,#$152
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1452     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$154] (used reg = )
! Debug: list * unsigned short = bx+$154 (used reg = )
add	bx,#$154
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1453     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$156] (used reg = )
! Debug: list * unsigned short = bx+$156 (used reg = )
add	bx,#$156
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1454     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1455     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1456   }
! 1457   for (device=0; device<(4*2); device++) {
.16A:
! Debug: postinc unsigned char device = [S+6-6] (used reg = )
mov	al,-4[bp]
inc	ax
mov	-4[bp],al
.16B:
! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
mov	al,-4[bp]
cmp	al,*8
blo 	.16C
.16D:
.169:
! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
xor	al,al
mov	-4[bp],al
!BCC_EOS
!BCC_EOS
jmp .170
.171:
! 1458     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[device],(4*2));
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $233 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	bx,ax
! Debug: address unsigned char = [bx+$233] (used reg = )
! Debug: list * unsigned char = bx+$233 (used reg = )
add	bx,#$233
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1459     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[device],(4*2));
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $23C (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	bx,ax
! Debug: address unsigned char = [bx+$23C] (used reg = )
! Debug: list * unsigned char = bx+$23C (used reg = )
add	bx,#$23C
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1460   }
! 1461   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount,0);
.16F:
! Debug: postinc unsigned char device = [S+6-6] (used reg = )
mov	al,-4[bp]
inc	ax
mov	-4[bp],al
.170:
! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
mov	al,-4[bp]
cmp	al,*8
jb 	.171
.172:
.16E:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1462   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $23B (used reg = )
mov	ax,#$23B
push	ax
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1463 }
mov	sp,bp
pop	bp
ret
! 1464 int await_ide();
! Register BX used in function ata_init
!BCC_EOS
! 1465 static int await_ide(when_done,base,timeout)
! 1466   Bit8u when_done;
_await_ide:
!BCC_EOS
! 1467   Bit16u base;
!BCC_EOS
! 1468   Bit16u timeout;
!BCC_EOS
! 1469 {
! 1470   Bit32u time=0,last=0;
push	bp
mov	bp,sp
add	sp,*-4
! Debug: eq int = const 0 to unsigned long time = [S+6-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
add	sp,*-4
! Debug: eq int = const 0 to unsigned long last = [S+$A-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 1471   Bit16u status;
!BCC_EOS
! 1472   Bit8u result;
!BCC_EOS
! 1473   status = inb(base + 7);
add	sp,*-4
! Debug: add int = const 7 to unsigned short base = [S+$E+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned short status = [S+$E-$C] (used reg = )
xor	ah,ah
mov	-$A[bp],ax
!BCC_EOS
! 1474   for(;;) {
!BCC_EOS
!BCC_EOS
.175:
! 1475     status = inb(base+7);
! Debug: add int = const 7 to unsigned short base = [S+$E+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned short status = [S+$E-$C] (used reg = )
xor	ah,ah
mov	-$A[bp],ax
!BCC_EOS
! 1476     time++;
! Debug: postinc unsigned long time = [S+$E-6] (used reg = )
mov	ax,-4[bp]
mov	si,-2[bp]
lea	bx,-4[bp]
call	lincl
!BCC_EOS
! 1477     if (whe
! 1477 n_done == 1)
! Debug: logeq int = const 1 to unsigned char when_done = [S+$E+2] (used reg = )
mov	al,4[bp]
cmp	al,*1
jne 	.176
.177:
! 1478       result = status & 0x80;
! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1479     else if (when_done == 2)
br 	.178
.176:
! Debug: logeq int = const 2 to unsigned char when_done = [S+$E+2] (used reg = )
mov	al,4[bp]
cmp	al,*2
jne 	.179
.17A:
! 1480       result = !(status & 0x80);
! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,#$80
test	al,al
jne 	.17B
.17C:
mov	al,*1
jmp	.17D
.17B:
xor	al,al
.17D:
! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1481     else if (when_done == 3)
br 	.17E
.179:
! Debug: logeq int = const 3 to unsigned char when_done = [S+$E+2] (used reg = )
mov	al,4[bp]
cmp	al,*3
jne 	.17F
.180:
! 1482       result = !(status & 0x80) && (status & 0x08);
! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,#$80
test	al,al
jne 	.181
.183:
! Debug: and int = const 8 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,*8
test	al,al
je  	.181
.182:
mov	al,*1
jmp	.184
.181:
xor	al,al
.184:
! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1483     else if (when_done == 4)
jmp .185
.17F:
! Debug: logeq int = const 4 to unsigned char when_done = [S+$E+2] (used reg = )
mov	al,4[bp]
cmp	al,*4
jne 	.186
.187:
! 1484       result = !(status & 0x80) && !(status & 0x08);
! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,#$80
test	al,al
jne 	.188
.18A:
! Debug: and int = const 8 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,*8
test	al,al
jne 	.188
.189:
mov	al,*1
jmp	.18B
.188:
xor	al,al
.18B:
! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1485     else if (when_done == 5)
jmp .18C
.186:
! Debug: logeq int = const 5 to unsigned char when_done = [S+$E+2] (used reg = )
mov	al,4[bp]
cmp	al,*5
jne 	.18D
.18E:
! 1486       result = !(status & 0x80) && (status & 0x40);
! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,#$80
test	al,al
jne 	.18F
.191:
! Debug: and int = const $40 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,*$40
test	al,al
je  	.18F
.190:
mov	al,*1
jmp	.192
.18F:
xor	al,al
.192:
! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1487     else if (when_done == 0)
jmp .193
.18D:
! Debug: logeq int = const 0 to unsigned char when_done = [S+$E+2] (used reg = )
mov	al,4[bp]
test	al,al
jne 	.194
.195:
! 1488       result = 0;
! Debug: eq int = const 0 to unsigned char result = [S+$E-$D] (used reg = )
xor	al,al
mov	-$B[bp],al
!BCC_EOS
! 1489     if (result) return 0;
.194:
.193:
.18C:
.185:
.17E:
.178:
mov	al,-$B[bp]
test	al,al
je  	.196
.197:
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1490     if (time>>16 != last)
.196:
! Debug: sr int = const $10 to unsigned long time = [S+$E-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
xchg	bx,ax
xor	bx,bx
! Debug: ne unsigned long last = [S+$E-$A] to unsigned long = bx+0 (used reg = )
lea	di,-8[bp]
call	lcmpul
je  	.198
.199:
! 1491     {
! 1492       last = time >>16;
! Debug: sr int = const $10 to unsigned long time = [S+$E-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned long last = [S+$E-$A] (used reg = )
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 1493       ;
!BCC_EOS
! 1494     }
! 1495     if (status & 0x01)
.198:
! Debug: and int = const 1 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,*1
test	al,al
je  	.19A
.19B:
! 1496     {
! 1497       ;
!BCC_EOS
! 1498       return -1;
mov	ax,*-1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1499     }
! 1500     if ((timeout == 0) || ((time>>11) > timeout)) break;
.19A:
! Debug: logeq int = const 0 to unsigned short timeout = [S+$E+6] (used reg = )
mov	ax,8[bp]
test	ax,ax
je  	.19D
.19E:
! Debug: cast unsigned long = const 0 to unsigned short timeout = [S+$E+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
push	bx
push	ax
! Debug: sr int = const $B to unsigned long time = [S+$12-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*3
call	lsrul
! Debug: gt unsigned long (temp) = [S+$12-$12] to unsigned long = bx+0 (used reg = )
lea	di,-$10[bp]
call	lcmpul
lea	sp,-$C[bp]
jbe 	.19C
.19D:
jmp .173
!BCC_EOS
! 1501   }
.19C:
! 1502   bios_printf(4, "IDE time out\n");
.174:
br 	.175
.173:
! Debug: list * char = .19F+0 (used reg = )
mov	bx,#.19F
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1503   return -1;
mov	ax,*-1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1504 }
! 1505 void ata_detect( )
! Register BX used in function await_ide
! 1506 {
export	_ata_detect
_ata_detect:
! 1507   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1508   Bit8u hdcount, cdcount, device, type;
!BCC_EOS
! 1509   Bit8u buffer[0x0200];
!BCC_EOS
! 1510   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iface,0x00);
add	sp,#-$204
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $122 (used reg = )
mov	ax,#$122
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1511   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase1,0x1f0);
! Debug: list int = const $1F0 (used reg = )
mov	ax,#$1F0
push	ax
! Debug: list * unsigned short = const $124 (used reg = )
mov	ax,#$124
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1512   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase2,0x3f0);
! Debug: list int = const $3F0 (used reg = )
mov	ax,#$3F0
push	ax
! Debug: list * unsigned short = const $126 (used reg = )
mov	ax,#$126
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1513   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].irq,14);
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list * unsigned char = const $128 (used reg = )
mov	ax,#$128
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1514   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iface,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $12A (used reg = )
mov	ax,#$12A
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1515   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase1,0x170);
! Debug: list int = const $170 (used reg = )
mov	ax,#$170
push	ax
! Debug: list * unsigned short = const $12C (used reg = )
mov	ax,#$12C
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1516   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase2,0x370);
! Debug: list int = const $370 (used reg = )
mov	ax,#$370
push	ax
! Debug: list * unsigned short = const $12E (used reg = )
mov	ax,#$12E
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1517   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].irq,15);
! Debug: list int = const $F (used reg = )
mov	ax,*$F
push	ax
! Debug: list * unsigned char = const $130 (used reg = )
mov	ax,#$130
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1518   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iface,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $132 (used reg = )
mov	ax,#$132
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1519   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase1,0x1e8);
! Debug: list int = const $1E8 (used reg = )
mov	ax,#$1E8
push	ax
! Debug: list * unsigned short = const $134 (used reg = )
mov	ax,#$134
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1520   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase2,0x3e0);
! Debug: list int = const $3E0 (used reg = )
mov	ax,#$3E0
push	ax
! Debug: list * unsigned short = const $136 (used reg = )
mov	ax,#$136
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1521   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].irq,12);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list * unsigned char = const $138 (used reg = )
mov	ax,#$138
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1522   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iface,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $13A (used reg = )
mov	ax,#$13A
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1523   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase1,0x168);
! Debug: list int = const $168 (used reg = )
mov	ax,#$168
push	ax
! Debug: list * unsigned short = const $13C (used reg = )
mov	ax,#$13C
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1524   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase2,0x360);
! Debug: list int = const $360 (used reg = )
mov	ax,#$360
push	ax
! Debug: list * unsigned short = const $13E (used reg = )
mov	ax,#$13E
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1525   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].irq,11);
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: list * unsigned char = const $140 (used reg = )
mov	ax,#$140
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1526   hdcount=cdcount=0;
! Debug: eq int = const 0 to unsigned char cdcount = [S+$208-6] (used reg = )
xor	al,al
mov	-4[bp],al
! Debug: eq unsigned char = al+0 to unsigned char hdcount = [S+$208-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 1527   for(device=0; device<(4*2); device++) {
! Debug: eq int = const 0 to unsigned char device = [S+$208-7] (used reg = )
xor	al,al
mov	-5[bp],al
!BCC_EOS
!BCC_EOS
br 	.1A2
.1A3:
! 1528     Bit16u iobas
! 1528 e1, iobase2;
!BCC_EOS
! 1529     Bit8u channel, slave, shift;
!BCC_EOS
! 1530     Bit8u sc, sn, cl, ch, st;
!BCC_EOS
! 1531     channel = device / 2;
add	sp,*-$C
! Debug: div int = const 2 to unsigned char device = [S+$214-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$214-$20D] (used reg = )
mov	-$20B[bp],al
!BCC_EOS
! 1532     slave = device % 2;
! Debug: mod int = const 2 to unsigned char device = [S+$214-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$214-$20E] (used reg = )
mov	-$20C[bp],al
!BCC_EOS
! 1533     iobase1 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	-$208[bp],ax
!BCC_EOS
! 1534     iobase2 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$214-$20C] (used reg = )
mov	-$20A[bp],ax
!BCC_EOS
! 1535     outb(iobase2+6, 0x08 | 0x02);
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$216-$20C] (used reg = )
mov	ax,-$20A[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1536     outb(iobase1+6, slave ? 0xb0 : 0xa0);
mov	al,-$20C[bp]
test	al,al
je  	.1A4
.1A5:
mov	al,#$B0
jmp .1A6
.1A4:
mov	al,#$A0
.1A6:
! Debug: list char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1537     outb(iobase1+2, 0x55);
! Debug: list int = const $55 (used reg = )
mov	ax,*$55
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1538     outb(iobase1+3, 0xaa);
! Debug: list int = const $AA (used reg = )
mov	ax,#$AA
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1539     outb(iobase1+2, 0xaa);
! Debug: list int = const $AA (used reg = )
mov	ax,#$AA
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1540     outb(iobase1+3, 0x55);
! Debug: list int = const $55 (used reg = )
mov	ax,*$55
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1541     outb(iobase1+2, 0x55);
! Debug: list int = const $55 (used reg = )
mov	ax,*$55
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1542     outb(iobase1+3, 0xaa);
! Debug: list int = const $AA (used reg = )
mov	ax,#$AA
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1543     sc = inb(iobase1+2);
! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
mov	-$20E[bp],al
!BCC_EOS
! 1544     sn = inb(iobase1+3);
! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
mov	-$20F[bp],al
!BCC_EOS
! 1545     if ( (sc == 0x55) && (sn == 0xaa) ) {
! Debug: logeq int = const $55 to unsigned char sc = [S+$214-$210] (used reg = )
mov	al,-$20E[bp]
cmp	al,*$55
bne 	.1A7
.1A9:
! Debug: logeq int = const $AA to unsigned char sn = [S+$214-$211] (used reg = )
mov	al,-$20F[bp]
cmp	al,#$AA
bne 	.1A7
.1A8:
! 1546       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x01);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1547       ata_reset(device);
! Debug: list unsigned char device = [S+$214-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: func () void = ata_reset+0 (used reg = )
call	_ata_reset
inc	sp
inc	sp
!BCC_EOS
! 1548       outb(iobase1+6, slave ? 0xb0 : 0xa0);
mov	al,-$20C[bp]
test	al,al
je  	.1AA
.1AB:
mov	al,#$B0
jmp .1AC
.1AA:
mov	al,#$A0
.1AC:
! Debug: list char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1549       sc = inb(iobase1+2);
! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
mov	-$20E[bp],al
!BCC_EOS
! 1550       sn = inb(iobase1+3);
! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
mov	-$20F[bp],al
!BCC_EOS
! 1551       if ((sc==0x01) && (sn==0x01)) {
! Debug: logeq int = const 1 to unsigned char sc = [S+$214-$210] (used reg = )
mov	al,-$20E[bp]
cmp	al,*1
bne 	.1AD
.1AF:
! Debug: logeq int = const 1 to unsigned char sn = [S+$214-$211] (used reg = )
mov	al,-$20F[bp]
cmp	al,*1
bne 	.1AD
.1AE:
! 1552         cl = inb(iobase1+4);
! Debug: add int = const 4 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char cl = [S+$214-$212] (used reg = )
mov	-$210[bp],al
!BCC_EOS
! 1553         ch = inb(iobase1+5);
! Debug: add int = const 5 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ch = [S+$214-$213] (used reg = )
mov	-$211[bp],al
!BCC_EOS
! 1554         st = inb(iobase1+7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char st = [S+$214-$214] (used reg = )
mov	-$212[bp],al
!BCC_EOS
! 1555         if ((cl==0x14) && (ch==0xeb)) {
! Debug: logeq int = const $14 to unsigned char cl = [S+$214-$212] (used reg = )
mov	al,-$210[bp]
cmp	al,*$14
jne 	.1B0
.1B2:
! Debug: logeq int = const $EB to unsigned char ch = [S+$214-$213] (used reg = )
mov	al,-$211[bp]
cmp	al,#$EB
jne 	.1B0
.1B1:
! 1556           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x03);
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1557         } else if ((cl==0x00) && (ch==0x00) && (st!=0x00)) {
jmp .1B3
.1B0:
! Debug: logeq int = const 0 to unsigned char cl = [S+$214-$212] (used reg = )
mov	al,-$210[bp]
test	al,al
jne 	.1B4
.1B7:
! Debug: logeq int = const 0 to unsigned char ch = [S+$214-$213] (used reg = )
mov	al,-$211[bp]
test	al,al
jne 	.1B4
.1B6:
! Debug: ne int = const 0 to unsigned char st = [S+$214-$214] (used reg = )
mov	al,-$212[bp]
test	al,al
je  	.1B4
.1B5:
! 1558           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1559         } else if ((cl==0xff) && (ch==0xff)) {
jmp .1B8
.1B4:
! Debug: logeq int = const $FF to unsigned char cl = [S+$214-$212] (used reg = )
mov	al,-$210[bp]
cmp	al,#$FF
jne 	.1B9
.1BB:
! Debug: logeq int = const $FF to unsigned char ch = [S+$214-$213] (used reg = )
mov	al,-$211[bp]
cmp	al,#$FF
jne 	.1B9
.1BA:
! 1560           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1561         }
! 1562       }
.1B9:
.1B8:
.1B3:
! 1563     }
.1AD:
! 1564     type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
.1A7:
! Debug: ptradd unsigned char device = [S+$214-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char type = [S+$214-8] (used reg = )
mov	-6[bp],al
!BCC_EOS
! 1565     if(type == 0x02) {
! Debug: logeq int = const 2 to unsigned char type = [S+$214-8] (used reg = )
mov	al,-6[bp]
cmp	al,*2
bne 	.1BC
.1BD:
! 1566       Bit32u sectors_low, sectors_high;
!BCC_EOS
! 1567       Bit16u cylinders, heads, spt, blksize;
!BCC_EOS
! 1568       Bit8u translation, removable, mode;
!BCC_EOS
! 1569       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
add	sp,*-$14
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1570       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1571       if (ata_cmd_data_in(device,0xEC, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) !=0 )
! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
lea	bx,-$206[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $EC (used reg = )
mov	ax,#$EC
push	ax
! Debug: list unsigned char device = [S+$23E-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
call	_ata_cmd_data_in
add	sp,*$18
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.1BE
.1BF:
! 1572         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATA device\n");
! Debug: list * char = .1C0+0 (used reg = )
mov	bx,#.1C0
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1573       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
.1BE:
! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
lea	bx,-$206[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
test	al,al
je  	.1C1
.1C2:
mov	al,*1
jmp .1C3
.1C1:
xor	al,al
.1C3:
! Debug: eq char = al+0 to unsigned char removable = [S+$228-$226] (used reg = )
mov	-$224[bp],al
!BCC_EOS
! 1574       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 
! 1574 0x00;
! Debug: list * unsigned char buffer = S+$228-$1A8 (used reg = )
lea	bx,-$1A6[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
test	al,al
je  	.1C4
.1C5:
mov	al,*1
jmp .1C6
.1C4:
xor	al,al
.1C6:
! Debug: eq char = al+0 to unsigned char mode = [S+$228-$227] (used reg = )
mov	-$225[bp],al
!BCC_EOS
! 1575       blksize = read_word(get_SS(),buffer+10);
! Debug: list * unsigned char buffer = S+$228-$1FE (used reg = )
lea	bx,-$1FC[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$228-$224] (used reg = )
mov	-$222[bp],ax
!BCC_EOS
! 1576       cylinders = read_word(get_SS(),buffer+(1*2));
! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
lea	bx,-$204[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	-$21C[bp],ax
!BCC_EOS
! 1577       heads = read_word(get_SS(),buffer+(3*2));
! Debug: list * unsigned char buffer = S+$228-$202 (used reg = )
lea	bx,-$200[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short heads = [S+$228-$220] (used reg = )
mov	-$21E[bp],ax
!BCC_EOS
! 1578       spt = read_word(get_SS(),buffer+(6*2));
! Debug: list * unsigned char buffer = S+$228-$1FC (used reg = )
lea	bx,-$1FA[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short spt = [S+$228-$222] (used reg = )
mov	-$220[bp],ax
!BCC_EOS
! 1579       if (read_word(get_SS(),buffer+(83*2)) & (1 << 10)) {
! Debug: list * unsigned char buffer = S+$228-$162 (used reg = )
lea	bx,-$160[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: and int = const $400 to unsigned short = ax+0 (used reg = )
and	ax,#$400
test	ax,ax
je  	.1C7
.1C8:
! 1580         sectors_low = read_dword(get_SS(),buffer+(100*2));
! Debug: list * unsigned char buffer = S+$228-$140 (used reg = )
lea	bx,-$13E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
mov	-$216[bp],ax
mov	-$214[bp],bx
!BCC_EOS
! 1581         sectors_high = read_dword(get_SS(),buffer+(102*2));
! Debug: list * unsigned char buffer = S+$228-$13C (used reg = )
lea	bx,-$13A[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
mov	-$21A[bp],ax
mov	-$218[bp],bx
!BCC_EOS
! 1582       } else {
jmp .1C9
.1C7:
! 1583         sectors_low = read_dword(get_SS(),buffer+(60*2));
! Debug: list * unsigned char buffer = S+$228-$190 (used reg = )
lea	bx,-$18E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
mov	-$216[bp],ax
mov	-$214[bp],bx
!BCC_EOS
! 1584         sectors_high = 0;
! Debug: eq int = const 0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$21A[bp],ax
mov	-$218[bp],bx
!BCC_EOS
! 1585       }
! 1586       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
.1C9:
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1587       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
! Debug: list unsigned char removable = [S+$228-$226] (used reg = )
mov	al,-$224[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$144] (used reg = )
! Debug: list * unsigned char = bx+$144 (used reg = )
add	bx,#$144
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1588       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
! Debug: list unsigned char mode = [S+$228-$227] (used reg = )
mov	al,-$225[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1589       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
! Debug: list unsigned short blksize = [S+$228-$224] (used reg = )
push	-$222[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1590       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads, heads);
! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
push	-$21E[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$152] (used reg = )
! Debug: list * unsigned short = bx+$152 (used reg = )
add	bx,#$152
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1591       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders, cylinders);
! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
push	-$21C[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$154] (used reg = )
! Debug: list * unsigned short = bx+$154 (used reg = )
add	bx,#$154
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1592       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt, spt);
! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
push	-$220[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$156] (used reg = )
! Debug: list * unsigned short = bx+$156 (used reg = )
add	bx,#$156
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1593       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors_low);
! Debug: list unsigned long sectors_low = [S+$228-$218] (used reg = )
push	-$214[bp]
push	-$216[bp]
! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1594       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high, sectors_high);
! Debug: list unsigned long sectors_high = [S+$228-$21C] (used reg = )
push	-$218[bp]
push	-$21A[bp]
! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1595       bios_printf(4, "ata%d-%d: PCHS=%u/%d/%d translation=", channel, slave,cylinders, heads, spt);
! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
push	-$220[bp]
! Debug: list unsigned short heads = [S+$22A-$220] (used reg = )
push	-$21E[bp]
! Debug: list unsigned short cylinders = [S+$22C-$21E] (used reg = )
push	-$21C[bp]
! Debug: list unsigned char slave = [S+$22E-$20E] (used reg = )
mov	al,-$20C[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char channel = [S+$230-$20D] (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .1CA+0 (used reg = )
mov	bx,#.1CA
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*$E
!BCC_EOS
! 1596       translation = inb_cmos(0x39 + channel/2);
! Debug: div int = const 2 to unsigned char channel = [S+$228-$20D] (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
shr	ax,*1
! Debug: add unsigned int = ax+0 to int = const $39 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$39 (used reg = )
add	ax,*$39
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$228-$225] (used reg = )
mov	-$223[bp],al
!BCC_EOS
! 1597       for (shift=device%4; shift>0; shift--) translation >>= 2;
! Debug: mod int = const 4 to unsigned char device = [S+$228-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
and	al,*3
! Debug: eq unsigned char = al+0 to unsigned char shift = [S+$228-$20F] (used reg = )
mov	-$20D[bp],al
!BCC_EOS
!BCC_EOS
jmp .1CD
.1CE:
! Debug: srab int = const 2 to unsigned char translation = [S+$228-$225] (used reg = )
mov	al,-$223[bp]
xor	ah,ah
shr	ax,*1
shr	ax,*1
mov	-$223[bp],al
!BCC_EOS
! 1598       translation &= 0x03;
.1CC:
! Debug: postdec unsigned char shift = [S+$228-$20F] (used reg = )
mov	al,-$20D[bp]
dec	ax
mov	-$20D[bp],al
.1CD:
! Debug: gt int = const 0 to unsigned char shift = [S+$228-$20F] (used reg = )
mov	al,-$20D[bp]
test	al,al
jne	.1CE
.1CF:
.1CB:
! Debug: andab int = const 3 to unsigned char translation = [S+$228-$225] (used reg = )
mov	al,-$223[bp]
and	al,*3
mov	-$223[bp],al
!BCC_EOS
! 1599       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation, translation);
! Debug: list unsigned char translation = [S+$228-$225] (used reg = )
mov	al,-$223[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$14A] (used reg = )
! Debug: list * unsigned char = bx+$14A (used reg = )
add	bx,#$14A
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1600       switch (translation) {
mov	al,-$223[bp]
jmp .1D2
! 1601         case 0:
! 1602           bios_printf(4, "none");
.1D3:
! Debug: list * char = .1D4+0 (used reg = )
mov	bx,#.1D4
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1603           break;
jmp .1D0
!BCC_EOS
! 1604         case 1:
! 1605           bios_printf(4, "lba");
.1D5:
! Debug: list * char = .1D6+0 (used reg = )
mov	bx,#.1D6
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1606           break;
jmp .1D0
!BCC_EOS
! 1607         case 2:
! 1608           bios_printf(4, "large");
.1D7:
! Debug: list * char = .1D8+0 (used reg = )
mov	bx,#.1D8
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1609           break;
jmp .1D0
!BCC_EOS
! 1610         case 3:
! 1611           bios_printf(4, "r-echs");
.1D9:
! Debug: list * char = .1DA+0 (used reg = )
mov	bx,#.1DA
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1612           break;
jmp .1D0
!BCC_EOS
! 1613       }
! 1614       switch (translation) {
jmp .1D0
.1D2:
sub	al,*0
je 	.1D3
sub	al,*1
je 	.1D5
sub	al,*1
je 	.1D7
sub	al,*1
je 	.1D9
.1D0:
..FFFE	=	-$228
mov	al,-$223[bp]
br 	.1DD
! 1615         case 0:
! 1616           break;
.1DE:
br 	.1DB
!BCC_EOS
! 1617         case 1:
! 1618           spt = 63;
.1DF:
! Debug: eq int = const $3F to unsigned short spt = [S+$228-$222] (used reg = )
mov	ax,*$3F
mov	-$220[bp],ax
!BCC_EOS
! 1619           sectors_low 
! 1619 /= 63;
! Debug: divab unsigned long = const $3F to unsigned long sectors_low = [S+$228-$218] (used reg = )
mov	ax,*$3F
xor	bx,bx
push	bx
push	ax
mov	ax,-$216[bp]
mov	bx,-$214[bp]
lea	di,-2+..FFFD[bp]
call	ldivul
mov	-$216[bp],ax
mov	-$214[bp],bx
add	sp,*4
!BCC_EOS
! 1620           heads = sectors_low / 1024;
! Debug: div unsigned long = const $400 to unsigned long sectors_low = [S+$228-$218] (used reg = )
mov	ax,#$400
xor	bx,bx
push	bx
push	ax
mov	ax,-$216[bp]
mov	bx,-$214[bp]
lea	di,-2+..FFFD[bp]
call	ldivul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned short heads = [S+$228-$220] (used reg = )
mov	-$21E[bp],ax
!BCC_EOS
! 1621           if (heads>128) heads = 255;
! Debug: gt int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,#$80
jbe 	.1E0
.1E1:
! Debug: eq int = const $FF to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,#$FF
mov	-$21E[bp],ax
!BCC_EOS
! 1622           else if (heads>64) heads = 128;
jmp .1E2
.1E0:
! Debug: gt int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$40
jbe 	.1E3
.1E4:
! Debug: eq int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,#$80
mov	-$21E[bp],ax
!BCC_EOS
! 1623           else if (heads>32) heads = 64;
jmp .1E5
.1E3:
! Debug: gt int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$20
jbe 	.1E6
.1E7:
! Debug: eq int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,*$40
mov	-$21E[bp],ax
!BCC_EOS
! 1624           else if (heads>16) heads = 32;
jmp .1E8
.1E6:
! Debug: gt int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$10
jbe 	.1E9
.1EA:
! Debug: eq int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,*$20
mov	-$21E[bp],ax
!BCC_EOS
! 1625           else heads=16;
jmp .1EB
.1E9:
! Debug: eq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,*$10
mov	-$21E[bp],ax
!BCC_EOS
! 1626           cylinders = sectors_low / heads;
.1EB:
.1E8:
.1E5:
.1E2:
! Debug: cast unsigned long = const 0 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
xor	bx,bx
! Debug: div unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
push	bx
push	ax
mov	ax,-$216[bp]
mov	bx,-$214[bp]
lea	di,-2+..FFFD[bp]
call	ldivul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	-$21C[bp],ax
!BCC_EOS
! 1627           break;
br 	.1DB
!BCC_EOS
! 1628         case 3:
! 1629           if (heads==16) {
.1EC:
! Debug: logeq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$10
jne 	.1ED
.1EE:
! 1630             if(cylinders>61439) cylinders=61439;
! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
xor	bx,bx
! Debug: gt long = const $EFFF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$EFFF
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFFD[bp]
mov	bx,0+..FFFD[bp]
lea	di,-6+..FFFD[bp]
call	lcmpul
lea	sp,2+..FFFD[bp]
jbe 	.1EF
.1F0:
! Debug: eq long = const $EFFF to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,#$EFFF
mov	-$21C[bp],ax
!BCC_EOS
! 1631             heads=15;
.1EF:
! Debug: eq int = const $F to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,*$F
mov	-$21E[bp],ax
!BCC_EOS
! 1632             cylinders = (Bit16u)((Bit32u)(cylinders)*16/15);
! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
xor	bx,bx
! Debug: mul unsigned long = const $10 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$10
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFFD[bp]
mov	bx,0+..FFFD[bp]
lea	di,-6+..FFFD[bp]
call	lmulul
add	sp,*8
! Debug: div unsigned long = const $F to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$F
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFFD[bp]
mov	bx,0+..FFFD[bp]
lea	di,-6+..FFFD[bp]
call	ldivul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	-$21C[bp],ax
!BCC_EOS
! 1633           }
! 1634         case 2:
.1ED:
! 1635           while(cylinders > 1024) {
.1F1:
jmp .1F3
.1F4:
! 1636             cylinders >>= 1;
! Debug: srab int = const 1 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
shr	ax,*1
mov	-$21C[bp],ax
!BCC_EOS
! 1637             heads <<= 1;
! Debug: slab int = const 1 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
shl	ax,*1
mov	-$21E[bp],ax
!BCC_EOS
! 1638             if (heads > 127) break;
! Debug: gt int = const $7F to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$7F
jbe 	.1F5
.1F6:
jmp .1F2
!BCC_EOS
! 1639           }
.1F5:
! 1640           break;
.1F3:
! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
cmp	ax,#$400
ja 	.1F4
.1F7:
.1F2:
jmp .1DB
!BCC_EOS
! 1641       }
! 1642       if (cylinders > 1024) cylinders=1024;
jmp .1DB
.1DD:
sub	al,*0
beq 	.1DE
sub	al,*1
beq 	.1DF
sub	al,*1
je 	.1F1
sub	al,*1
beq 	.1EC
.1DB:
..FFFD	=	-$228
! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
cmp	ax,#$400
jbe 	.1F8
.1F9:
! Debug: eq int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,#$400
mov	-$21C[bp],ax
!BCC_EOS
! 1643       bios_printf(4, " LCHS=%d/%d/%d\n", cylinders, heads, spt);
.1F8:
! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
push	-$220[bp]
! Debug: list unsigned short heads = [S+$22A-$220] (used reg = )
push	-$21E[bp]
! Debug: list unsigned short cylinders = [S+$22C-$21E] (used reg = )
push	-$21C[bp]
! Debug: list * char = .1FA+0 (used reg = )
mov	bx,#.1FA
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*$A
!BCC_EOS
! 1644       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads, heads);
! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
push	-$21E[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1645       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders, cylinders);
! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
push	-$21C[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1646       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt, spt);
! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
push	-$220[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1647       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[hdcount], device);
! Debug: list unsigned char device = [S+$228-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char hdcount = [S+$22A-5] to [8] unsigned char = const $233 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	bx,ax
! Debug: address unsigned char = [bx+$233] (used reg = )
! Debug: list * unsigned char = bx+$233 (used reg = )
add	bx,#$233
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1648       hdcount++;
! Debug: postinc unsigned char hdcount = [S+$228-5] (used reg = )
mov	al,-3[bp]
inc	ax
mov	-3[bp],al
!BCC_EOS
! 1649     }
add	sp,*$14
! 1650     if(type == 0x03) {
.1BC:
! Debug: logeq int = const 3 to unsigned char type = [S+$214-8] (used reg = )
mov	al,-6[bp]
cmp	al,*3
bne 	.1FB
.1FC:
! 1651       Bit8u type, removable, mode;
!BCC_EOS
! 1652       Bit16u blksize;
!BCC_EOS
! 1653       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x05);
add	sp,*-6
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1654       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1655       if (ata_cmd_data_in(device,0xA1, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) != 0)
! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
lea	bx,-$206[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: list unsigned char device = [S+$230-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
call	_ata_cmd_data_in
add	sp,*$18
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.1FD
.1FE:
! 1656         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATAPI device\n");
! Debug: list * char = .1FF+0 (used reg = )
mov	bx,#.1FF
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1657       type = read_byte(get_SS(),buffer+1) & 0x1f;
.1FD:
! Debug: list * unsigned char buffer = S+$21A-$207 (used reg = )
lea	bx,-$205[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $1F to unsigned char = al+0 (used reg = )
and	al,*$1F
! Debug: eq unsigned char = al+0 to unsigned char type = [S+$21A-$215] (used reg = )
mov	-$213[bp],al
!BCC_EOS
! 1658       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
lea	bx,-$206[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
test	al,al
je  	.200
.201:
mov	al,*1
jmp .202
.200:
xor	al,al
.202:
! Debug: eq char = al+0 to unsigned char removable = [S+$21A-$216] (used reg = )
mov	-$214[bp],al
!BCC_EOS
! 1659       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
! Debug: list * unsigned char buffer = S+$21A-$1A8 (used reg = )
lea	bx,-$1A6[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
test	al,al
je  	.203
.204:
mov	al,*1
jmp .205
.203:
xor	al,al
.205:
! Debug: eq char = al+0 to unsigned char mode = [S+$21A-$217] (used reg = )
mov	-$215[bp],al
!BCC_EOS
! 1660       blksize = 2048;
! Debug: eq int = const $800 to unsigned short blksize = [S+$21A-$21A] (used reg = )
mov	ax,#$800
mov	-$218[bp],ax
!BCC_EOS
! 1661       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device, type);
! Debug: list unsigned char type = [S+$21A-$215] (used reg = )
mov	al,-$213[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1662       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
! Debug: list unsigned char removable = [S+$21A-$216] (used reg = )
mov	al,-$214[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$144] (used reg = )
! Debug: list * unsigned char = bx+$144 (used reg = )
add	bx,#$144
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1663       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
! Debug: list unsigned char mode = [S+$21A-$217] (used reg = )
mov	al,-$215[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1664       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.dev
! 1664 ices[device].blksize, blksize);
! Debug: list unsigned short blksize = [S+$21A-$21A] (used reg = )
push	-$218[bp]
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1665       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[cdcount], device);
! Debug: list unsigned char device = [S+$21A-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char cdcount = [S+$21C-6] to [8] unsigned char = const $23C (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	bx,ax
! Debug: address unsigned char = [bx+$23C] (used reg = )
! Debug: list * unsigned char = bx+$23C (used reg = )
add	bx,#$23C
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1666       cdcount++;
! Debug: postinc unsigned char cdcount = [S+$21A-6] (used reg = )
mov	al,-4[bp]
inc	ax
mov	-4[bp],al
!BCC_EOS
! 1667     }
add	sp,*6
! 1668     {
.1FB:
! 1669       Bit32u sizeinmb;
!BCC_EOS
! 1670       Bit16u ataversion;
!BCC_EOS
! 1671       Bit8u c, i, version, model[41];
!BCC_EOS
! 1672       switch (type) {
add	sp,*-$32
mov	al,-6[bp]
br 	.208
! 1673         case 0x02:
! 1674           sizeinmb = (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high) << 21)
.209:
! 1675             | (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low) >> 11);
! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*3
call	lsrul
push	bx
push	ax
! Debug: ptradd unsigned char device = [S+$24A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$24C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: sl int = const $15 to unsigned long = bx+0 (used reg = )
mov	cl,*5
shl	ax,cl
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$24A-$24A] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFFC[bp]
call	lorul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
mov	-$216[bp],ax
mov	-$214[bp],bx
!BCC_EOS
! 1676         case 0x03:
! 1677           ataversion=((Bit16u)(read_byte(get_SS(),buffer+161))<<8)|read_byte(get_SS(),buffer+160);
.20A:
! Debug: list * unsigned char buffer = S+$246-$168 (used reg = )
lea	bx,-$166[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: list * unsigned char buffer = S+$248-$167 (used reg = )
lea	bx,-$165[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
mov	ah,al
xor	al,al
! Debug: or unsigned char (temp) = [S+$248-$248] to unsigned int = ax+0 (used reg = )
or	al,0+..FFFC[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
mov	-$218[bp],ax
!BCC_EOS
! 1678           for(version=15;version>0;version--) {
! Debug: eq int = const $F to unsigned char version = [S+$246-$21D] (used reg = )
mov	al,*$F
mov	-$21B[bp],al
!BCC_EOS
!BCC_EOS
jmp .20D
.20E:
! 1679             if((ataversion&(1<<version))!=0)
! Debug: sl unsigned char version = [S+$246-$21D] to int = const 1 (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
mov	bx,ax
mov	ax,*1
mov	cx,bx
shl	ax,cl
! Debug: and int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
! Debug: expression subtree swapping
and	ax,-$218[bp]
! Debug: ne int = const 0 to unsigned int = ax+0 (used reg = )
test	ax,ax
je  	.20F
.210:
! 1680             break;
jmp .20B
!BCC_EOS
! 1681           }
.20F:
! 1682           for(i=0;i<20;i++) {
.20C:
! Debug: postdec unsigned char version = [S+$246-$21D] (used reg = )
mov	al,-$21B[bp]
dec	ax
mov	-$21B[bp],al
.20D:
! Debug: gt int = const 0 to unsigned char version = [S+$246-$21D] (used reg = )
mov	al,-$21B[bp]
test	al,al
jne	.20E
.211:
.20B:
! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
xor	al,al
mov	-$21A[bp],al
!BCC_EOS
!BCC_EOS
jmp .214
.215:
! 1683             write_byte(get_SS(),model+(i*2),read_byte(get_SS(),buffer+(i*2)+54+1));
! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
shl	ax,*1
! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
mov	bx,bp
add	bx,ax
! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
! Debug: ptradd int = const 1 to [$200] unsigned char = bx-$1D0 (used reg = )
! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CF (used reg = )
! Debug: list * unsigned char = bx-$1CF (used reg = )
add	bx,#-$1CF
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
shl	ax,*1
! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1684             write_byte(get_SS(),model+(i*2)+1,read_byte(get_SS(),buffer+(i*2)+54));
! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
shl	ax,*1
! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
mov	bx,bp
add	bx,ax
! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1D0 (used reg = )
! Debug: list * unsigned char = bx-$1D0 (used reg = )
add	bx,#-$1D0
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
shl	ax,*1
! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
mov	bx,bp
add	bx,ax
! Debug: ptradd int = const 1 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$243 (used reg = )
! Debug: list * unsigned char = bx-$243 (used reg = )
add	bx,#-$243
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1685           }
! 1686           write_byte(get_SS(),model+40,0x00);
.213:
! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
inc	ax
mov	-$21A[bp],al
.214:
! Debug: lt int = const $14 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
cmp	al,*$14
blo 	.215
.216:
.212:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char model = S+$248-$21E (used reg = )
lea	bx,-$21C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1687           for(i=39;i>0;i--){
! Debug: eq int = const $27 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,*$27
mov	-$21A[bp],al
!BCC_EOS
!BCC_EOS
jmp .219
.21A:
! 1688             if(read_byte(get_SS(),model+i)==0x20)
! Debug: ptradd unsigned char i = [S+$246-$21C] to [$29] unsigned char model = S+$246-$246 (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: logeq int = const $20 to unsigned char = al+0 (used reg = )
cmp	al,*$20
jne 	.21B
.21C:
! 1689               write_byte(get_SS(),model+i,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1690             else break;
jmp .21D
.21B:
jmp .217
!BCC_EOS
! 1691           }
.21D:
! 1692           if (i>36) {
.218:
! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
dec	ax
mov	-$21A[bp],al
.219:
! Debug: gt int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
test	al,al
jne	.21A
.21E:
.217:
! Debug: gt int = const $24 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
cmp	al,*$24
jbe 	.21F
.220:
! 1693             write_byte(get_SS(),model+36,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char model = S+$248-$222 (used reg = )
lea	bx,-$220[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1694             for(i=35;i>32;i--){
! Debug: eq int = const $23 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,*$23
mov	-$21A[bp],al
!BCC_EOS
!BCC_EOS
jmp .223
.224:
! 1695               write_byte(get_SS(),model+i,0x2E);
! Debug: list int = const $2E (used reg = )
mov	ax,*$2E
push	ax
! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1696             }
! 1697           }
.222:
! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
dec	ax
mov	-$21A[bp],al
.223:
! Debug: gt int = const $20 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
cmp	al,*$20
ja 	.224
.225:
.221:
! 1698           break;
.21F:
jmp .206
!BCC_EOS
! 1699       }
! 1700       switch (type) {
jmp .206
.208:
sub	al,*2
beq 	.209
sub	al,*1
beq 	.20A
.206:
..FFFC	=	-$246
mov	al,-6[bp]
br 	.228
! 1701         case 0x02:
! 1702           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
.229:
mov	al,-$20C[bp]
test	al,al
je  	.22D
.22E:
mov	bx,#.22B
jmp .22F
.22D:
mov	bx,#.22C
.22F:
! Debug: list * char = bx+0 (used reg = )
push	bx
! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .22A+0 (used reg = )
mov	bx,#.22A
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1703           i=0;
! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
xor	al,al
mov	-$21A[bp],al
!BCC_EOS
! 1704           while(c=read_byte(get_SS(),model+i++))
! 1705             bios_printf(2, "%c",c);
jmp .231
.232:
! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
mov	al,-$219[bp]
xor	ah,ah
push	ax
! Debug: list * char = .233+0 (used reg = )
mov	bx,#.233
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1706           if (sizeinmb < (1UL<<16))
.231:
! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
inc	ax
mov	-$21A[bp],al
! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
dec	ax
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
mov	-$219[bp],al
test	al,al
jne	.232
.234:
.230:
! Debug: lt unsigned long = const $10000 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
xor	ax,ax
mov	bx,*1
lea	di,-$216[bp]
call	lcmpul
jbe 	.235
.236:
! 1707             bios_printf(2, " ATA-%d Hard-Disk (%4u MBytes)\n", version, (Bit16u)sizeinmb);
! Debug: list unsigned short sizeinmb = [S+$246-$218] (used reg = )
push	-$216[bp]
! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .237+0 (used reg = )
mov	bx,#.237
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1708           else
! 1709             bios_printf(2, " ATA-%d Hard-Disk (%4u GBytes)\n", version, (Bit16u)(sizeinmb>>10));
jmp .238
.235:
! Debug: sr int = const $A to unsigned long sizeinmb = [S+$246-$218] (used reg = )
mov	ax,-$216[bp]
mov	bx,-$214[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*2
call	lsrul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .239+0 (used reg = )
mov	bx,#.239
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1710           break;
.238:
br 	.226
!BCC_EOS
! 1711         case 0x03:
! 1712           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
.23A:
mov	al,-$20C[bp]
test	al,al
je  	.23E
.23F:
mov	bx,#.23C
jmp .240
.23E:
mov	bx,#.23D
.240:
! Debug: list * char = bx+0 (used reg = )
push	bx
! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .23B+0 (used reg = )
mov	bx,#.23B
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1713           i=0; while(c=read_byte(get_SS(),model+i++)) bios_printf(2, "%c",c);
! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
xor	al,al
mov	-$21A[bp],al
!BCC_EOS
jmp .242
.243:
! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
mov	al,-$219[bp]
xor	ah,ah
push	ax
! Debug: list * char = .244+0 (used reg = )
mov	bx,#.244
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1714           if(read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].de
.242:
! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
inc	ax
mov	-$21A[bp],al
! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
dec	ax
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
mov	-$219[bp],al
test	al,al
jne	.243
.245:
.241:
! 1714 vice)==0x05)
! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: logeq int = const 5 to unsigned char = al+0 (used reg = )
cmp	al,*5
jne 	.246
.247:
! 1715             bios_printf(2, " ATAPI-%d CD-Rom/DVD-Rom\n",version);
! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .248+0 (used reg = )
mov	bx,#.248
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1716           else
! 1717             bios_printf(2, " ATAPI-%d Device\n",version);
jmp .249
.246:
! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .24A+0 (used reg = )
mov	bx,#.24A
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1718           break;
.249:
jmp .226
!BCC_EOS
! 1719         case 0x01:
! 1720           bios_printf(2, "ata%d %s: Unknown device\n",channel,slave?" slave":"master");
.24B:
mov	al,-$20C[bp]
test	al,al
je  	.24F
.250:
mov	bx,#.24D
jmp .251
.24F:
mov	bx,#.24E
.251:
! Debug: list * char = bx+0 (used reg = )
push	bx
! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .24C+0 (used reg = )
mov	bx,#.24C
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1721           break;
jmp .226
!BCC_EOS
! 1722       }
! 1723     }
jmp .226
.228:
sub	al,*1
je 	.24B
sub	al,*1
beq 	.229
sub	al,*1
beq 	.23A
.226:
..FFFB	=	-$246
add	sp,*$32
! 1724   }
add	sp,*$C
! 1725   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount, hdcount);
.1A1:
! Debug: postinc unsigned char device = [S+$208-7] (used reg = )
mov	al,-5[bp]
inc	ax
mov	-5[bp],al
.1A2:
! Debug: lt int = const 8 to unsigned char device = [S+$208-7] (used reg = )
mov	al,-5[bp]
cmp	al,*8
blo 	.1A3
.252:
.1A0:
! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1726   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount, cdcount);
! Debug: list unsigned char cdcount = [S+$208-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $23B (used reg = )
mov	ax,#$23B
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1727   write_byte(0x40,0x75, hdcount);
! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $75 (used reg = )
mov	ax,*$75
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1728   bios_printf(2, "\n");
! Debug: list * char = .253+0 (used reg = )
mov	bx,#.253
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1729 }
mov	sp,bp
pop	bp
ret
! 1730 void ata_reset(device)
! Register BX used in function ata_detect
! 1731 Bit16u device;
export	_ata_reset
_ata_reset:
!BCC_EOS
! 1732 {
! 1733   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1734   Bit16u iobase1, iobase2;
!BCC_EOS
! 1735   Bit8u channel, slave, sn, sc;
!BCC_EOS
! 1736   Bit8u type;
!BCC_EOS
! 1737   Bit16u max;
!BCC_EOS
! 1738   channel = device / 2;
add	sp,*-$C
! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 1739   slave = device % 2;
! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$A] (used reg = )
mov	-8[bp],al
!BCC_EOS
! 1740   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
mov	al,-7[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 1741   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
mov	al,-7[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 1742   outb(iobase2+6, 0x08 | 0x02 | 0x04);
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1743   await_ide(1, iobase1, 20);
! Debug: list int = const $14 (used reg = )
mov	ax,*$14
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1744   outb(iobase2+6, 0x08 | 0x02);
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1745   type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char type = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1746   if (type != 0x00) {
! Debug: ne int = const 0 to unsigned char type = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
beq 	.254
.255:
! 1747     outb(iobase1+6, slave?0xb0:0xa0);
mov	al,-8[bp]
test	al,al
je  	.256
.257:
mov	al,#$B0
jmp .258
.256:
mov	al,#$A0
.258:
! Debug: list char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1748     sc = inb(iobase1+2);
! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$10-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1749     sn = inb(iobase1+3);
! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 1750     if ( (sc==0x01) && (sn==0x01) ) {
! Debug: logeq int = const 1 to unsigned char sc = [S+$10-$C] (used reg = )
mov	al,-$A[bp]
cmp	al,*1
jne 	.259
.25B:
! Debug: logeq int = const 1 to unsigned char sn = [S+$10-$B] (used reg = )
mov	al,-9[bp]
cmp	al,*1
jne 	.259
.25A:
! 1751       if (type == 0x02)
! Debug: logeq int = const 2 to unsigned char type = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
cmp	al,*2
jne 	.25C
.25D:
! 1752         await_ide(5, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1753       else
! 1754         await_ide(2, iobase1, 32000u);
jmp .25E
.25C:
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1755     }
.25E:
! 1756     await_ide(2, iobase1, 32000u);
.259:
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1757   }
! 1758   outb(iobase2+6, 0x08);
.254:
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1759 }
mov	sp,bp
pop	bp
ret
! 1760 Bit16u ata_cmd_non_data()
! Register BX used in function ata_reset
! 1761 {return 0;}
export	_ata_cmd_non_data
_ata_cmd_non_data:
push	bp
mov	bp,sp
xor	ax,ax
pop	bp
ret
!BCC_EOS
! 1762 Bit16u ata_cmd_data_in(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
! 1763 Bit16u device, command, count, cylinder, head, sector, segment, offset;
export	_ata_cmd_data_in
_ata_cmd_data_in:
!BCC_EOS
! 1764 Bit32u lba_low, lba_high;
!BCC_EOS
! 1765 {
! 1766   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1767   Bit16u iobase1, iobase2, blksize;
!BCC_EOS
! 1768   Bit8u channel, slave;
!BCC_EOS
! 1769   Bit8u status, current, mode;
!BCC_EOS
! 1770   channel = device / 2;
add	sp,*-$C
! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 1771   slave = device % 2;
! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1772   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
mov	al,-9[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 1773   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
mov	al,-9[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 1774   mode = read_byte(ebda_seg, &((ebda_data_t *) 0
! 1774 )->ata.devices[device].mode);
! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 1775   blksize = 0x200;
! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,#$200
mov	-8[bp],ax
!BCC_EOS
! 1776   if (mode == 0x01) blksize>>=2;
! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
mov	al,-$D[bp]
cmp	al,*1
jne 	.25F
.260:
! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! 1777   else blksize>>=1;
jmp .261
.25F:
! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! 1778   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
.261:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1779   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1780   current = 0;
! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
xor	al,al
mov	-$C[bp],al
!BCC_EOS
! 1781   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1782   if (status & 0x80) return 1;
! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$80
test	al,al
je  	.262
.263:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1783   outb(iobase2 + 6, 0x08 | 0x02);
.262:
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1784   if (sector == 0) {
! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
mov	ax,$E[bp]
test	ax,ax
bne 	.264
.265:
! 1785     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
cmp	ax,#$100
jb 	.26A
mov	al,*1
jmp	.26B
.26A:
xor	al,al
.26B:
! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
xor	ah,ah
cwd
mov	bx,dx
call	ltstl
jne 	.267
.269:
mov	ax,$14[bp]
mov	bx,$16[bp]
call	ltstl
jne 	.267
.268:
! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
! Debug: expression subtree swapping
lea	di,$10[bp]
call	laddul
! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$1000
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	lcmpul
lea	sp,-$E[bp]
blo 	.266
.267:
! 1786       outb(iobase1 + 1, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1787       outb(iobase1 + 2, (count >> 8) & 0xff);
! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
mov	al,ah
xor	ah,ah
! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1788       outb(iobase1 + 3, lba_low >> 24);
! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1789       outb(iobase1 + 4, lba_high & 0xff);
! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,$14[bp]
call	landul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1790       outb(iobase1 + 5, lba_high >> 8);
! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
mov	ax,$14[bp]
mov	bx,$16[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1791       command |= 0x04;
! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
mov	ax,6[bp]
or	al,*4
mov	6[bp],ax
!BCC_EOS
! 1792       count &= (1UL << 8) - 1;
! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
push	bx
push	ax
mov	ax,#$FF
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
mov	8[bp],ax
add	sp,*8
!BCC_EOS
! 1793       lba_low &= (1UL << 24) - 1;
! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,#$FFFF
mov	bx,#$FF
push	bx
push	ax
mov	ax,$10[bp]
mov	bx,$12[bp]
lea	di,-$12[bp]
call	landul
mov	$10[bp],ax
mov	$12[bp],bx
add	sp,*4
!BCC_EOS
! 1794     }
! 1795     sector = (Bit16u) (lba_low & 0x000000ffL);
.266:
! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,$10[bp]
call	landul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
mov	$E[bp],ax
!BCC_EOS
! 1796     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$FFFF
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
mov	$A[bp],ax
!BCC_EOS
! 1797     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$F
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
or	al,*$40
! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
mov	$C[bp],ax
!BCC_EOS
! 1798   }
! 1799   outb(iobase1 + 1, 0x00);
.264:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1800   outb(iobase1 + 2, count);
! Debug: list unsigned short count = [S+$10+6] (used reg = )
push	8[bp]
! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1801   outb(iobase1 + 3, sector);
! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
push	$E[bp]
! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1802   outb(iobase1 + 4, cylinder & 0x00ff);
! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
mov	al,$A[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1803   outb(iobase1 + 5, cylinder >> 8);
! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
mov	ax,$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1804   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
mov	al,-$A[bp]
test	al,al
je  	.26D
.26E:
mov	al,#$B0
jmp .26F
.26D:
mov	al,#$A0
.26F:
! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
or	al,$C[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1805   outb(iobase1 + 7, command);
! Debug: list unsigned short command = [S+$10+4] (used reg = )
push	6[bp]
! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1806   await_ide(3, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1807   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1808   if (status & 0x01) {
! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,*1
test	al,al
je  	.270
.271:
! 1809     ;
!BCC_EOS
! 1810     return 2;
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1811   } else if ( !(status & 0x08) ) {
jmp .272
.270:
! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,*8
test	al,al
jne 	.273
.274:
! 1812     ;
!BCC_EOS
! 1813     return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1814   }
! 1815 #asm
.273:
.272:
!BCC_EOS
!BCC_ASM
_ata_cmd_data_in.count	set	$16
.ata_cmd_data_in.count	set	8
_ata_cmd_data_in.segment	set	$26
.ata_cmd_data_in.segment	set	$18
_ata_cmd_data_in.iobase1	set	$A
.ata_cmd_data_in.iobase1	set	-4
_ata_cmd_data_in.channel	set	5
.ata_cmd_data_in.channel	set	-9
_ata_cmd_data_in.lba_low	set	$1E
.ata_cmd_data_in.lba_low	set	$10
_ata_cmd_data_in.lba_high	set	$22
.ata_cmd_data_in.lba_high	set	$14
_ata_cmd_data_in.sector	set	$1C
.ata_cmd_data_in.sector	set	$E
_ata_cmd_data_in.blksize	set	6
.ata_cmd_data_in.blksize	set	-8
_ata_cmd_data_in.head	set	$1A
.ata_cmd_data_in.head	set	$C
_ata_cmd_data_in.cylinder	set	$18
.ata_cmd_data_in.cylinder	set	$A
_ata_cmd_data_in.device	set	$12
.ata_cmd_data_in.device	set	4
_ata_cmd_data_in.ebda_seg	set	$C
.ata_cmd_data_in.ebda_seg	set	-2
_ata_cmd_data_in.status	set	3
.ata_cmd_data_in.status	set	-$B
_ata_cmd_data_in.current	set	2
.ata_cmd_data_in.current	set	-$C
_ata_cmd_data_in.command	set	$14
.ata_cmd_data_in.command	set	6
_ata_cmd_data_in.mode	set	1
.ata_cmd_data_in.mode	set	-$D
_ata_cmd_data_in.iobase2	set	8
.ata_cmd_data_in.iobase2	set	-6
_ata_cmd_data_in.offset	set	$28
.ata_cmd_data_in.offset	set	$1A
_ata_cmd_data_in.slave	set	4
.ata_cmd_data_in.slave	set	-$A
        sti ;; enable higher priority interrupts
! 1817 endasm
!BCC_ENDASM
!BCC_EOS
! 1818   while (1) {
.277:
! 1819 #asm
!BCC_EOS
!BCC_ASM
_ata_cmd_data_in.count	set	$16
.ata_cmd_data_in.count	set	8
_ata_cmd_data_in.segment	set	$26
.ata_cmd_data_in.segment	set	$18
_ata_cmd_data_in.iobase1	set	$A
.ata_cmd_data_in.iobase1	set	-4
_ata_cmd_data_in.channel	set	5
.ata_cmd_data_in.channel	set	-9
_ata_cmd_data_in.lba_low	set	$1E
.ata_cmd_data_in.lba_low	set	$10
_ata_cmd_data_in.lba_high	set	$22
.ata_cmd_data_in.lba_high	set	$14
_ata_cmd_data_in.sector	set	$1C
.ata_cmd_data_in.sector	set	$E
_ata_cmd_data_in.blksize	set	6
.ata_cmd_data_in.blksize	set	-8
_ata_cmd_data_in.head	set	$1A
.ata_cmd_data_in.head	set	$C
_ata_cmd_data_in.cylinder	set	$18
.ata_cmd_data_in.cylinder	set	$A
_ata_cmd_data_in.device	set	$12
.ata_cmd_data_in.device	set	4
_ata_cmd_data_in.ebda_seg	set	$C
.ata_cmd_data_in.ebda_seg	set	-2
_ata_cmd_data_in.status	set	3
.ata_cmd_data_in.status	set	-$B
_ata_cmd_data_in.current	set	2
.ata_cmd_data_in.current	set	-$C
_ata_cmd_data_in.command	set	$14
.ata_cmd_data_in.command	set	6
_ata_cmd_data_in.mode	set	1
.ata_cmd_data_in.mode	set	-$D
_ata_cmd_data_in.iobase2	set	8
.ata_cmd_data_in.iobase2	set	-6
_ata_cmd_data_in.offset	set	$28
.ata_cmd_data_in.offset	set	$1A
_ata_cmd_data_in.slave	set	4
.ata_cmd_data_in.slave	set	-$A
        push bp
        mov bp, sp
        mov di, _ata_cmd_data_in.offset + 2[bp]
        mov ax, _ata_cmd_data_in.segment + 2[bp]
        mov cx, _ata_cmd_data_in.blksize + 2[bp]
        ;; adjust if there will be an overrun. 2K max sector size
        cmp di, #0xf800 ;;
        jbe ata_in_no_adjust
ata_in_adjust:
        sub di, #0x0800 ;; sub 2 kbytes from offset
        add ax, #0x0080 ;; add 2 Kbytes to segment
ata_in_no_adjust:
        mov es, ax ;; segment in es
        mov dx, _ata_cmd_data_in.iobase1 + 2[bp] ;; ATA data read port
        mov ah, _ata_cmd_data_in.mode + 2[bp]
        cmp ah, #0x01
        je ata_in_32
ata_in_16:
        rep
          insw ;; CX words transfered from port(DX) to ES:[DI]
        jmp ata_in_done
ata_in_32:
        rep
          insd ;; CX dwords transfered from port(DX) to ES:[DI]
ata_in_done:
        mov _ata_cmd_data_in.offset + 2[bp], di
        mov _ata_cmd_data_in.segment + 2[bp], es
        pop bp
! 1848 endasm
!BCC_ENDASM
!BCC_EOS
! 1849     current++;
! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
inc	ax
mov	-$C[bp],al
!BCC_EOS
! 1850     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
! Debug: list unsigned char current = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1851     count--;
! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
dec	ax
mov	8[bp],ax
!BCC_EOS
! 1852     await_ide(2, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1853     status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1854     if (count == 0) {
! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
test	ax,ax
jne 	.278
.279:
! 1855       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
! 1856           != 0x40 ) {
! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$C9
! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
je  	.27A
.27B:
! 1857         ;
!BCC_EOS
! 1858         return 4;
mov	ax,*4
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1859       }
! 1860       break;
.27A:
jmp .275
!BCC_EOS
! 1861     }
! 1862     else {
jmp .27C
.278:
! 1863       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
! 1864           != (0x40 | 0x08) ) {
! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$C9
! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
cmp	al,*$48
je  	.27D
.27E:
! 1865         ;
!BCC_EOS
! 1866         return 5;
mov	ax,*5
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1867       }
! 1868       continue;
.27D:
jmp .276
!BCC_EOS
! 1869     }
! 1870   }
.27C:
! 1871   outb(iobase2+6, 0x08);
.276:
jmp	.277
.27F:
.275:
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1872   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1873 }
! 1874 Bit16u ata_cmd_data_out(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
! Register BX used in function ata_cmd_data_in
! 1875 Bit16u device, command, count, cylinder, head, sector, segment, offset;
export	_ata_cmd_data_out
_ata_cmd_data_out:
!BCC_EOS
! 1876 Bit32u lba_low, lba_high;
!BCC_EOS
! 1877 {
! 1878   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1879   Bit16u iobase1, iobase2, blksize;
!BCC_EOS
! 1880   Bit8u channel, slave;
!BCC_EOS
! 1881   Bit8u status, current, mode;
!BCC_EOS
! 1882   channel = device / 2;
add	sp,*-$C
! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 1883   slave = device % 2;
! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1884   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
mov	al,-9[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 1885   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
mov	al,-9[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 1886   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 1887   blksize = 0x200;
! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,#$200
mov	-8[bp],ax
!BCC_EOS
! 1888   if (mode == 0x01) blksize>>=2;
! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
mov	al,-$D[bp]
cmp	al,*1
jne 	.280
.281:
! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! 1889   else blksize>>=1;
jmp .282
.280:
! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! 1890   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
.282:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1891   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1892   current = 0;
! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
xor	al,al
mov	-$C[bp],al
!BCC_EOS
! 1893   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1894   if (status & 0x80) return 1;
! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$80
test	al,al
je  	.283
.284:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1895   outb(iobase2 + 6, 0x08 | 0x02);
.283:
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1896   if (sector == 0) {
! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
mov	ax,$E[bp]
test	ax,ax
bne 	.285
.286:
! 1897     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
cmp	ax,#$100
jb 	.28B
mov	al,*1
jmp	.28C
.28B:
xor	al,al
.28C:
! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
xor	ah,ah
cwd
mov	bx,dx
call	ltstl
jne 	.288
.28A:
mov	ax,$14[bp]
mov	bx,$16[bp]
call	ltstl
jne 	.288
.289:
! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
! Debug: expression subtree swapping
lea	di,$10[bp]
call	laddul
! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$1000
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	lcmpul
lea	sp,-$E[bp]
blo 	.287
.288:
! 1898       outb(iobase1 + 1, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1899       outb(iobase1 + 2, (count >> 8) & 0xff);
! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
mov	al,ah
xor	ah,ah
! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1900       outb(iobase1 + 3, lba_low >> 24);
! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1901       outb(iobase1 + 4, lba_high & 0xff);
! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,$14[bp]
call	landul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1902       outb(iobase1 + 5, l
! 1902 ba_high >> 8);
! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
mov	ax,$14[bp]
mov	bx,$16[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1903       command |= 0x04;
! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
mov	ax,6[bp]
or	al,*4
mov	6[bp],ax
!BCC_EOS
! 1904       count &= (1UL << 8) - 1;
! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
push	bx
push	ax
mov	ax,#$FF
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
mov	8[bp],ax
add	sp,*8
!BCC_EOS
! 1905       lba_low &= (1UL << 24) - 1;
! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,#$FFFF
mov	bx,#$FF
push	bx
push	ax
mov	ax,$10[bp]
mov	bx,$12[bp]
lea	di,-$12[bp]
call	landul
mov	$10[bp],ax
mov	$12[bp],bx
add	sp,*4
!BCC_EOS
! 1906     }
! 1907     sector = (Bit16u) (lba_low & 0x000000ffL);
.287:
! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,$10[bp]
call	landul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
mov	$E[bp],ax
!BCC_EOS
! 1908     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$FFFF
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
mov	$A[bp],ax
!BCC_EOS
! 1909     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$F
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
or	al,*$40
! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
mov	$C[bp],ax
!BCC_EOS
! 1910   }
! 1911   outb(iobase1 + 1, 0x00);
.285:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1912   outb(iobase1 + 2, count);
! Debug: list unsigned short count = [S+$10+6] (used reg = )
push	8[bp]
! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1913   outb(iobase1 + 3, sector);
! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
push	$E[bp]
! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1914   outb(iobase1 + 4, cylinder & 0x00ff);
! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
mov	al,$A[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1915   outb(iobase1 + 5, cylinder >> 8);
! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
mov	ax,$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1916   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
mov	al,-$A[bp]
test	al,al
je  	.28E
.28F:
mov	al,#$B0
jmp .290
.28E:
mov	al,#$A0
.290:
! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
or	al,$C[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1917   outb(iobase1 + 7, command);
! Debug: list unsigned short command = [S+$10+4] (used reg = )
push	6[bp]
! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1918   await_ide(3, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1919   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1920   if (status & 0x01) {
! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,*1
test	al,al
je  	.291
.292:
! 1921     ;
!BCC_EOS
! 1922     return 2;
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1923   } else if ( !(status & 0x08) ) {
jmp .293
.291:
! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,*8
test	al,al
jne 	.294
.295:
! 1924     ;
!BCC_EOS
! 1925     return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1926   }
! 1927 #asm
.294:
.293:
!BCC_EOS
!BCC_ASM
_ata_cmd_data_out.count	set	$16
.ata_cmd_data_out.count	set	8
_ata_cmd_data_out.segment	set	$26
.ata_cmd_data_out.segment	set	$18
_ata_cmd_data_out.iobase1	set	$A
.ata_cmd_data_out.iobase1	set	-4
_ata_cmd_data_out.channel	set	5
.ata_cmd_data_out.channel	set	-9
_ata_cmd_data_out.lba_low	set	$1E
.ata_cmd_data_out.lba_low	set	$10
_ata_cmd_data_out.lba_high	set	$22
.ata_cmd_data_out.lba_high	set	$14
_ata_cmd_data_out.sector	set	$1C
.ata_cmd_data_out.sector	set	$E
_ata_cmd_data_out.blksize	set	6
.ata_cmd_data_out.blksize	set	-8
_ata_cmd_data_out.head	set	$1A
.ata_cmd_data_out.head	set	$C
_ata_cmd_data_out.cylinder	set	$18
.ata_cmd_data_out.cylinder	set	$A
_ata_cmd_data_out.device	set	$12
.ata_cmd_data_out.device	set	4
_ata_cmd_data_out.ebda_seg	set	$C
.ata_cmd_data_out.ebda_seg	set	-2
_ata_cmd_data_out.status	set	3
.ata_cmd_data_out.status	set	-$B
_ata_cmd_data_out.current	set	2
.ata_cmd_data_out.current	set	-$C
_ata_cmd_data_out.command	set	$14
.ata_cmd_data_out.command	set	6
_ata_cmd_data_out.mode	set	1
.ata_cmd_data_out.mode	set	-$D
_ata_cmd_data_out.iobase2	set	8
.ata_cmd_data_out.iobase2	set	-6
_ata_cmd_data_out.offset	set	$28
.ata_cmd_data_out.offset	set	$1A
_ata_cmd_data_out.slave	set	4
.ata_cmd_data_out.slave	set	-$A
        sti ;; enable higher priority interrupts
! 1929 endasm
!BCC_ENDASM
!BCC_EOS
! 1930   while (1) {
.298:
! 1931 #asm
!BCC_EOS
!BCC_ASM
_ata_cmd_data_out.count	set	$16
.ata_cmd_data_out.count	set	8
_ata_cmd_data_out.segment	set	$26
.ata_cmd_data_out.segment	set	$18
_ata_cmd_data_out.iobase1	set	$A
.ata_cmd_data_out.iobase1	set	-4
_ata_cmd_data_out.channel	set	5
.ata_cmd_data_out.channel	set	-9
_ata_cmd_data_out.lba_low	set	$1E
.ata_cmd_data_out.lba_low	set	$10
_ata_cmd_data_out.lba_high	set	$22
.ata_cmd_data_out.lba_high	set	$14
_ata_cmd_data_out.sector	set	$1C
.ata_cmd_data_out.sector	set	$E
_ata_cmd_data_out.blksize	set	6
.ata_cmd_data_out.blksize	set	-8
_ata_cmd_data_out.head	set	$1A
.ata_cmd_data_out.head	set	$C
_ata_cmd_data_out.cylinder	set	$18
.ata_cmd_data_out.cylinder	set	$A
_ata_cmd_data_out.device	set	$12
.ata_cmd_data_out.device	set	4
_ata_cmd_data_out.ebda_seg	set	$C
.ata_cmd_data_out.ebda_seg	set	-2
_ata_cmd_data_out.status	set	3
.ata_cmd_data_out.status	set	-$B
_ata_cmd_data_out.current	set	2
.ata_cmd_data_out.current	set	-$C
_ata_cmd_data_out.command	set	$14
.ata_cmd_data_out.command	set	6
_ata_cmd_data_out.mode	set	1
.ata_cmd_data_out.mode	set	-$D
_ata_cmd_data_out.iobase2	set	8
.ata_cmd_data_out.iobase2	set	-6
_ata_cmd_data_out.offset	set	$28
.ata_cmd_data_out.offset	set	$1A
_ata_cmd_data_out.slave	set	4
.ata_cmd_data_out.slave	set	-$A
        push bp
        mov bp, sp
        mov si, _ata_cmd_data_out.offset + 2[bp]
        mov ax, _ata_cmd_data_out.segment + 2[bp]
        mov cx, _ata_cmd_data_out.blksize + 2[bp]
        ;; adjust if there will be an overrun. 2K max sector size
        cmp si, #0xf800 ;;
        jbe ata_out_no_adjust
ata_out_adjust:
        sub si, #0x0800 ;; sub 2 kbytes from offset
        add ax, #0x0080 ;; add 2 Kbytes to segment
ata_out_no_adjust:
        mov es, ax ;; segment in es
        mov dx, _ata_cmd_data_out.iobase1 + 2[bp] ;; ATA data write port
        mov ah, _ata_cmd_data_out.mode + 2[bp]
        cmp ah, #0x01
        je ata_out_32
ata_out_16:
        seg ES
        rep
          outsw ;; CX words transfered from port(DX) to ES:[SI]
        jmp ata_out_done
ata_out_32:
        seg ES
        rep
          outsd ;; CX dwords transfered from port(DX) to ES:[SI]
ata_out_done:
        mov _ata_cmd_data_out.offset + 2[bp], si
        mov _ata_cmd_data_out.segment + 2[bp], es
        pop bp
! 1962 endasm
!BCC_ENDASM
!BCC_EOS
! 1963     current++;
! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
inc	ax
mov	-$C[bp],al
!BCC_EOS
! 1964     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
! Debug: list unsigned char current = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1965     count--;
! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
dec	ax
mov	8[bp],ax
!BCC_EOS
! 1966     status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1967     if (count == 0) {
! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
test	ax,ax
jne 	.299
.29A:
! 1968       if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
! 1969           != 0x40 ) {
! Debug: and int = const $E9 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$E9
! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
je  	.29B
.29C:
! 1970         ;
!BCC_EOS
! 1971         return 6;
mov	ax,*6
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1972     
! 1972   }
! 1973       break;
.29B:
jmp .296
!BCC_EOS
! 1974     }
! 1975     else {
jmp .29D
.299:
! 1976       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
! 1977           != (0x40 | 0x08) ) {
! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$C9
! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
cmp	al,*$48
je  	.29E
.29F:
! 1978         ;
!BCC_EOS
! 1979         return 7;
mov	ax,*7
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1980       }
! 1981       continue;
.29E:
jmp .297
!BCC_EOS
! 1982     }
! 1983   }
.29D:
! 1984   outb(iobase2+6, 0x08);
.297:
jmp	.298
.2A0:
.296:
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1985   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1986 }
! 1987 Bit16u ata_cmd_packet(device, cmdlen, cmdseg, cmdoff, header, length, inout, bufseg, bufoff)
! Register BX used in function ata_cmd_data_out
! 1988 Bit8u cmdlen,inout;
export	_ata_cmd_packet
_ata_cmd_packet:
!BCC_EOS
! 1989 Bit16u device,cmdseg, cmdoff, bufseg, bufoff;
!BCC_EOS
! 1990 Bit16u header;
!BCC_EOS
! 1991 Bit32u length;
!BCC_EOS
! 1992 {
! 1993   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1994   Bit16u iobase1, iobase2;
!BCC_EOS
! 1995   Bit16u lcount, lbefore, lafter, count;
!BCC_EOS
! 1996   Bit8u channel, slave;
!BCC_EOS
! 1997   Bit8u status, mode, lmode;
!BCC_EOS
! 1998   Bit32u total, transfer;
!BCC_EOS
! 1999   channel = device / 2;
add	sp,*-$1A
! Debug: div int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
mov	ax,4[bp]
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$1E-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 2000   slave = device % 2;
! Debug: mod int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
mov	ax,4[bp]
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$1E-$12] (used reg = )
mov	-$10[bp],al
!BCC_EOS
! 2001   if (inout == 0x02) {
! Debug: logeq int = const 2 to unsigned char inout = [S+$1E+$10] (used reg = )
mov	al,$12[bp]
cmp	al,*2
jne 	.2A1
.2A2:
! 2002     bios_printf(4, "ata_cmd_packet: DATA_OUT not supported yet\n");
! Debug: list * char = .2A3+0 (used reg = )
mov	bx,#.2A3
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 2003     return 1;
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2004   }
! 2005   if (header & 1) {
.2A1:
! Debug: and int = const 1 to unsigned short header = [S+$1E+$A] (used reg = )
mov	al,$C[bp]
and	al,*1
test	al,al
je  	.2A4
.2A5:
! 2006     ;
!BCC_EOS
! 2007     return 1;
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2008   }
! 2009   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
.2A4:
! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
mov	al,-$F[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$1E-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 2010   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
mov	al,-$F[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$1E-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2011   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned short device = [S+$1E+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$1E-$14] (used reg = )
mov	-$12[bp],al
!BCC_EOS
! 2012   transfer= 0L;
! Debug: eq long = const 0 to unsigned long transfer = [S+$1E-$1E] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$1C[bp],ax
mov	-$1A[bp],bx
!BCC_EOS
! 2013   if (cmdlen < 12) cmdlen=12;
! Debug: lt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,6[bp]
cmp	al,*$C
jae 	.2A6
.2A7:
! Debug: eq int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,*$C
mov	6[bp],al
!BCC_EOS
! 2014   if (cmdlen > 12) cmdlen=16;
.2A6:
! Debug: gt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,6[bp]
cmp	al,*$C
jbe 	.2A8
.2A9:
! Debug: eq int = const $10 to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,*$10
mov	6[bp],al
!BCC_EOS
! 2015   cmdlen>>=1;
.2A8:
! Debug: srab int = const 1 to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
shr	ax,*1
mov	6[bp],al
!BCC_EOS
! 2016   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2017   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2018   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2019   if (status & 0x80) return 2;
! Debug: and int = const $80 to unsigned char status = [S+$1E-$13] (used reg = )
mov	al,-$11[bp]
and	al,#$80
test	al,al
je  	.2AA
.2AB:
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2020   outb(iobase2 + 6, 0x08 | 0x02);
.2AA:
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2021   outb(iobase1 + 1, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2022   outb(iobase1 + 2, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2023   outb(iobase1 + 3, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2024   outb(iobase1 + 4, 0xfff0 & 0x00ff);
! Debug: list unsigned int = const $F0 (used reg = )
mov	ax,#$F0
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2025   outb(iobase1 + 5, 0xfff0 >> 8);
! Debug: list unsigned int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2026   outb(iobase1 + 6, slave ? 0xb0 : 0xa0);
mov	al,-$10[bp]
test	al,al
je  	.2AC
.2AD:
mov	al,#$B0
jmp .2AE
.2AC:
mov	al,#$A0
.2AE:
! Debug: list char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2027   outb(iobase1 + 7, 0xA0);
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2028   await_ide(3, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
push	-4[bp]
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 2029   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2030   if (status & 0x01) {
! Debug: and int = const 1 to unsigned char status = [S+$1E-$13] (used reg = )
mov	al,-$11[bp]
and	al,*1
test	al,al
je  	.2AF
.2B0:
! 2031     ;
!BCC_EOS
! 2032     return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2033   } else if ( !(status & 0x08) ) {
jmp .2B1
.2AF:
! Debug: and int = const 8 to unsigned char status = [S+$1E-$13] (used reg = )
mov	al,-$11[bp]
and	al,*8
test	al,al
jne 	.2B2
.2B3:
! 2034     ;
!BCC_EOS
! 2035     return 4;
mov	ax,*4
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2036   }
! 2037   cmdseg += (cmdoff / 16);
.2B2:
.2B1:
! Debug: div int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
mov	ax,$A[bp]
mov	cl,*4
shr	ax,cl
! Debug: addab unsigned int = ax+0 to unsigned short cmdseg = [S+$1E+6] (used reg = )
add	ax,8[bp]
mov	8[bp],ax
!BCC_EOS
! 2038   cmdoff %= 16;
! Debug: modab int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
mov	ax,$A[bp]
and	al,*$F
xor	ah,ah
mov	$A[bp],ax
!BCC_EOS
! 2039 #asm
!BCC_EOS
!BCC_ASM
_ata_cmd_packet.cmdoff	set	$26
.ata_cmd_packet.cmdoff	set	$A
_ata_cmd_packet.header	set	$28
.ata_cmd_packet.header	set	$C
_ata_cmd_packet.count	set	$E
.ata_cmd_packet.count	set	-$E
_ata_cmd_packet.lafter	set	$10
.ata_cmd_packet.lafter	set	-$C
_ata_cmd_packet.iobase1	set	$18
.ata_cmd_packet.iobase1	set	-4
_ata_cmd_packet.channel	set	$D
.ata_cmd_packet.channel	set	-$F
_ata_cmd_packet.cmdseg	set	$24
.ata_cmd_packet.cmdseg	set	8
_ata_cmd_packet.cmdlen	set	$22
.ata_cmd_packet.cmdlen	set	6
_ata_cmd_packet.lmode	set	9
.ata_cmd_packet.lmode	set	-$13
_ata_cmd_packet.device	set	$20
.ata_cmd_packet.device	set	4
_ata_cmd_packet.ebda_seg	set	$1A
.ata_cmd_packet.ebda_seg	set	-2
_ata_cmd_packet.lcount	set	$14
.ata_cmd_packet.lcount	set	-8
_ata_cmd_packet.total	set	4
.ata_cmd_packet.total	set	-$18
_ata_cmd_packet.status	set	$B
.ata_cmd_packet.status	set	-$11
_ata_cmd_packet.mode	set	$A
.ata_cmd_packet.mode	set	-$12
_ata_cmd_packet.bufoff	set	$32
.ata_cmd_packet.bufoff	set	$16
_ata_cmd_packet.transfer	set	0
.ata_cmd_packet.transfer	set	-$1C
_ata_cmd_packet.iobase2	set	$16
.ata_cmd_packet.iobase2	set	-6
_ata_cmd_packet.lbefore	set	$12
.ata_cmd_packet.lbefore	set	-$A
_ata_cmd_packet.bufseg	set	$30
.ata_cmd_packet.bufseg	set	$14
_ata_cmd_packet.slave	set	$C
.ata_cmd_packet.slave	set	-$10
_ata_cmd_packet.inout	set	$2E
.ata_cmd_packet.inout	set	$12
_ata_cmd_packet.length	set	$2A
.ata_cmd_packet.length	set	$E
      sti ;; enable higher priority interrupts
      push bp
      mov bp, sp
      mov si, _ata_cmd_packet.cmdoff + 2[bp]
      mov ax, _ata_cmd_packet.cmdseg + 2[bp]
      mov cx, _ata_cmd_packet.cmdlen + 2[bp]
      mov es, ax ;; segment in es
      mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data write port
      seg ES
      rep
        outsw ;; CX words transfered from port(DX) to ES:[SI]
      pop bp
! 2052 endasm
!BCC_ENDASM
!BCC_EOS
! 2053   if (inout == 0x00) {
! Debug: logeq int = const 0 to unsigned char inout = [S+$1E+$10] (used reg = )
mov	al,$12[bp]
test	al,al
jne 	.2B4
.2B5:
! 2054     await_ide(2, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 2055     status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2056   }
! 2057   else {
br 	.2B6
.2B4:
! 2058     Bit16u loops = 0;
dec	sp
dec	sp
! Debug: eq int = const 0 to unsigned short loops = [S+$20-$20] (used reg = )
xor	ax,ax
mov	-$1E[bp],ax
!BCC_EOS
! 2059     Bit8u sc;
!BCC_EOS
! 2060     while (1) {
dec	sp
dec	sp
.2B9:
! 2061       if (loops == 0) {
! Debug: logeq int = const 0 to unsigned short loops = [S+$22-$20] (used reg = )
mov	ax,-$1E[bp]
test	ax,ax
jne 	.2BA
.2BB:
! 2062         status = inb(iobase2 + 6);
! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2063         await_ide(3, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
push	-4[bp]
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 2064       }
! 2065       else
! 2066         await_ide(2, iobase1, 32000u);
jmp .2BC
.2BA:
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 2067       loops++;
.2BC:
! Debug: postinc unsigned short loops = [S+$22-$20] (used reg = )
mov	ax,-$1E[bp]
inc	ax
mov	-$1E[bp],ax
!BCC_EOS
! 2068       status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$22-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2069       sc = inb(iobase1 + 2);
! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$22-$21] (used reg = )
mov	-$1F[bp],al
!BCC_EOS
! 2070       if(((inb(iobase1 + 2)&0x7)==0x3) &&
! 2071          ((status & (0x40 | 0x01)) == 0x40)) break;
! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 7 to unsigned char = al+0 (used reg = )
and	al,*7
! Debug: logeq int = const 3 to unsigned char = al+0 (used reg = )
cmp	al,*3
jne 	.2BD
.2BF:
! Debug: and int = const $41 to unsigned char status = [S+$22-$13] (used reg = )
mov	al,-$11[bp]
and	al,*$41
! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
jne 	.2BD
.2BE:
br 	.2B7
!BCC_EOS
! 2072       if (status & 0x01) {
.2BD:
! Debug: and int = const 1 to unsigned char status = [S+$22-$13] (used reg = )
mov	al,-$11[bp]
and	al,*1
test	al,al
je  	.2C0
.2C1:
! 2073         ;
!BCC_EOS
! 2074         return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2075       }
! 2076       bufseg += (bufoff / 16);
.2C0:
! Debug: div int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
mov	ax,$16[bp]
mov	cl,*4
shr	ax,cl
! Debug: addab unsigned int = ax+0 to unsigned short bufseg = [S+$22+$12] (used reg = )
add	ax,$14[bp]
mov	$14[bp],ax
!BCC_EOS
! 2077       bufoff %= 16;
! Debug: modab int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
mov	ax,$16[bp]
and	al,*$F
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 2078       lcount = ((Bit16u)(inb(iobase1 + 5))<<8)+inb(iobase1 + 4);
! Debug: add int = const 4 to unsigned short iobase1 = [S+$22-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$24-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
mov	ah,al
xor	al,al
! Debug: add unsigned char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
add	al,-$22[bp]
adc	ah,*0
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 2079       if(header>lcount) {
! Debug: gt unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
cmp	ax,-8[bp]
jbe 	.2C2
.2C3:
! 2080          lbefore=lcount;
! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	ax,-8[bp]
mov	-$A[bp],ax
!BCC_EOS
! 2081          header-=lcount;
! Debug: subab unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
sub	ax,-8[bp]
mov	$C[bp],ax
!BCC_EOS
! 2082          lcount=0;
! Debug: eq int = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
xor	ax,ax
mov	-8[bp],ax
!BCC_EOS
! 2083       }
! 2084       else {
jmp .2C4
.2C2:
! 2085         lbefore=header;
! Debug: eq unsigned short header = [S+$22+$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	ax,$C[bp]
mov	-$A[bp],ax
!BCC_EOS
! 2086         header=0;
! Debug: eq int = const 0 to unsigned short header = [S+$22+$A] (used reg = )
xor	ax,ax
mov	$C[bp],ax
!BCC_EOS
! 2087         lcount-=lbefore;
! Debug: subab unsigned short lbefore = [S+$22-$C] to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
sub	ax,-$A[bp]
mov	-8[bp],ax
!BCC_EOS
! 2088       }
! 2089       if(lcount>length) {
.2C4:
! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
xor	bx,bx
! Debug: gt unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
lea	di,$E[bp]
call	lcmpul
jbe 	.2C5
.2C6:
! 2090         lafter=lcount-length;
! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
xor	bx,bx
! Debug: sub unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
lea	di,$E[bp]
call	lsubul
! Debug: eq unsigned long = bx+0 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 2091         lcount=length;
! Debug: eq unsigned long length = [S+$22+$C] to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,$E[bp]
mov	-8[bp],ax
!BCC_EOS
! 2092         length=0;
! Debug: eq int = const 0 to unsigned long length = [S+$22+$C] (used reg = )
xor	ax,ax
xor	bx,bx
mov	$E[bp],ax
mov	$10[bp],bx
!BCC_EOS
! 2093       }
! 2094       else {
jmp .2C7
.2C5:
! 2095         lafter=0;
! Debug: eq int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
xor	ax,ax
mov	-$C[bp],ax
!BCC_EOS
! 2096         length-=lcount;
! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
xor	bx,bx
! Debug: subab unsigned long = bx+0 to unsigned long length = [S+$22+$C] (used reg = )
push	bx
push	ax
mov	ax,$E[bp]
mov	bx,$10[bp]
lea	di,-$24[bp]
call	lsubul
mov	$E[bp],ax
mov	$10[bp],bx
add	sp,*4
!BCC_EOS
! 2097       }
! 2098       count = lcount;
.2C7:
! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short count = [S+$22-$10] (used reg = )
mov	ax,-8[bp]
mov	-$E[bp],ax
!BCC_EOS
! 2099       ;
!BCC_EOS
! 2100       ;
!BCC_EOS
! 2101       lmode = mode;
! Debug: eq unsigned char mode = [S+$22-$14] to unsigned char lmode = [S+$22-$15] (used reg = )
mov	al,-$12[bp]
mov	-$13[bp],al
!BCC_EOS
! 2102       if (lbefore & 0x03) lmode=0x00;
! Debug: and int = const 3 to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	al,-$A[bp]
and	al,*3
test	al,al
je  	.2C8
.2C9:
! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
xor	al,al
mov	-$13[bp],al
!BCC_EOS
! 2103       if (lcount & 0x03) lmode=0x00;
.2C8:
! Debug: and int = const 3 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	al,-8[bp]
and	al,*3
test	al,al
je  	.2CA
.2CB:
! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
xor	al,al
mov	-$13[bp],al
!BCC_EOS
! 2104       if (lafter & 0x03) lmode=0x00;
.2CA:
! Debug: and int = const 3 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	al,-$C[bp]
and	al,*3
test	al,al
je  	.2CC
.2CD:
! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
xor	al,al
mov	-$13[bp],al
!BCC_EOS
! 2105       if (lcount & 0x01) {
.2CC:
! Debug: and int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	al,-8[bp]
and	al,*1
test	al,al
je  	.2CE
.2CF:
! 2106         lcount+=1;
! Debug: addab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
inc	ax
mov	-8[bp],ax
!BCC_EOS
! 2107         if ((lafter > 0) && (lafter & 0x01)) {
! Debug: gt int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	ax,-$C[bp]
test	ax,ax
je  	.2D0
.2D2:
! Debug: and int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	al,-$C[bp]
and	al,*1
test	al,al
je  	.2D0
.2D1:
! 2108           lafter-=1;
! Debug: subab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	ax,-$C[bp]
dec	ax
mov	-$C[bp],ax
!BCC_EOS
! 2109         }
! 2110       }
.2D0:
! 2111       if (lmode == 0x01) {
.2CE:
! Debug: logeq int = const 1 to unsigned char lmode = [S+$22-$15] (used reg = )
mov	al,-$13[bp]
cmp	al,*1
jne 	.2D3
.2D4:
! 2112         lcount>>=2; lbefore>>=2; lafter>>=2;
! Debug: srab int = const 2 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! Debug: srab int = const 2 to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	ax,-$A[bp]
shr	ax,*1
shr	ax,*1
mov	-$A[bp],ax
!BCC_EOS
! Debug: srab int = const 2 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	ax,-$C[bp]
shr	ax,*1
shr	ax,*1
mov	-$C[bp],ax
!BCC_EOS
! 2113       }
! 2114       else {
jmp .2D5
.2D3:
! 2115         lcount>>=1; lbefore>>=1; lafter>>=1;
! Debug: srab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! Debug: srab int = const 1 to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	ax,-$A[bp]
shr	ax,*1
mov	-$A[bp],ax
!BCC_EOS
! Debug: srab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	ax,-$C[bp]
shr	ax,*1
mov	-$C[bp],ax
!BCC_EOS
! 2116       }
! 2117        ;
.2D5:
!BCC_EOS
! 2118 #asm
!BCC_EOS
!BCC_ASM
_ata_cmd_packet.cmdoff	set	$2A
.ata_cmd_packet.cmdoff	set	$A
_ata_cmd_packet.header	set	$2C
.ata_cmd_packet.header	set	$C
_ata_cmd_packet.count	set	$12
.ata_cmd_packet.count	set	-$E
_ata_cmd_packet.lafter	set	$14
.ata_cmd_packet.lafter	set	-$C
_ata_cmd_packet.iobase1	set	$1C
.ata_cmd_packet.iobase1	set	-4
_ata_cmd_packet.channel	set	$11
.ata_cmd_packet.channel	set	-$F
_ata_cmd_packet.cmdseg	set	$28
.ata_cmd_packet.cmdseg	set	8
_ata_cmd_packet.cmdlen	set	$26
.ata_cmd_packet.cmdlen	set	6
_ata_cmd_packet.lmode	set	$D
.ata_cmd_packet.lmode	set	-$13
_ata_cmd_packet.device	set	$24
.ata_cmd_packet.device	set	4
_ata_cmd_packet.loops	set	2
.ata_cmd_packet.loops	set	-$1E
_ata_cmd_packet.ebda_seg	set	$1E
.ata_cmd_packet.ebda_seg	set	-2
_ata_cmd_packet.lcount	set	$18
.ata_cmd_packet.lcount	set	-8
_ata_cmd_packet.total	set	8
.ata_cmd_packet.total	set	-$18
_ata_cmd_packet.status	set	$F
.ata_cmd_packet.status	set	-$11
_ata_cmd_packet.mode	set	$E
.ata_cmd_packet.mode	set	-$12
_ata_cmd_packet.bufoff	set	$36
.ata_cmd_packet.bufoff	set	$16
_ata_cmd_packet.transfer	set	4
.ata_cmd_packet.transfer	set	-$1C
_ata_cmd_packet.sc	set	1
.ata_cmd_packet.sc	set	-$1F
_ata_cmd_packet.iobase2	set	$1A
.ata_cmd_packet.iobase2	set	-6
_ata_cmd_packet.lbefore	set	$16
.ata_cmd_packet.lbefore	set	-$A
_ata_cmd_packet.bufseg	set	$34
.ata_cmd_packet.bufseg	set	$14
_ata_cmd_packet.slave	set	$10
.ata_cmd_packet.slave	set	-$10
_ata_cmd_packet.inout	set	$32
.ata_cmd_packet.inout	set	$12
_ata_cmd_packet.length	set	$2E
.ata_cmd_packet.length	set	$E
        push bp
        mov bp, sp
        mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data read port
        mov cx, _ata_cmd_packet.lbefore + 2[bp]
        jcxz ata_packet_no_before
        mov ah, _ata_cmd_packet.lmode + 2[bp]
        cmp ah, #0x01
        je ata_packet_in_before_32
ata_packet_in_before_16:
        in ax, dx
        loop ata_packet_in_before_16
        jmp ata_packet_no_before
ata_packet_in_before_32:
        push eax
ata_packet_in_before_32_loop:
        in eax, dx
        loop ata_packet_in_before_32_loop
        pop eax
ata_packet_no_before:
        mov cx, _ata_cmd_packet.lcount + 2[bp]
        jcxz ata_packet_after
        mov di, _ata_cmd_packet.bufoff + 2[bp]
        mov ax, _ata_cmd_packet.bufseg + 2[bp]
        mov es, ax
        mov ah, _ata_cmd_packet.lmode + 2[bp]
        cmp ah, #0x01
        je ata_packet_in_32
ata_packet_in_16:
        rep
          insw ;; CX words transfered tp port(DX) to ES:[DI]
        jmp ata_packet_after
ata_packet_in_32:
        rep
          insd ;; CX dwords transfered to port(DX) to ES:[DI]
ata_packet_after:
        mov cx, _ata_cmd_packet.lafter + 2[bp]
        jcxz ata_packet_done
        mov ah, _ata_cmd_packet.lmode + 2[bp]
        cmp ah, #0x01
        je ata_packet_in_after_32
ata_packet_in_after_16:
        in ax, dx
        loop ata_packet_in_after_16
        jmp ata_packet_done
ata_packet_in_after_32:
        push eax
ata_packet_in_after_32_loop:
        in eax, dx
        loop ata_packet_in_after_32_loop
        pop eax
ata_packet_done:
        pop bp
! 2171 endasm
!BCC_ENDASM
!BCC_EOS
! 2172       bufoff += count;
! Debug: addab unsigned short count = [S+$22-$10] to unsigned short bufoff = [S+$22+$14] (used reg = )
mov	ax,$16[bp]
add	ax,-$E[bp]
mov	$16[bp],ax
!BCC_EOS
! 2173       transfer += count;
! Debug: cast unsigned long = const 0 to unsigned short count = [S+$22-$10] (used reg = )
mov	ax,-$E[bp]
xor	bx,bx
! Debug: addab unsigned long = bx+0 to unsigned long transfer = [S+$22-$1E] (used reg = )
lea	di,-$1C[bp]
call	laddul
mov	-$1C[bp],ax
mov	-$1A[bp],bx
!BCC_EOS
! 2174       write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,transfer);
! Debug: list unsigned long transfer = [S+$22-$1E] (used reg = )
push	-$1A[bp]
push	-$1C[bp]
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$28-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2175     }
! 2176   }
.2B8:
br 	.2B9
.2D6:
.2B7:
add	sp,*4
! 2177   if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
.2B6:
! 2178          != 0x40 ) {
! Debug: and int = const $E9 to unsigned char status = [S+$1E-$13] (used reg = )
mov	al,-$11[bp]
and	al,#$E9
! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
je  	.2D7
.2D8:
! 2179     ;
!BCC_EOS
! 2180     return 4;
mov	ax,*4
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2181   }
! 2182   outb(iobase2+6, 0x08);
.2D7:
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2183   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2184 }
! 2185   Bit16u
! Register BX used in function ata_cmd_packet
! 2186 atapi_get_sense(device, seg, asc, ascq)
! 2187   Bit16u device;
export	_atapi_get_sense
_atapi_get_sense:
!BCC_EOS
! 2188 {
! 2189   Bit8u atacmd[12];
!BCC_EOS
! 2190   Bit8u buffer[18];
!BCC_EOS
! 2191   Bit8u i;
!BCC_EOS
! 2192   memsetb(get_SS(),atacmd,0,12);
push	bp
mov	bp,sp
add	sp,*-$20
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$26-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2193   atacmd[0]=0x03;
! Debug: eq int = const 3 to unsigned char atacmd = [S+$22-$E] (used reg = )
mov	al,*3
mov	-$C[bp],al
!BCC_EOS
! 2194   atacmd[4]=sizeof(buffer);
! Debug: eq int = const $12 to unsigned char atacmd = [S+$22-$A] (used reg = )
mov	al,*$12
mov	-8[bp],al
!BCC_EOS
! 2195   if (ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 18L, 0x01, get_SS(), buffer) != 0)
! Debug: list * unsigned char buffer = S+$22-$20 (used reg = )
lea	bx,-$1E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list long = const $12 (used reg = )
mov	ax,*$12
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$2E-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned short device = [S+$34+2] (used reg = )
push	4[bp]
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.2D9
.2DA:
! 2196     return 0x0002;
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2197   write_byte(seg,asc,buffer[12]);
.2D9:
! Debug: list unsigned char buffer = [S+$22-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
push	ax
! Debug: list int asc = [S+$24+6] (used reg = )
push	8[bp]
! Debug: list int seg = [S+$26+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2198   write_byte(seg,ascq,buffer[13]);
! Debug: list unsigned char buffer = [S+$22-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
push	ax
! Debug: list int ascq = [S+$24+8] (used reg = )
push	$A[bp]
! Debug: list int seg = [S+$26+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2199   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2200 }
! 2201   Bit16u
! Register BX used in function atapi_get_sense
! 2202 atapi_is_ready(device)
! 2203   Bit16u device;
export	_atapi_is_ready
_atapi_is_ready:
!BCC_EOS
! 2204 {
! 2205   Bit8u packet[12];
!BCC_EOS
! 2206   Bit8u buf[8];
!BCC_EOS
! 2207   Bit32u block_len;
!BCC_EOS
! 2208   Bit32u sectors;
!BCC_EOS
! 2209   Bit32u timeout;
!BCC_EOS
! 2210   Bit32u time;
!BCC_EOS
! 2211   Bit8u asc, ascq;
!BCC_EOS
! 2212   Bit8u in_progress;
!BCC_EOS
! 2213   Bit16u ebda_seg = read_wo
! 2213 rd(0x0040,0x000E);
push	bp
mov	bp,sp
add	sp,*-$2A
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
mov	-$2A[bp],ax
!BCC_EOS
! 2214   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03) {
! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
push	-$2A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
cmp	al,*3
je  	.2DB
.2DC:
! 2215     bios_printf(2, "not implemented for non-ATAPI device\n");
! Debug: list * char = .2DD+0 (used reg = )
mov	bx,#.2DD
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 2216     return -1;
mov	ax,#$FFFF
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2217   }
! 2218   ;
.2DB:
!BCC_EOS
! 2219   memsetb(get_SS(),packet, 0, sizeof packet);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char packet = S+$30-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2220   packet[0] = 0x25;
! Debug: eq int = const $25 to unsigned char packet = [S+$2C-$E] (used reg = )
mov	al,*$25
mov	-$C[bp],al
!BCC_EOS
! 2221   timeout = 5000;
! Debug: eq int = const $1388 to unsigned long timeout = [S+$2C-$22] (used reg = )
mov	ax,#$1388
xor	bx,bx
mov	-$20[bp],ax
mov	-$1E[bp],bx
!BCC_EOS
! 2222   time = 0;
! Debug: eq int = const 0 to unsigned long time = [S+$2C-$26] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$24[bp],ax
mov	-$22[bp],bx
!BCC_EOS
! 2223   in_progress = 0;
! Debug: eq int = const 0 to unsigned char in_progress = [S+$2C-$29] (used reg = )
xor	al,al
mov	-$27[bp],al
!BCC_EOS
! 2224   while (time < timeout) {
br 	.2DF
.2E0:
! 2225     if (ata_cmd_packet(device, sizeof(packet), get_SS(), packet, 0, 8L, 0x01, get_SS(), buf) == 0)
! Debug: list * unsigned char buf = S+$2C-$16 (used reg = )
lea	bx,-$14[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list long = const 8 (used reg = )
mov	ax,*8
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char packet = S+$38-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned short device = [S+$3E+2] (used reg = )
push	4[bp]
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.2E1
.2E2:
! 2226       goto ok;
add	sp,#..FFFA+$2C
br 	.FFFA
!BCC_EOS
! 2227     if (atapi_get_sense(device, get_SS(), &asc, &ascq) == 0) {
.2E1:
! Debug: list * unsigned char ascq = S+$2C-$28 (used reg = )
lea	bx,-$26[bp]
push	bx
! Debug: list * unsigned char asc = S+$2E-$27 (used reg = )
lea	bx,-$25[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list unsigned short device = [S+$32+2] (used reg = )
push	4[bp]
! Debug: func () unsigned short = atapi_get_sense+0 (used reg = )
call	_atapi_get_sense
add	sp,*8
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.2E3
.2E4:
! 2228       if (asc == 0x3a) {
! Debug: logeq int = const $3A to unsigned char asc = [S+$2C-$27] (used reg = )
mov	al,-$25[bp]
cmp	al,*$3A
jne 	.2E5
.2E6:
! 2229         ;
!BCC_EOS
! 2230         return -1;
mov	ax,#$FFFF
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2231       }
! 2232       if (asc == 0x04 && ascq == 0x01 && !in_progress) {
.2E5:
! Debug: logeq int = const 4 to unsigned char asc = [S+$2C-$27] (used reg = )
mov	al,-$25[bp]
cmp	al,*4
jne 	.2E7
.2EA:
! Debug: logeq int = const 1 to unsigned char ascq = [S+$2C-$28] (used reg = )
mov	al,-$26[bp]
cmp	al,*1
jne 	.2E7
.2E9:
mov	al,-$27[bp]
test	al,al
jne 	.2E7
.2E8:
! 2233         bios_printf(2, "Waiting for device to detect medium... ");
! Debug: list * char = .2EB+0 (used reg = )
mov	bx,#.2EB
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 2234         timeout = 30000;
! Debug: eq int = const $7530 to unsigned long timeout = [S+$2C-$22] (used reg = )
mov	ax,#$7530
xor	bx,bx
mov	-$20[bp],ax
mov	-$1E[bp],bx
!BCC_EOS
! 2235         in_progress = 1;
! Debug: eq int = const 1 to unsigned char in_progress = [S+$2C-$29] (used reg = )
mov	al,*1
mov	-$27[bp],al
!BCC_EOS
! 2236       }
! 2237     }
.2E7:
! 2238     time += 100;
.2E3:
! Debug: addab unsigned long = const $64 to unsigned long time = [S+$2C-$26] (used reg = )
mov	ax,*$64
xor	bx,bx
push	bx
push	ax
mov	ax,-$24[bp]
mov	bx,-$22[bp]
lea	di,-$2E[bp]
call	laddul
mov	-$24[bp],ax
mov	-$22[bp],bx
add	sp,*4
!BCC_EOS
! 2239   }
! 2240   ;
.2DF:
! Debug: lt unsigned long timeout = [S+$2C-$22] to unsigned long time = [S+$2C-$26] (used reg = )
mov	ax,-$20[bp]
mov	bx,-$1E[bp]
lea	di,-$24[bp]
call	lcmpul
bhi 	.2E0
.2EC:
.2DE:
!BCC_EOS
! 2241   return -1;
mov	ax,#$FFFF
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2242 ok:
.FFFA:
..FFFA	=	-$2C
! 2243   block_len = (Bit32u) buf[4] << 24
! 2244     | (Bit32u) buf[5] << 16
! 2245     | (Bit32u) buf[6] << 8
! 2246     | (Bit32u) buf[7] << 0;
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
mov	bh,bl
mov	bl,ah
mov	ah,al
xor	al,al
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$12] (used reg = )
mov	al,-$10[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
mov	ah,al
xor	al,al
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
lea	di,-$36[bp]
call	lorul
add	sp,*4
! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
lea	di,-$32[bp]
call	lorul
add	sp,*4
! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
lea	di,-$2E[bp]
call	lorul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long block_len = [S+$2C-$1A] (used reg = )
mov	-$18[bp],ax
mov	-$16[bp],bx
!BCC_EOS
! 2247   ;
!BCC_EOS
! 2248   if (block_len!= 2048 && block_len!= 512)
! Debug: ne unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
mov	ax,-$18[bp]
mov	bx,-$16[bp]
lea	di,-$2E[bp]
call	lcmpul
lea	sp,-$2A[bp]
je  	.2ED
.2EF:
! Debug: ne unsigned long = const $200 to unsigned long block_len = [S+$2C-$1A] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$200
xor	bx,bx
push	bx
push	ax
mov	ax,-$18[bp]
mov	bx,-$16[bp]
lea	di,-$2E[bp]
call	lcmpul
lea	sp,-$2A[bp]
je  	.2ED
.2EE:
! 2249   {
! 2250     bios_printf(2, "Unsupported sector size %u\n", block_len);
! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
push	-$16[bp]
push	-$18[bp]
! Debug: list * char = .2F0+0 (used reg = )
mov	bx,#.2F0
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 2251     return -1;
mov	ax,#$FFFF
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2252   }
! 2253   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, block_len);
.2ED:
! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
push	-$16[bp]
push	-$18[bp]
! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
push	-$2A[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2254   sectors = (Bit32u) buf[0] << 24
! 2255     | (Bit32u) buf[1] << 16
! 2256     | (Bit32u) buf[2] << 8
! 2257     | (Bit32u) buf[3] << 0;
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
mov	bh,bl
mov	bl,ah
mov	ah,al
xor	al,al
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$15] (used reg = )
mov	al,-$13[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$16] (used reg = )
mov	al,-$14[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
mov	ah,al
xor	al,al
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
lea	di,-$36[bp]
call	lorul
add	sp,*4
! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
lea	di,-$32[bp]
call	lorul
add	sp,*4
! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
lea	di,-$2E[bp]
call	lorul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
mov	-$1C[bp],ax
mov	-$1A[bp],bx
!BCC_EOS
! 2258   ;
!BCC_EOS
! 2259   if (block_len == 2048)
! Debug: logeq unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
mov	ax,-$18[bp]
mov	bx,-$16[bp]
lea	di,-$2E[bp]
call	lcmpul
lea	sp,-$2A[bp]
jne 	.2F1
.2F2:
! 2260     sectors <<= 2;
! Debug: slab int = const 2 to unsigned long sectors = [S+$2C-$1E] (used reg = )
mov	ax,-$1C[bp]
mov	bx,-$1A[bp]
mov	di,*2
call	lslul
mov	-$1C[bp],ax
mov	-$1A[bp],bx
!BCC_EOS
! 2261   if (sectors != read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low))
.2F1:
! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
push	-$2A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: ne unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
! Debug: expression subtree swapping
lea	di,-$1C[bp]
call	lcmpul
je  	.2F3
.2F4:
! 2262     bios_printf(2, "%dMB medium detected\n", sectors>>(20-9));
! Debug: sr int = const $B to unsigned long sectors = [S+$2C-$1E] (used reg = )
mov	ax,-$1C[bp]
mov	bx,-$1A[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*3
call	lsrul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list * char = .2F5+0 (used reg = )
mov	bx,#.2F5
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 2263   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors);
.2F3:
! Debug: list unsigned long sectors = [S+$2C-$1E] (used reg = )
push	-$1A[bp]
push	-$1C[bp]
! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
push	-$2A[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2264   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2265 }
! 2266   Bit16u
! Register BX used in function atapi_is_ready
! 2267 atapi_is_cdrom(device)
! 2268   Bit8u device;
export	_atapi_is_cdrom
_atapi_is_cdrom:
!BCC_EOS
! 2269 {
! 2270   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2271   if (device >= (4*2))
! Debug: ge int = const 8 to unsigned char device = [S+4+2] (used reg = )
mov	al,4[bp]
cmp	al,*8
jb  	.2F6
.2F7:
! 2272     return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2273   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03)
.2F6:
! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
mov	al,4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
cmp	al,*3
je  	.2F8
.2F9:
! 2274     return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2275   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device) != 0x05)
.2F8:
! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
mov	al,4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 5 to unsigned char = al+0 (used reg = )
cmp	al,*5
je  	.2FA
.2FB:
! 2276     return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2277   return 1;
.2FA:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2278 }
! 2279   void
! Register BX used in function atapi_is_cdrom
! 2280 cdemu_init()
! 2281 {
export	_cdemu_init
_cdemu_init:
! 2282   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2283   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2284 }
mov	sp,bp
pop	bp
ret
! 2285   Bit8u
! 2286 cdemu_isa
! 2286 ctive()
! 2287 {
export	_cdemu_isactive
_cdemu_isactive:
! 2288   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2289   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active));
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2290 }
! 2291   Bit8u
! 2292 cdemu_emulated_drive()
! 2293 {
export	_cdemu_emulated_drive
_cdemu_emulated_drive:
! 2294   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2295   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2296 }
! 2297 static char isotag[6]="CD001";
.data
_isotag:
.2FC:
.ascii	"CD001"
.byte	0
!BCC_EOS
! 2298 static char eltorito[24]="EL TORITO SPECIFICATION";
_eltorito:
.2FD:
.ascii	"EL TORITO SPECIFICATION"
.byte	0
!BCC_EOS
! 2299   Bit16u
! 2300 cdrom_boot()
! 2301 {
.text
export	_cdrom_boot
_cdrom_boot:
! 2302   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2303   Bit8u atacmd[12], buffer[2048];
!BCC_EOS
! 2304   Bit32u lba;
!BCC_EOS
! 2305   Bit16u boot_segment, nbsectors, i, error;
!BCC_EOS
! 2306   Bit8u device;
!BCC_EOS
! 2307   for (device=0; device<(4*2);device++) {
add	sp,#-$81A
! Debug: eq int = const 0 to unsigned char device = [S+$81E-$81D] (used reg = )
xor	al,al
mov	-$81B[bp],al
!BCC_EOS
!BCC_EOS
jmp .300
.301:
! 2308     if (atapi_is_cdrom(device)) break;
! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = atapi_is_cdrom+0 (used reg = )
call	_atapi_is_cdrom
inc	sp
inc	sp
test	ax,ax
je  	.302
.303:
jmp .2FE
!BCC_EOS
! 2309   }
.302:
! 2310   if(device >= (4*2)) return 2;
.2FF:
! Debug: postinc unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
inc	ax
mov	-$81B[bp],al
.300:
! Debug: lt int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
cmp	al,*8
jb 	.301
.304:
.2FE:
! Debug: ge int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
cmp	al,*8
jb  	.305
.306:
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2311   if(error = atapi_is_ready(device) != 0)
.305:
! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = atapi_is_ready+0 (used reg = )
call	_atapi_is_ready
inc	sp
inc	sp
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je 	.309
mov	al,*1
jmp	.30A
.309:
xor	al,al
.30A:
! Debug: eq char = al+0 to unsigned short error = [S+$81E-$81C] (used reg = )
xor	ah,ah
mov	-$81A[bp],ax
test	ax,ax
je  	.307
.308:
! 2312     bios_printf(4, "ata_is_ready returned %d\n",error);
! Debug: list unsigned short error = [S+$81E-$81C] (used reg = )
push	-$81A[bp]
! Debug: list * char = .30B+0 (used reg = )
mov	bx,#.30B
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2313   memsetb(get_SS(),atacmd,0,12);
.307:
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2314   atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
mov	al,*$28
mov	-$E[bp],al
!BCC_EOS
! 2315   atacmd[7]=(0x01 & 0xff00) >> 8;
! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
xor	al,al
mov	-7[bp],al
!BCC_EOS
! 2316   atacmd[8]=(0x01 & 0x00ff);
! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
mov	al,*1
mov	-6[bp],al
!BCC_EOS
! 2317   atacmd[2]=(0x11 & 0xff000000) >> 24;
! Debug: eq unsigned long = const 0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
xor	al,al
mov	-$C[bp],al
!BCC_EOS
! 2318   atacmd[3]=(0x11 & 0x00ff0000) >> 16;
! Debug: eq long = const 0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
xor	al,al
mov	-$B[bp],al
!BCC_EOS
! 2319   atacmd[4]=(0x11 & 0x0000ff00) >> 8;
! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
xor	al,al
mov	-$A[bp],al
!BCC_EOS
! 2320   atacmd[5]=(0x11 & 0x000000ff);
! Debug: eq int = const $11 to unsigned char atacmd = [S+$81E-$B] (used reg = )
mov	al,*$11
mov	-9[bp],al
!BCC_EOS
! 2321   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
lea	bx,-$80E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list long = const $800 (used reg = )
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
mov	-$81A[bp],ax
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.30C
.30D:
! 2322     return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2323   if(buffer[0]!=0) return 4;
.30C:
! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$810] (used reg = )
mov	al,-$80E[bp]
test	al,al
je  	.30E
.30F:
mov	ax,*4
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2324   for(i=0;i<5;i++){
.30E:
! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
xor	ax,ax
mov	-$818[bp],ax
!BCC_EOS
!BCC_EOS
jmp .312
.313:
! 2325     if(buffer[1+i]!=read_byte(0xf000,&isotag[i])) return 5;
! Debug: ptradd unsigned short i = [S+$81E-$81A] to [6] char = isotag+0 (used reg = )
mov	bx,-$818[bp]
! Debug: address char = [bx+_isotag+0] (used reg = )
! Debug: list * char = bx+_isotag+0 (used reg = )
add	bx,#_isotag
push	bx
! Debug: list unsigned int = const $F000 (used reg = )
mov	ax,#$F000
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: add unsigned short i = [S+$820-$81A] to int = const 1 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$818[bp]
! Debug: ptradd unsigned int = ax+1 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
inc	ax
mov	bx,bp
add	bx,ax
! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = [bx-$80E] (used reg = )
mov	al,-$80E[bx]
cmp	al,-$81E[bp]
lea	sp,-$81C[bp]
je  	.314
.315:
mov	ax,*5
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2326   }
.314:
! 2327   for(i=0;i<23;i++)
.311:
! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
mov	ax,-$818[bp]
inc	ax
mov	-$818[bp],ax
.312:
! Debug: lt int = const 5 to unsigned short i = [S+$81E-$81A] (used reg = )
mov	ax,-$818[bp]
cmp	ax,*5
jb 	.313
.316:
.310:
! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
xor	ax,ax
mov	-$818[bp],ax
!BCC_EOS
!BCC_EOS
! 2328     if(buffer[7+i]!=read_byte(0xf000,&eltorito[i])) return 6;
jmp .319
.31A:
! Debug: ptradd unsigned short i = [S+$81E-$81A] to [$18] char = eltorito+0 (used reg = )
mov	bx,-$818[bp]
! Debug: address char = [bx+_eltorito+0] (used reg = )
! Debug: list * char = bx+_eltorito+0 (used reg = )
add	bx,#_eltorito
push	bx
! Debug: list unsigned int = const $F000 (used reg = )
mov	ax,#$F000
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: add unsigned short i = [S+$820-$81A] to int = const 7 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$818[bp]
! Debug: ptradd unsigned int = ax+7 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
add	ax,*7
mov	bx,bp
add	bx,ax
! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = [bx-$80E] (used reg = )
mov	al,-$80E[bx]
cmp	al,-$81E[bp]
lea	sp,-$81C[bp]
je  	.31B
.31C:
mov	ax,*6
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2329   lba=buffer[0x4A]*0x1000000+buffer[0x49]*0x10000+buffer[0x48]*0x100+buffer[0x47];
.31B:
.318:
! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
mov	ax,-$818[bp]
inc	ax
mov	-$818[bp],ax
.319:
! Debug: lt int = const $17 to unsigned short i = [S+$81E-$81A] (used reg = )
mov	ax,-$818[bp]
cmp	ax,*$17
jb 	.31A
.31D:
.317:
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7C9] (used reg = )
mov	al,-$7C7[bp]
xor	ah,ah
xor	bx,bx
push	bx
push	ax
! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7C8] (used reg = )
mov	al,-$7C6[bp]
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7C7] (used reg = )
mov	al,-$7C5[bp]
xor	ah,ah
xor	bx,bx
! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,*1
push	bx
push	ax
mov	ax,-$828[bp]
mov	bx,-$826[bp]
lea	di,-$82C[bp]
call	lmulul
add	sp,*8
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7C6] (used reg = )
mov	al,-$7C4[bp]
xor	ah,ah
xor	bx,bx
! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$100
push	bx
push	ax
mov	ax,-$82C[bp]
mov	bx,-$82A[bp]
lea	di,-$830[bp]
call	lmulul
add	sp,*8
! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
lea	di,-$828[bp]
call	laddul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
lea	di,-$824[bp]
call	laddul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
lea	di,-$820[bp]
call	laddul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
mov	-$812[bp],ax
mov	-$810[bp],bx
!BCC_EOS
! 2330   memsetb(get_SS(),atacmd,0,12);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2331   atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
mov	al,*$28
mov	-$E[bp],al
!BCC_EOS
! 2332   atacmd[7]=(0x01 & 0xff00) >> 8;
! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
xor	al,al
mov	-7[bp],al
!BCC_EOS
! 2333   atacmd[8]=(0x01 & 0x00ff);
! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
mov	al,*1
mov	-6[bp],al
!BCC_EOS
! 2334   atacmd[2]=(lba & 0xff000000) >> 24;
! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF00
lea	di,-$812[bp]
call	landul
! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
mov	-$C[bp],al
!BCC_EOS
! 2335   atacmd[3]=(lba & 0x00ff0000) >> 16;
! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF
lea	di,-$812[bp]
call	landul
! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2336   atacmd[4]=(lba & 0x0000ff00) >> 8;
! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF00
xor	bx,bx
lea	di,-$812[bp]
call	landul
! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 2337   atacmd[5]=(lba & 0x000000ff);
! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,-$812[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2338   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
lea	bx,-$80E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list long = const $800 (used reg = )
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
mov	-$81A[bp],ax
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.31E
.31F:
! 2339     return 7;
mov	ax,*7
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2340   if(buffer[0x00]!=0x01)return 8;
.31E:
! Debug: ne int = const 1 to unsigned char buffer = [S+$81E-$810] (used reg = )
mov	al,-$80E[bp]
cmp	al,*1
je  	.320
.321:
mov	ax,*8
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2341   if(buffer[0x01]!=0x00)return 9;
.320:
! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$80F] (used reg = )
mov	al,-$80D[bp]
test	al,al
je  	.322
.323:
mov	ax,*9
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2342   if(buffer[0x1E]!=0x55)return 10;
.322:
! Debug: ne int = const $55 to unsigned char buffer = [S+$81E-$7F2] (used reg = )
mov	al,-$7F0[bp]
cmp	al,*$55
je  	.324
.325:
mov	ax,*$A
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2343   if(buffer[0x1F]!=0xAA)return 10;
.324:
! Debug: ne int = const $AA to unsigned char buffer = [S+$81E-$7F1] (used reg = )
mov	al,-$7EF[bp]
cmp	al,#$AA
je  	.326
.327:
mov	ax,*$A
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2344   if(buffer[0x20]!=0x88)return 11;
.326:
! Debug: ne int = const $88 to unsigned char buffer = [S+$81E-$7F0] (used reg = )
mov	al,-$7EE[bp]
cmp	al,#$88
je  	.328
.329:
mov	ax,*$B
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2345   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media,buffer[0x21]);
.328:
! Debug: list unsigned char buffer = [S+$81E-$7EF] (used reg = )
mov	al,-$7ED[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2346   if(buffer[0x21]==0){
! Debug: logeq int = const 0 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
mov	al,-$7ED[bp]
test	al,al
jne 	.32A
.32B:
! 2347     
! 2347 write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0xE0);
! Debug: list int = const $E0 (used reg = )
mov	ax,#$E0
push	ax
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2348   }
! 2349   else if(buffer[0x21]<4)
jmp .32C
.32A:
! Debug: lt int = const 4 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
mov	al,-$7ED[bp]
cmp	al,*4
jae 	.32D
.32E:
! 2350     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2351   else
! 2352     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x80);
jmp .32F
.32D:
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2353   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index,device/2);
.32F:
.32C:
! Debug: div int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
shr	ax,*1
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * unsigned char = const $25D (used reg = )
mov	ax,#$25D
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2354   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec,device%2);
! Debug: mod int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
and	al,*1
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list * unsigned short = const $25E (used reg = )
mov	ax,#$25E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2355   boot_segment=buffer[0x23]*0x100+buffer[0x22];
! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7ED] (used reg = )
mov	al,-$7EB[bp]
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: add unsigned char buffer = [S+$81E-$7EE] to unsigned int = ax+0 (used reg = )
add	al,-$7EC[bp]
adc	ah,*0
! Debug: eq unsigned int = ax+0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
mov	-$814[bp],ax
!BCC_EOS
! 2356   if(boot_segment==0x0000)boot_segment=0x07C0;
! Debug: logeq int = const 0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
mov	ax,-$814[bp]
test	ax,ax
jne 	.330
.331:
! Debug: eq int = const $7C0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
mov	ax,#$7C0
mov	-$814[bp],ax
!BCC_EOS
! 2357   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment,boot_segment);
.330:
! Debug: list unsigned short boot_segment = [S+$81E-$816] (used reg = )
push	-$814[bp]
! Debug: list * unsigned short = const $266 (used reg = )
mov	ax,#$266
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2358   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment,0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $264 (used reg = )
mov	ax,#$264
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2359   nbsectors=buffer[0x27]*0x100+buffer[0x26];
! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7E9] (used reg = )
mov	al,-$7E7[bp]
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: add unsigned char buffer = [S+$81E-$7EA] to unsigned int = ax+0 (used reg = )
add	al,-$7E8[bp]
adc	ah,*0
! Debug: eq unsigned int = ax+0 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
mov	-$816[bp],ax
!BCC_EOS
! 2360   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count,nbsectors);
! Debug: list unsigned short nbsectors = [S+$81E-$818] (used reg = )
push	-$816[bp]
! Debug: list * unsigned short = const $268 (used reg = )
mov	ax,#$268
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2361   lba=buffer[0x2B]*0x1000000+buffer[0x2A]*0x10000+buffer[0x29]*0x100+buffer[0x28];
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7E8] (used reg = )
mov	al,-$7E6[bp]
xor	ah,ah
xor	bx,bx
push	bx
push	ax
! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7E7] (used reg = )
mov	al,-$7E5[bp]
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7E6] (used reg = )
mov	al,-$7E4[bp]
xor	ah,ah
xor	bx,bx
! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,*1
push	bx
push	ax
mov	ax,-$828[bp]
mov	bx,-$826[bp]
lea	di,-$82C[bp]
call	lmulul
add	sp,*8
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7E5] (used reg = )
mov	al,-$7E3[bp]
xor	ah,ah
xor	bx,bx
! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$100
push	bx
push	ax
mov	ax,-$82C[bp]
mov	bx,-$82A[bp]
lea	di,-$830[bp]
call	lmulul
add	sp,*8
! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
lea	di,-$828[bp]
call	laddul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
lea	di,-$824[bp]
call	laddul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
lea	di,-$820[bp]
call	laddul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
mov	-$812[bp],ax
mov	-$810[bp],bx
!BCC_EOS
! 2362   write_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba,lba);
! Debug: list unsigned long lba = [S+$81E-$814] (used reg = )
push	-$810[bp]
push	-$812[bp]
! Debug: list * unsigned long = const $260 (used reg = )
mov	ax,#$260
push	ax
! Debug: list unsigned short ebda_seg = [S+$824-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2363   memsetb(get_SS(),atacmd,0,12);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2364   atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
mov	al,*$28
mov	-$E[bp],al
!BCC_EOS
! 2365   atacmd[7]=((1+(nbsectors-1)/4) & 0xff00) >> 8;
! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
mov	ax,-$816[bp]
! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
dec	ax
shr	ax,*1
shr	ax,*1
! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
! Debug: expression subtree swapping
! Debug: and unsigned int = const $FF00 to unsigned int = ax+1 (used reg = )
inc	ax
xor	al,al
! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$81E-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 2366   atacmd[8]=((1+(nbsectors-1)/4) & 0x00ff);
! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
mov	ax,-$816[bp]
! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
dec	ax
shr	ax,*1
shr	ax,*1
! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
! Debug: expression subtree swapping
! Debug: and int = const $FF to unsigned int = ax+1 (used reg = )
inc	ax
! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$81E-8] (used reg = )
mov	-6[bp],al
!BCC_EOS
! 2367   atacmd[2]=(lba & 0xff000000) >> 24;
! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF00
lea	di,-$812[bp]
call	landul
! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
mov	-$C[bp],al
!BCC_EOS
! 2368   atacmd[3]=(lba & 0x00ff0000) >> 16;
! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF
lea	di,-$812[bp]
call	landul
! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2369   atacmd[4]=(lba & 0x0000ff00) >> 8;
! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF00
xor	bx,bx
lea	di,-$812[bp]
call	landul
! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 2370   atacmd[5]=(lba & 0x000000ff);
! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,-$812[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2371   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, nbsectors*512L, 0x01, boot_segment,0)) != 0)
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
push	-$814[bp]
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$824-$818] (used reg = )
mov	ax,-$816[bp]
xor	bx,bx
! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$200
xor	bx,bx
push	bx
push	ax
mov	ax,-$826[bp]
mov	bx,-$824[bp]
lea	di,-$82A[bp]
call	lmulul
add	sp,*8
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
mov	-$81A[bp],ax
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.332
.333:
! 2372     return 12;
mov	ax,*$C
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2373   switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
.332:
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
br 	.336
! 2374     case 0x01:
! 2375       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,15);
.337:
! Debug: list int = const $F (used reg = )
mov	ax,*$F
push	ax
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2376       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
! Debug: list int = const $50 (used reg = )
mov	ax,*$50
push	ax
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2377       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2378       break;
br 	.334
!BCC_EOS
! 2379     case 0x02:
! 2380       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,18);
.338:
! Debug: list int = const $12 (used reg = )
mov	ax,*$12
push	ax
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2381       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
! Debug: list int = const $50 (used reg = )
mov	ax,*$50
push	ax
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2382       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2383       break;
br 	.334
!BCC_EOS
! 2384     case 0x03:
! 2385       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,36);
.339:
! Debug: list int = const $24 (used reg = )
mov	ax,*$24
push	ax
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2386       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders
! 2386 ,80);
! Debug: list int = const $50 (used reg = )
mov	ax,*$50
push	ax
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2387       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2388       break;
br 	.334
!BCC_EOS
! 2389     case 0x04:
! 2390       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,read_byte(boot_segment,446+6)&0x3f);
.33A:
! Debug: list int = const $1C4 (used reg = )
mov	ax,#$1C4
push	ax
! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
push	-$814[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
and	al,*$3F
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2391       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,
! 2392               (read_byte(boot_segment,446+6)<<2) + read_byte(boot_segment,446+7) + 1);
! Debug: list int = const $1C5 (used reg = )
mov	ax,#$1C5
push	ax
! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
push	-$814[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: list int = const $1C4 (used reg = )
mov	ax,#$1C4
push	ax
! Debug: list unsigned short boot_segment = [S+$822-$816] (used reg = )
push	-$814[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: add unsigned char (temp) = [S+$820-$820] to unsigned int = ax+0 (used reg = )
add	al,0+..FFF9[bp]
adc	ah,*0
inc	sp
inc	sp
! Debug: add int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2393       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,read_byte(boot_segment,446+5) + 1);
! Debug: list int = const $1C3 (used reg = )
mov	ax,#$1C3
push	ax
! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
push	-$814[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2394       break;
jmp .334
!BCC_EOS
! 2395    }
! 2396   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0) {
jmp .334
.336:
sub	al,*1
beq 	.337
sub	al,*1
beq 	.338
sub	al,*1
beq 	.339
sub	al,*1
beq 	.33A
.334:
..FFF9	=	-$81E
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.33B
.33C:
! 2397     if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)==0x00)
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.33D
.33E:
! 2398       write_byte(0x40,0x10,read_byte(0x40,0x10)|0x41);
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: or int = const $41 to unsigned char = al+0 (used reg = )
or	al,*$41
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2399     else
! 2400       write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount, read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount) + 1);
jmp .33F
.33D:
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2401   }
.33F:
! 2402   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0)
.33B:
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.340
.341:
! 2403     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x01);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2404   return (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)*0x100)+0;
.340:
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: mul int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: add int = const 0 to unsigned int = ax+0 (used reg = )
! Debug: cast unsigned short = const 0 to unsigned int = ax+0 (used reg = )
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2405 }
! 2406 void int14_function(regs, ds, iret_addr)
! Register BX used in function cdrom_boot
! 2407   pusha_regs_t regs;
export	_int14_function
_int14_function:
!BCC_EOS
! 2408   Bit16u ds;
!BCC_EOS
! 2409   iret_addr_t iret_addr;
!BCC_EOS
! 2410 {
! 2411   Bit16u addr,timer,val16;
!BCC_EOS
! 2412   Bit8u counter;
!BCC_EOS
! 2413 #asm
push	bp
mov	bp,sp
add	sp,*-8
!BCC_EOS
!BCC_ASM
_int14_function.ds	set	$1C
.int14_function.ds	set	$14
_int14_function.counter	set	1
.int14_function.counter	set	-7
_int14_function.timer	set	4
.int14_function.timer	set	-4
_int14_function.iret_addr	set	$1E
.int14_function.iret_addr	set	$16
_int14_function.addr	set	6
.int14_function.addr	set	-2
_int14_function.val16	set	2
.int14_function.val16	set	-6
_int14_function.regs	set	$C
.int14_function.regs	set	4
  sti
! 2415 endasm
!BCC_ENDASM
!BCC_EOS
! 2416   addr = read_word(0x0040, (regs.u.r16.dx << 1));
! Debug: sl int = const 1 to unsigned short regs = [S+$A+$C] (used reg = )
mov	ax,$E[bp]
shl	ax,*1
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+$A-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2417   counter = read_byte(0x0040, 0x007C + regs.u.r16.dx);
! Debug: add unsigned short regs = [S+$A+$C] to int = const $7C (used reg = )
! Debug: expression subtree swapping
mov	ax,$E[bp]
! Debug: list unsigned int = ax+$7C (used reg = )
add	ax,*$7C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char counter = [S+$A-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 2418   if ((regs.u.r16.dx < 4) && (addr > 0)) {
! Debug: lt int = const 4 to unsigned short regs = [S+$A+$C] (used reg = )
mov	ax,$E[bp]
cmp	ax,*4
bhis	.342
.344:
! Debug: gt int = const 0 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
beq 	.342
.343:
! 2419     switch (regs.u.r8.ah) {
mov	al,$13[bp]
br 	.347
! 2420       case 0:
! 2421         outb(addr+3, inb(addr+3) | 0x80);
.348:
! Debug: add int = const 3 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
or	al,#$80
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2422         if (regs.u.r8.al & 0xE0 == 0) {
! Debug: and int = const 0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	al,$12[bp]
xor	al,al
test	al,al
je  	.349
.34A:
! 2423           outb(addr, 0x17);
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list unsigned short addr = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2424           outb(addr+1, 0x04);
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2425         } else {
jmp .34B
.349:
! 2426           val16 = 0x600 >> ((regs.u.r8.al & 0xE0) >> 5);
! Debug: and int = const $E0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	al,$12[bp]
and	al,#$E0
! Debug: sr int = const 5 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cl,*5
shr	ax,cl
! Debug: sr unsigned int = ax+0 to int = const $600 (used reg = )
mov	bx,ax
mov	ax,#$600
mov	cx,bx
sar	ax,cl
! Debug: eq int = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2427           outb(addr, val16 & 0xFF);
! Debug: and int = const $FF to unsigned short val16 = [S+$A-8] (used reg = )
mov	al,-6[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list unsigned short addr = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2428           outb(addr+1, val16 >> 8);
! Debug: sr int = const 8 to unsigned short val16 = [S+$A-8] (used reg = )
mov	ax,-6[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2429         }
! 2430         outb(addr+3, regs.u.r8.al & 0x1F);
.34B:
! Debug: and int = const $1F to unsigned char regs = [S+$A+$10] (used reg = )
mov	al,$12[bp]
and	al,*$1F
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2431         regs.u.r8.ah = inb(addr+5);
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2432         regs.u.r8.al = inb(addr+6);
! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2433         iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 2434         break;
br 	.345
!BCC_EOS
! 2435       case 1:
! 2436         timer = read_word(0x0040, 0x006C);
.34C:
! Debug: list int = const $6C (used reg = )
mov	ax,*$6C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 2437         while (((inb(addr+5) & 0x60) != 0x60) && (counter)) {
jmp .34E
.34F:
! 2438           val16 = read_word(0x0040, 0x006C);
! Debug: list int = const $6C (used reg = )
mov	ax,*$6C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2439           if (val16 
! 2439 != timer) {
! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
mov	ax,-6[bp]
cmp	ax,-4[bp]
je  	.350
.351:
! 2440             timer = val16;
! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
mov	ax,-6[bp]
mov	-4[bp],ax
!BCC_EOS
! 2441             counter--;
! Debug: postdec unsigned char counter = [S+$A-9] (used reg = )
mov	al,-7[bp]
dec	ax
mov	-7[bp],al
!BCC_EOS
! 2442           }
! 2443         }
.350:
! 2444         if (counter > 0) {
.34E:
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
and	al,*$60
! Debug: ne int = const $60 to unsigned char = al+0 (used reg = )
cmp	al,*$60
je  	.352
.353:
mov	al,-7[bp]
test	al,al
jne	.34F
.352:
.34D:
! Debug: gt int = const 0 to unsigned char counter = [S+$A-9] (used reg = )
mov	al,-7[bp]
test	al,al
je  	.354
.355:
! 2445           outb(addr, regs.u.r8.al);
! Debug: list unsigned char regs = [S+$A+$10] (used reg = )
mov	al,$12[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short addr = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2446           regs.u.r8.ah = inb(addr+5);
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2447         } else {
jmp .356
.354:
! 2448           regs.u.r8.ah = 0x80;
! Debug: eq int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
mov	al,#$80
mov	$13[bp],al
!BCC_EOS
! 2449         }
! 2450         iret_addr.flags.u.r8.flagsl &= 0xfe;
.356:
! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 2451         break;
br 	.345
!BCC_EOS
! 2452       case 2:
! 2453         timer = read_word(0x0040, 0x006C);
.357:
! Debug: list int = const $6C (used reg = )
mov	ax,*$6C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 2454         while (((inb(addr+5) & 0x01) == 0) && (counter)) {
jmp .359
.35A:
! 2455           val16 = read_word(0x0040, 0x006C);
! Debug: list int = const $6C (used reg = )
mov	ax,*$6C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2456           if (val16 != timer) {
! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
mov	ax,-6[bp]
cmp	ax,-4[bp]
je  	.35B
.35C:
! 2457             timer = val16;
! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
mov	ax,-6[bp]
mov	-4[bp],ax
!BCC_EOS
! 2458             counter--;
! Debug: postdec unsigned char counter = [S+$A-9] (used reg = )
mov	al,-7[bp]
dec	ax
mov	-7[bp],al
!BCC_EOS
! 2459           }
! 2460         }
.35B:
! 2461         if (counter > 0) {
.359:
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.35D
.35E:
mov	al,-7[bp]
test	al,al
jne	.35A
.35D:
.358:
! Debug: gt int = const 0 to unsigned char counter = [S+$A-9] (used reg = )
mov	al,-7[bp]
test	al,al
je  	.35F
.360:
! 2462           regs.u.r8.ah = inb(addr+5);
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2463           regs.u.r8.al = inb(addr);
! Debug: list unsigned short addr = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2464         } else {
jmp .361
.35F:
! 2465           regs.u.r8.ah = 0x80;
! Debug: eq int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
mov	al,#$80
mov	$13[bp],al
!BCC_EOS
! 2466         }
! 2467         iret_addr.flags.u.r8.flagsl &= 0xfe;
.361:
! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 2468         break;
jmp .345
!BCC_EOS
! 2469       case 3:
! 2470         regs.u.r8.ah = inb(addr+5);
.362:
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2471         regs.u.r8.al = inb(addr+6);
! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2472         iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 2473         break;
jmp .345
!BCC_EOS
! 2474       default:
! 2475         iret_addr.flags.u.r8.flagsl |= 0x01;
.363:
! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 2476       }
! 2477   } else {
jmp .345
.347:
sub	al,*0
beq 	.348
sub	al,*1
beq 	.34C
sub	al,*1
beq 	.357
sub	al,*1
je 	.362
jmp	.363
.345:
..FFF8	=	-$A
jmp .364
.342:
! 2478     iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 2479   }
! 2480 }
.364:
mov	sp,bp
pop	bp
ret
! 2481   void
! Register BX used in function int14_function
! 2482 int15_function(regs, ES, DS, FLAGS)
! 2483   pusha_regs_t regs;
export	_int15_function
_int15_function:
!BCC_EOS
! 2484   Bit16u ES, DS, FLAGS;
!BCC_EOS
! 2485 {
! 2486   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2487   bx_bool prev_a20_enable;
!BCC_EOS
! 2488   Bit16u base15_00;
!BCC_EOS
! 2489   Bit8u base23_16;
!BCC_EOS
! 2490   Bit16u ss;
!BCC_EOS
! 2491   Bit16u BX,CX,DX;
!BCC_EOS
! 2492   Bit16u bRegister;
!BCC_EOS
! 2493   Bit8u irqDisable;
!BCC_EOS
! 2494 ;
add	sp,*-$12
!BCC_EOS
! 2495   switch (regs.u.r8.ah) {
mov	al,$13[bp]
br 	.367
! 2496     case 0x24:
! 2497       switch (regs.u.r8.al) {
.368:
mov	al,$12[bp]
br 	.36B
! 2498         case 0x00:
! 2499           set_enable_a20(0);
.36C:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
!BCC_EOS
! 2500           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2501           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2502           break;
br 	.369
!BCC_EOS
! 2503         case 0x01:
! 2504           set_enable_a20(1);
.36D:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
!BCC_EOS
! 2505           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2506           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2507           break;
jmp .369
!BCC_EOS
! 2508         case 0x02:
! 2509           regs.u.r8.al = (inb(0x92) >> 1) & 0x01;
.36E:
! Debug: list int = const $92 (used reg = )
mov	ax,#$92
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: sr int = const 1 to unsigned char = al+0 (used reg = )
xor	ah,ah
shr	ax,*1
! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2510           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2511           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2512           break;
jmp .369
!BCC_EOS
! 2513         case 0x03:
! 2514           FLAGS &= 0xfffe;
.36F:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2515           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2516           regs.u.r16.bx = 3;
! Debug: eq int = const 3 to unsigned short regs = [S+$16+$A] (used reg = )
mov	ax,*3
mov	$C[bp],ax
!BCC_EOS
! 2517           break;
jmp .369
!BCC_EOS
! 2518         default:
! 2519           bios_printf(4, "int15: Func 24h, subfunc %02xh, A20 gate control not supported\n", (unsigned) regs.u.r8.al);
.370:
! Debug: list unsigned char regs = [S+$16+$10] (used reg = )
mov	al,$12[bp]
xor	ah,ah
push	ax
! Debug: list * char = .371+0 (used reg = )
mov	bx,#.371
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2520        
! 2520    FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2521           regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2522       }
! 2523       break;
jmp .369
.36B:
sub	al,*0
beq 	.36C
sub	al,*1
beq 	.36D
sub	al,*1
je 	.36E
sub	al,*1
je 	.36F
jmp	.370
.369:
br 	.365
!BCC_EOS
! 2524     case 0x41:
! 2525       FLAGS |= 0x0001;
.372:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2526       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2527       break;
br 	.365
!BCC_EOS
! 2528     case 0x4f:
! 2529       FLAGS |= 0x0001;
.373:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2530       break;
br 	.365
!BCC_EOS
! 2531     case 0x52:
! 2532       FLAGS &= 0xfffe;
.374:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2533       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2534       break;
br 	.365
!BCC_EOS
! 2535     case 0x83: {
.375:
! 2536       if( regs.u.r8.al == 0 ) {
! Debug: logeq int = const 0 to unsigned char regs = [S+$16+$10] (used reg = )
mov	al,$12[bp]
test	al,al
bne 	.376
.377:
! 2537         if( ( read_byte( 0x40, 0xA0 ) & 1 ) == 0 ) {
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
bne 	.378
.379:
! 2538           write_byte( 0x40, 0xA0, 1 );
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2539           write_word( 0x40, 0x98, ES );
! Debug: list unsigned short ES = [S+$16+$12] (used reg = )
push	$14[bp]
! Debug: list int = const $98 (used reg = )
mov	ax,#$98
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2540           write_word( 0x40, 0x9A, regs.u.r16.bx );
! Debug: list unsigned short regs = [S+$16+$A] (used reg = )
push	$C[bp]
! Debug: list int = const $9A (used reg = )
mov	ax,#$9A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2541           write_word( 0x40, 0x9C, regs.u.r16.dx );
! Debug: list unsigned short regs = [S+$16+$C] (used reg = )
push	$E[bp]
! Debug: list int = const $9C (used reg = )
mov	ax,#$9C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2542           write_word( 0x40, 0x9E, regs.u.r16.cx );
! Debug: list unsigned short regs = [S+$16+$E] (used reg = )
push	$10[bp]
! Debug: list int = const $9E (used reg = )
mov	ax,#$9E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2543           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2544           irqDisable = inb( 0xA1 );
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char irqDisable = [S+$16-$15] (used reg = )
mov	-$13[bp],al
!BCC_EOS
! 2545           outb( 0xA1, irqDisable & 0xFE );
! Debug: and int = const $FE to unsigned char irqDisable = [S+$16-$15] (used reg = )
mov	al,-$13[bp]
and	al,#$FE
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2546           bRegister = inb_cmos( 0xB );
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$16-$14] (used reg = )
xor	ah,ah
mov	-$12[bp],ax
!BCC_EOS
! 2547           outb_cmos( 0xB, bRegister | 0x40 );
! Debug: or int = const $40 to unsigned short bRegister = [S+$16-$14] (used reg = )
mov	ax,-$12[bp]
or	al,*$40
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 2548         } else {
jmp .37A
.378:
! 2549           ;
!BCC_EOS
! 2550           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2551           regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2552         }
! 2553       } else if( regs.u.r8.al == 1 ) {
.37A:
jmp .37B
.376:
! Debug: logeq int = const 1 to unsigned char regs = [S+$16+$10] (used reg = )
mov	al,$12[bp]
cmp	al,*1
jne 	.37C
.37D:
! 2554         write_byte( 0x40, 0xA0, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2555         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2556         bRegister = inb_cmos( 0xB );
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$16-$14] (used reg = )
xor	ah,ah
mov	-$12[bp],ax
!BCC_EOS
! 2557         outb_cmos( 0xB, bRegister & ~0x40 );
! Debug: and int = const -$41 to unsigned short bRegister = [S+$16-$14] (used reg = )
mov	ax,-$12[bp]
and	al,#$BF
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 2558       } else {
jmp .37E
.37C:
! 2559         ;
!BCC_EOS
! 2560         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2561         regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2562         regs.u.r8.al--;
! Debug: postdec unsigned char regs = [S+$16+$10] (used reg = )
mov	al,$12[bp]
dec	ax
mov	$12[bp],al
!BCC_EOS
! 2563       }
! 2564       break;
.37E:
.37B:
br 	.365
!BCC_EOS
! 2565     }
! 2566     case 0x87:
! 2567 #asm
.37F:
!BCC_EOS
!BCC_ASM
_int15_function.CX	set	6
.int15_function.CX	set	-$E
_int15_function.FLAGS	set	$2C
.int15_function.FLAGS	set	$18
_int15_function.irqDisable	set	1
.int15_function.irqDisable	set	-$13
_int15_function.DS	set	$2A
.int15_function.DS	set	$16
_int15_function.DX	set	4
.int15_function.DX	set	-$10
_int15_function.base23_16	set	$D
.int15_function.base23_16	set	-7
_int15_function.bRegister	set	2
.int15_function.bRegister	set	-$12
_int15_function.ES	set	$28
.int15_function.ES	set	$14
_int15_function.ebda_seg	set	$12
.int15_function.ebda_seg	set	-2
_int15_function.base15_00	set	$E
.int15_function.base15_00	set	-6
_int15_function.ss	set	$A
.int15_function.ss	set	-$A
_int15_function.BX	set	8
.int15_function.BX	set	-$C
_int15_function.regs	set	$18
.int15_function.regs	set	4
_int15_function.prev_a20_enable	set	$10
.int15_function.prev_a20_enable	set	-4
  cli
! 2569 endasm
!BCC_ENDASM
!BCC_EOS
! 2570       prev_a20_enable = set_enable_a20(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
! Debug: eq unsigned short = ax+0 to unsigned short prev_a20_enable = [S+$16-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 2571       base15_00 = (ES << 4) + regs.u.r16.si;
! Debug: sl int = const 4 to unsigned short ES = [S+$16+$12] (used reg = )
mov	ax,$14[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned short regs = [S+$16+4] to unsigned int = ax+0 (used reg = )
add	ax,6[bp]
! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2572       base23_16 = ES >> 12;
! Debug: sr int = const $C to unsigned short ES = [S+$16+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$16-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 2573       if (base15_00 < (ES<<4))
! Debug: sl int = const 4 to unsigned short ES = [S+$16+$12] (used reg = )
mov	ax,$14[bp]
mov	cl,*4
shl	ax,cl
! Debug: lt unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
cmp	ax,-6[bp]
jbe 	.380
.381:
! 2574         base23_16++;
! Debug: postinc unsigned char base23_16 = [S+$16-9] (used reg = )
mov	al,-7[bp]
inc	ax
mov	-7[bp],al
!BCC_EOS
! 2575       write_word(ES, regs.u.r16.si+0x08+0, 47);
.380:
! Debug: list int = const $2F (used reg = )
mov	ax,*$2F
push	ax
! Debug: add int = const 8 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 0 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2576       write_word(ES, regs.u.r16.si+0x08+2, base15_00);
! Debug: list unsigned short base15_00 = [S+$16-8] (used reg = )
push	-6[bp]
! Debug: add int = const 8 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 2 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+$A (used reg = )
add	ax,*$A
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2577       write_byte(ES, regs.u.r16.si+0x08+4, base23_16);
! Debug: list unsigned char base23_16 = [S+$16-9] (used reg = )
mov	al,-7[bp]
xor	ah,ah
push	ax
! Debug: add int = const 8 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 4 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2578       write_byte(ES, regs.u.r16.si+0x08+5, 0x93);
! Debug: list int = const $93 (used reg = )
mov	ax,#$93
push	ax
! Debug: add int = const 8 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 5 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+$D (used reg = )
add	ax,*$D
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2579       write_word(ES, regs.u.r16.si+0x08+6, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 8 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 6 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+$E (used reg = )
add	ax,*$E
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2580       write_word(ES, regs.u.r16.si+0x20+0, 0xffff);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 0 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$20 (used reg = )
add	ax,*$20
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2581       write_word(ES, regs.u.r16.si+0x20+2, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 2 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$22 (used reg = )
add	ax,*$22
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2582       write_byte(ES, regs.u.r16.si+0x20+4, 0x000f);
! Debug: list int = const $F (used reg = )
mov	ax,*$F
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 4 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$24 (used reg = )
add	ax,*$24
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2583       write_byte(ES, regs.u.r16.si+0x20+5, 0x9b);
! Debug: list int = const $9B (used reg = )
mov	ax,#$9B
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 5 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$25 (used reg = )
add	ax,*$25
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2584       write_word(ES, regs.u.r16.si+0x20+6, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 6 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$26 (used reg = )
add	ax,*$26
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2585       ss = get_SS();
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 2586       base15_00 = ss << 4;
! Debug: sl int = const 4 to unsigned short ss = [S+$16-$C] (used reg = )
mov	ax,-$A[bp]
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$16-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2587       base23_16 = ss >> 12;
! Debug: sr int = const $C to unsigned short ss = [S+$16-$C] (used reg = )
mov	ax,-$A[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$16-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 2588       write_word(ES, regs.u.r16.si+0x28+0
! 2588 , 0xffff);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: add int = const $28 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 0 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$28 (used reg = )
add	ax,*$28
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2589       write_word(ES, regs.u.r16.si+0x28+2, base15_00);
! Debug: list unsigned short base15_00 = [S+$16-8] (used reg = )
push	-6[bp]
! Debug: add int = const $28 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 2 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$2A (used reg = )
add	ax,*$2A
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2590       write_byte(ES, regs.u.r16.si+0x28+4, base23_16);
! Debug: list unsigned char base23_16 = [S+$16-9] (used reg = )
mov	al,-7[bp]
xor	ah,ah
push	ax
! Debug: add int = const $28 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 4 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$2C (used reg = )
add	ax,*$2C
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2591       write_byte(ES, regs.u.r16.si+0x28+5, 0x93);
! Debug: list int = const $93 (used reg = )
mov	ax,#$93
push	ax
! Debug: add int = const $28 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 5 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$2D (used reg = )
add	ax,*$2D
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2592       write_word(ES, regs.u.r16.si+0x28+6, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $28 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 6 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$2E (used reg = )
add	ax,*$2E
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2593       CX = regs.u.r16.cx;
! Debug: eq unsigned short regs = [S+$16+$E] to unsigned short CX = [S+$16-$10] (used reg = )
mov	ax,$10[bp]
mov	-$E[bp],ax
!BCC_EOS
! 2594 #asm
!BCC_EOS
!BCC_ASM
_int15_function.CX	set	6
.int15_function.CX	set	-$E
_int15_function.FLAGS	set	$2C
.int15_function.FLAGS	set	$18
_int15_function.irqDisable	set	1
.int15_function.irqDisable	set	-$13
_int15_function.DS	set	$2A
.int15_function.DS	set	$16
_int15_function.DX	set	4
.int15_function.DX	set	-$10
_int15_function.base23_16	set	$D
.int15_function.base23_16	set	-7
_int15_function.bRegister	set	2
.int15_function.bRegister	set	-$12
_int15_function.ES	set	$28
.int15_function.ES	set	$14
_int15_function.ebda_seg	set	$12
.int15_function.ebda_seg	set	-2
_int15_function.base15_00	set	$E
.int15_function.base15_00	set	-6
_int15_function.ss	set	$A
.int15_function.ss	set	-$A
_int15_function.BX	set	8
.int15_function.BX	set	-$C
_int15_function.regs	set	$18
.int15_function.regs	set	4
_int15_function.prev_a20_enable	set	$10
.int15_function.prev_a20_enable	set	-4
      mov bx, sp
      SEG SS
        mov cx, _int15_function.CX [bx]
      push eax
      xor eax, eax
      mov ds, ax
      mov 0x0469, ss
      mov 0x0467, sp
      SEG ES
        lgdt [si + 0x08]
      SEG CS
        lidt [pmode_IDT_info]
      ;; perhaps do something with IDT here
      ;; set PE bit in CR0
      mov eax, cr0
      or al, #0x01
      mov cr0, eax
      ;; far jump to flush CPU queue after transition to protected mode
      JMP_AP(0x0020, protected_mode)
protected_mode:
      ;; GDT points to valid descriptor table, now load SS, DS, ES
      mov ax, #0x28 ;; 101 000 = 5th descriptor in table, TI=GDT, RPL=00
      mov ss, ax
      mov ax, #0x10 ;; 010 000 = 2nd descriptor in table, TI=GDT, RPL=00
      mov ds, ax
      mov ax, #0x18 ;; 011 000 = 3rd descriptor in table, TI=GDT, RPL=00
      mov es, ax
      xor si, si
      xor di, di
      cld
      rep
        movsw ;; move CX words from DS:SI to ES:DI
      ;; make sure DS and ES limits are 64KB
      mov ax, #0x28
      mov ds, ax
      mov es, ax
      ;; reset PG bit in CR0 ???
      mov eax, cr0
      and al, #0xFE
      mov cr0, eax
      ;; far jump to flush CPU queue after transition to real mode
      JMP_AP(0xf000, real_mode)
real_mode:
      ;; restore IDT to normal real-mode defaults
      SEG CS
        lidt [rmode_IDT_info]
      xor ax, ax
      mov ds, ax
      mov ss, 0x0469
      mov sp, 0x0467
      pop eax
! 2646 endasm
!BCC_ENDASM
!BCC_EOS
! 2647       set_enable_a20(prev_a20_enable);
! Debug: list unsigned short prev_a20_enable = [S+$16-6] (used reg = )
push	-4[bp]
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
!BCC_EOS
! 2648 #asm
!BCC_EOS
!BCC_ASM
_int15_function.CX	set	6
.int15_function.CX	set	-$E
_int15_function.FLAGS	set	$2C
.int15_function.FLAGS	set	$18
_int15_function.irqDisable	set	1
.int15_function.irqDisable	set	-$13
_int15_function.DS	set	$2A
.int15_function.DS	set	$16
_int15_function.DX	set	4
.int15_function.DX	set	-$10
_int15_function.base23_16	set	$D
.int15_function.base23_16	set	-7
_int15_function.bRegister	set	2
.int15_function.bRegister	set	-$12
_int15_function.ES	set	$28
.int15_function.ES	set	$14
_int15_function.ebda_seg	set	$12
.int15_function.ebda_seg	set	-2
_int15_function.base15_00	set	$E
.int15_function.base15_00	set	-6
_int15_function.ss	set	$A
.int15_function.ss	set	-$A
_int15_function.BX	set	8
.int15_function.BX	set	-$C
_int15_function.regs	set	$18
.int15_function.regs	set	4
_int15_function.prev_a20_enable	set	$10
.int15_function.prev_a20_enable	set	-4
  sti
! 2650 endasm
!BCC_ENDASM
!BCC_EOS
! 2651       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2652       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2653       break;
br 	.365
!BCC_EOS
! 2654     case 0x88:
! 2655       regs.u.r8.al = inb_cmos(0x30);
.382:
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2656       regs.u.r8.ah = inb_cmos(0x31);
! Debug: list int = const $31 (used reg = )
mov	ax,*$31
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$16+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2657       if(regs.u.r16.ax > 0xffc0)
! Debug: gt unsigned int = const $FFC0 to unsigned short regs = [S+$16+$10] (used reg = )
mov	ax,$12[bp]
cmp	ax,#$FFC0
jbe 	.383
.384:
! 2658         regs.u.r16.ax = 0xffc0;
! Debug: eq unsigned int = const $FFC0 to unsigned short regs = [S+$16+$10] (used reg = )
mov	ax,#$FFC0
mov	$12[bp],ax
!BCC_EOS
! 2659       FLAGS &= 0xfffe;
.383:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2660       break;
br 	.365
!BCC_EOS
! 2661   case 0x89:
! 2662 #asm
.385:
!BCC_EOS
!BCC_ASM
_int15_function.CX	set	6
.int15_function.CX	set	-$E
_int15_function.FLAGS	set	$2C
.int15_function.FLAGS	set	$18
_int15_function.irqDisable	set	1
.int15_function.irqDisable	set	-$13
_int15_function.DS	set	$2A
.int15_function.DS	set	$16
_int15_function.DX	set	4
.int15_function.DX	set	-$10
_int15_function.base23_16	set	$D
.int15_function.base23_16	set	-7
_int15_function.bRegister	set	2
.int15_function.bRegister	set	-$12
_int15_function.ES	set	$28
.int15_function.ES	set	$14
_int15_function.ebda_seg	set	$12
.int15_function.ebda_seg	set	-2
_int15_function.base15_00	set	$E
.int15_function.base15_00	set	-6
_int15_function.ss	set	$A
.int15_function.ss	set	-$A
_int15_function.BX	set	8
.int15_function.BX	set	-$C
_int15_function.regs	set	$18
.int15_function.regs	set	4
_int15_function.prev_a20_enable	set	$10
.int15_function.prev_a20_enable	set	-4
  cli
! 2664 endasm
!BCC_ENDASM
!BCC_EOS
! 2665       set_enable_a20(1);
! 2665 
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
!BCC_EOS
! 2666       write_word(ES, regs.u.r16.si+0x38+0, 0xffff);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: add int = const $38 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 0 to unsigned int = ax+$38 (used reg = )
! Debug: list unsigned int = ax+$38 (used reg = )
add	ax,*$38
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2667       write_word(ES, regs.u.r16.si+0x38+2, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $38 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 2 to unsigned int = ax+$38 (used reg = )
! Debug: list unsigned int = ax+$3A (used reg = )
add	ax,*$3A
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2668       write_byte(ES, regs.u.r16.si+0x38+4, 0x000f);
! Debug: list int = const $F (used reg = )
mov	ax,*$F
push	ax
! Debug: add int = const $38 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 4 to unsigned int = ax+$38 (used reg = )
! Debug: list unsigned int = ax+$3C (used reg = )
add	ax,*$3C
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2669       write_byte(ES, regs.u.r16.si+0x38+5, 0x9b);
! Debug: list int = const $9B (used reg = )
mov	ax,#$9B
push	ax
! Debug: add int = const $38 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 5 to unsigned int = ax+$38 (used reg = )
! Debug: list unsigned int = ax+$3D (used reg = )
add	ax,*$3D
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2670       write_word(ES, regs.u.r16.si+0x38+6, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $38 to unsigned short regs = [S+$18+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 6 to unsigned int = ax+$38 (used reg = )
! Debug: list unsigned int = ax+$3E (used reg = )
add	ax,*$3E
push	ax
! Debug: list unsigned short ES = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2671       BX = regs.u.r16.bx;
! Debug: eq unsigned short regs = [S+$16+$A] to unsigned short BX = [S+$16-$E] (used reg = )
mov	ax,$C[bp]
mov	-$C[bp],ax
!BCC_EOS
! 2672 #asm
!BCC_EOS
!BCC_ASM
_int15_function.CX	set	6
.int15_function.CX	set	-$E
_int15_function.FLAGS	set	$2C
.int15_function.FLAGS	set	$18
_int15_function.irqDisable	set	1
.int15_function.irqDisable	set	-$13
_int15_function.DS	set	$2A
.int15_function.DS	set	$16
_int15_function.DX	set	4
.int15_function.DX	set	-$10
_int15_function.base23_16	set	$D
.int15_function.base23_16	set	-7
_int15_function.bRegister	set	2
.int15_function.bRegister	set	-$12
_int15_function.ES	set	$28
.int15_function.ES	set	$14
_int15_function.ebda_seg	set	$12
.int15_function.ebda_seg	set	-2
_int15_function.base15_00	set	$E
.int15_function.base15_00	set	-6
_int15_function.ss	set	$A
.int15_function.ss	set	-$A
_int15_function.BX	set	8
.int15_function.BX	set	-$C
_int15_function.regs	set	$18
.int15_function.regs	set	4
_int15_function.prev_a20_enable	set	$10
.int15_function.prev_a20_enable	set	-4
      mov bx, sp
      SEG SS
        mov bx, _int15_function.BX [bx]
      mov al, #0x11 ; send initialisation commands
      out 0x20, al
      out 0xa0, al
      mov al, bh
      out 0x21, al
      mov al, bl
      out 0xa1, al
      mov al, #0x04
      out 0x21, al
      mov al, #0x02
      out 0xa1, al
      mov al, #0x01
      out 0x21, al
      out 0xa1, al
      mov al, #0xff ; mask all IRQs, user must re-enable
      out 0x21, al
      out 0xa1, al
      SEG ES
        lgdt [si + 0x08]
      SEG ES
        lidt [si + 0x10]
      mov eax, cr0
      or al, #0x01
      mov cr0, eax
      JMP_AP(0x0038, protmode_switch)
protmode_switch:
      ;; GDT points to valid descriptor table, now load SS, DS, ES
      mov ax, #0x28
      mov ss, ax
      mov ax, #0x18
      mov ds, ax
      mov ax, #0x20
      mov es, ax
      mov sp,bp
      add sp,#4 ; skip return address
      popa ; restore regs
      pop ax ; skip saved es
      pop ax ; skip saved ds
      pop ax ; skip saved flags
      pop cx ; get return offset
      pop ax ; skip return segment
      pop ax ; skip flags
      mov ax, #0x30 ; ah must be 0 on successful exit
      push ax
      push cx ; re-create modified ret address on stack
      retf
! 2722 endasm
!BCC_ENDASM
!BCC_EOS
! 2723       break;
br 	.365
!BCC_EOS
! 2724     case 0x90:
! 2725       break;
.386:
br 	.365
!BCC_EOS
! 2726     case 0x91:
! 2727       break;
.387:
br 	.365
!BCC_EOS
! 2728     case 0xbf:
! 2729       bios_printf(4, "*** int 15h function AH=bf not yet supported!\n");
.388:
! Debug: list * char = .389+0 (used reg = )
mov	bx,#.389
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 2730       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2731       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2732       break;
br 	.365
!BCC_EOS
! 2733     case 0xC0:
! 2734       FLAGS &= 0xfffe;
.38A:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2735       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$16+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2736       regs.u.r16.bx = 0xe6f5;
! Debug: eq unsigned int = const $E6F5 to unsigned short regs = [S+$16+$A] (used reg = )
mov	ax,#$E6F5
mov	$C[bp],ax
!BCC_EOS
! 2737       ES = 0xF000;
! Debug: eq unsigned int = const $F000 to unsigned short ES = [S+$16+$12] (used reg = )
mov	ax,#$F000
mov	$14[bp],ax
!BCC_EOS
! 2738       break;
br 	.365
!BCC_EOS
! 2739     case 0xc1:
! 2740       ES = ebda_seg;
.38B:
! Debug: eq unsigned short ebda_seg = [S+$16-4] to unsigned short ES = [S+$16+$12] (used reg = )
mov	ax,-2[bp]
mov	$14[bp],ax
!BCC_EOS
! 2741       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2742       break;
br 	.365
!BCC_EOS
! 2743     case 0xd8:
! 2744       bios_printf(8, "EISA BIOS not present\n");
.38C:
! Debug: list * char = .38D+0 (used reg = )
mov	bx,#.38D
push	bx
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 2745       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2746       regs.u.r8.ah =
! 2746  0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2747       break;
br 	.365
!BCC_EOS
! 2748     default:
! 2749       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
.38E:
! Debug: list unsigned short regs = [S+$16+$A] (used reg = )
push	$C[bp]
! Debug: list unsigned short regs = [S+$18+$10] (used reg = )
push	$12[bp]
! Debug: list * char = .38F+0 (used reg = )
mov	bx,#.38F
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 2750       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$16+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2751       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$16+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2752       break;
jmp .365
!BCC_EOS
! 2753     }
! 2754 }
jmp .365
.367:
sub	al,*$24
beq 	.368
sub	al,*$1D
beq 	.372
sub	al,*$E
beq 	.373
sub	al,*3
beq 	.374
sub	al,*$31
jb 	.38E
cmp	al,*$E
ja  	.390
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.391[bx]
.391:
.word	.375
.word	.38E
.word	.38E
.word	.38E
.word	.37F
.word	.382
.word	.385
.word	.38E
.word	.38E
.word	.38E
.word	.38E
.word	.38E
.word	.38E
.word	.386
.word	.387
.390:
sub	al,*$3C
beq 	.388
sub	al,*1
beq 	.38A
sub	al,*1
beq 	.38B
sub	al,*$17
beq 	.38C
br 	.38E
.365:
..FFF7	=	-$16
mov	sp,bp
pop	bp
ret
! 2755   void
! Register BX used in function int15_function
! 2756 int15_function_mouse(regs, ES, DS, FLAGS)
! 2757   pusha_regs_t regs;
export	_int15_function_mouse
_int15_function_mouse:
!BCC_EOS
! 2758   Bit16u ES, DS, FLAGS;
!BCC_EOS
! 2759 {
! 2760   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2761   Bit8u mouse_flags_1, mouse_flags_2;
!BCC_EOS
! 2762   Bit16u mouse_driver_seg;
!BCC_EOS
! 2763   Bit16u mouse_driver_offset;
!BCC_EOS
! 2764   Bit8u comm_byte, prev_command_byte;
!BCC_EOS
! 2765   Bit8u ret, mouse_data1, mouse_data2, mouse_data3;
!BCC_EOS
! 2766 ;
add	sp,*-$C
!BCC_EOS
! 2767   switch (regs.u.r8.ah) {
mov	al,$13[bp]
br 	.394
! 2768     case 0xC2:
! 2769       switch (regs.u.r8.al) {
.395:
mov	al,$12[bp]
br 	.398
! 2770         case 0:
! 2771 ;
.399:
!BCC_EOS
! 2772           switch (regs.u.r8.bh) {
mov	al,$D[bp]
br 	.39C
! 2773             case 0:
! 2774 ;
.39D:
!BCC_EOS
! 2775               inhibit_mouse_int_and_events();
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2776               ret = send_to_mouse_ctrl(0xF5);
! Debug: list int = const $F5 (used reg = )
mov	ax,#$F5
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2777               if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.39E
.39F:
! 2778                 ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2779                 if ( (ret == 0) || (mouse_data1 == 0xFA) ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
je  	.3A1
.3A2:
! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
jne 	.3A0
.3A1:
! 2780                   FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2781                   regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2782                   return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2783                 }
! 2784               }
.3A0:
! 2785               FLAGS |= 0x0001;
.39E:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2786               regs.u.r8.ah = ret;
! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,-$B[bp]
mov	$13[bp],al
!BCC_EOS
! 2787               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2788               break;
br 	.39A
!BCC_EOS
! 2789             case 1:
! 2790 ;
.3A3:
!BCC_EOS
! 2791               mouse_flags_2 = read_byte(ebda_seg, 0x0027);
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 2792               if ( (mouse_flags_2 & 0x80) == 0 ) {
! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
and	al,#$80
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.3A4
.3A5:
! 2793                 ;
!BCC_EOS
! 2794                 FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2795                 regs.u.r8.ah = 5;
! Debug: eq int = const 5 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,*5
mov	$13[bp],al
!BCC_EOS
! 2796                 return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2797               }
! 2798               inhibit_mouse_int_and_events();
.3A4:
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2799               ret = send_to_mouse_ctrl(0xF4);
! Debug: list int = const $F4 (used reg = )
mov	ax,#$F4
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2800               if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3A6
.3A7:
! 2801                 ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2802                 if ( (ret == 0) && (mouse_data1 == 0xFA) ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3A8
.3AA:
! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
jne 	.3A8
.3A9:
! 2803                   enable_mouse_int_and_events();
! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
call	_enable_mouse_int_and_events
!BCC_EOS
! 2804                   FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2805                   regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2806                   return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2807                 }
! 2808               }
.3A8:
! 2809               FLAGS |= 0x0001;
.3A6:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2810               regs.u.r8.ah = ret;
! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,-$B[bp]
mov	$13[bp],al
!BCC_EOS
! 2811               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2812             default:
! 2813               ;
.3AB:
!BCC_EOS
! 2814               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2815               regs.u.r8.ah = 1;
! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,*1
mov	$13[bp],al
!BCC_EOS
! 2816    
! 2816            return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2817           }
! 2818           break;
jmp .39A
.39C:
sub	al,*0
beq 	.39D
sub	al,*1
beq 	.3A3
jmp	.3AB
.39A:
br 	.396
!BCC_EOS
! 2819         case 1:
! 2820         case 5:
.3AC:
! 2821 ;
.3AD:
!BCC_EOS
! 2822           if (regs.u.r8.al == 5) {
! Debug: logeq int = const 5 to unsigned char regs = [S+$10+$10] (used reg = )
mov	al,$12[bp]
cmp	al,*5
bne 	.3AE
.3AF:
! 2823             if (regs.u.r8.bh != 3) {
! Debug: ne int = const 3 to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
cmp	al,*3
je  	.3B0
.3B1:
! 2824               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2825               regs.u.r8.ah = 0x02;
! Debug: eq int = const 2 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,*2
mov	$13[bp],al
!BCC_EOS
! 2826               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2827             }
! 2828             mouse_flags_2 = read_byte(ebda_seg, 0x0027);
.3B0:
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 2829             mouse_flags_2 = (mouse_flags_2 & 0x00) | regs.u.r8.bh;
! Debug: and int = const 0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
xor	al,al
! Debug: or unsigned char regs = [S+$10+$B] to unsigned char = al+0 (used reg = )
or	al,$D[bp]
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 2830             mouse_flags_1 = 0x00;
! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
xor	al,al
mov	-3[bp],al
!BCC_EOS
! 2831             write_byte(ebda_seg, 0x0026, mouse_flags_1);
! Debug: list unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $26 (used reg = )
mov	ax,*$26
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2832             write_byte(ebda_seg, 0x0027, mouse_flags_2);
! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2833           }
! 2834           inhibit_mouse_int_and_events();
.3AE:
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2835           ret = send_to_mouse_ctrl(0xFF);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2836           if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
bne 	.3B2
.3B3:
! 2837             ret = get_mouse_data(&mouse_data3);
! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2838             if (mouse_data3 == 0xfe) {
! Debug: logeq int = const $FE to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
mov	al,-$E[bp]
cmp	al,#$FE
jne 	.3B4
.3B5:
! 2839               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2840               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2841             }
! 2842             if (mouse_data3 != 0xfa)
.3B4:
! Debug: ne int = const $FA to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
mov	al,-$E[bp]
cmp	al,#$FA
je  	.3B6
.3B7:
! 2843               bios_printf((2 | 4 | 1), "Mouse reset returned %02x (should be ack)\n", (unsigned)mouse_data3);
! Debug: list unsigned char mouse_data3 = [S+$10-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3B8+0 (used reg = )
mov	bx,#.3B8
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2844             if ( ret == 0 ) {
.3B6:
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3B9
.3BA:
! 2845               ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2846               if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3BB
.3BC:
! 2847                 ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2848                 if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3BD
.3BE:
! 2849                   enable_mouse_int_and_events();
! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
call	_enable_mouse_int_and_events
!BCC_EOS
! 2850                   FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2851                   regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2852                   regs.u.r8.bl = mouse_data1;
! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
mov	al,-$C[bp]
mov	$C[bp],al
!BCC_EOS
! 2853                   regs.u.r8.bh = mouse_data2;
! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,-$D[bp]
mov	$D[bp],al
!BCC_EOS
! 2854                   return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2855                 }
! 2856               }
.3BD:
! 2857             }
.3BB:
! 2858           }
.3B9:
! 2859           FLAGS |= 0x0001;
.3B2:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2860           regs.u.r8.ah = ret;
! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,-$B[bp]
mov	$13[bp],al
!BCC_EOS
! 2861           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2862         case 2:
! 2863 ;
.3BF:
!BCC_EOS
! 2864           switch (regs.u.r8.bh) {
mov	al,$D[bp]
jmp .3C2
! 2865             case 0: mouse_data1 = 10; break;
.3C3:
! Debug: eq int = const $A to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$A
mov	-$C[bp],al
!BCC_EOS
jmp .3C0
!BCC_EOS
! 2866             case 1: mouse_data1 = 20; break;
.3C4:
! Debug: eq int = const $14 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$14
mov	-$C[bp],al
!BCC_EOS
jmp .3C0
!BCC_EOS
! 2867             case 2: mouse_data1 = 40; break;
.3C5:
! Debug: eq int = const $28 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$28
mov	-$C[bp],al
!BCC_EOS
jmp .3C0
!BCC_EOS
! 2868             case 3: mouse_data1 = 60; break;
.3C6:
! Debug: eq int = const $3C to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$3C
mov	-$C[bp],al
!BCC_EOS
jmp .3C0
!BCC_EOS
! 2869             case 4: mouse_data1 = 80; break;
.3C7:
! Debug: eq int = const $50 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$50
mov	-$C[bp],al
!BCC_EOS
jmp .3C0
!BCC_EOS
! 2870             case 5: mouse_data1 = 100; break;
.3C8:
! Debug: eq int = const $64 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$64
mov	-$C[bp],al
!BCC_EOS
jmp .3C0
!BCC_EOS
! 2871             case 6: mouse_data1 = 200; break;
.3C9:
! Debug: eq int = const $C8 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,#$C8
mov	-$C[bp],al
!BCC_EOS
jmp .3C0
!BCC_EOS
! 2872             default: mouse_data1 = 0;
.3CA:
! Debug: eq int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
xor	al,al
mov	-$C[bp],al
!BCC_EOS
! 2873           }
! 2874           if (mouse_data1 > 0) {
jmp .3C0
.3C2:
sub	al,*0
jb 	.3CA
cmp	al,*6
ja  	.3CB
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.3CC[bx]
.3CC:
.word	.3C3
.word	.3C4
.word	.3C5
.word	.3C6
.word	.3C7
.word	.3C8
.word	.3C9
.3CB:
jmp	.3CA
.3C0:
! Debug: gt int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
test	al,al
je  	.3CD
.3CE:
! 2875             ret = send_to_mouse_ctrl(0xF3);
! Debug: list int = const $F3 (used reg = )
mov	ax,#$F3
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2876             if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3CF
.3D0:
! 2877   
! 2877             ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2878               ret = send_to_mouse_ctrl(mouse_data1);
! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2879               ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2880               FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2881               regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2882             } else {
jmp .3D1
.3CF:
! 2883               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2884               regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2885             }
! 2886           } else {
.3D1:
jmp .3D2
.3CD:
! 2887             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2888             regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2889           }
! 2890           break;
.3D2:
br 	.396
!BCC_EOS
! 2891         case 3:
! 2892 ;
.3D3:
!BCC_EOS
! 2893           comm_byte = inhibit_mouse_int_and_events();
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2894           if (regs.u.r8.bh < 4) {
! Debug: lt int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
cmp	al,*4
bhis	.3D4
.3D5:
! 2895             ret = send_to_mouse_ctrl(0xE8);
! Debug: list int = const $E8 (used reg = )
mov	ax,#$E8
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2896             if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3D6
.3D7:
! 2897               ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2898               if (mouse_data1 != 0xfa)
! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
je  	.3D8
.3D9:
! 2899                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3DA+0 (used reg = )
mov	bx,#.3DA
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2900               ret = send_to_mouse_ctrl(regs.u.r8.bh);
.3D8:
! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2901               ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2902               if (mouse_data1 != 0xfa)
! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
je  	.3DB
.3DC:
! 2903                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3DD+0 (used reg = )
mov	bx,#.3DD
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2904               FLAGS &= 0xfffe;
.3DB:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2905               regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2906             } else {
jmp .3DE
.3D6:
! 2907               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2908               regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2909             }
! 2910           } else {
.3DE:
jmp .3DF
.3D4:
! 2911             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2912             regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2913           }
! 2914           set_kbd_command_byte(comm_byte);
.3DF:
! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	al,-9[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_kbd_command_byte+0 (used reg = )
call	_set_kbd_command_byte
inc	sp
inc	sp
!BCC_EOS
! 2915           break;
br 	.396
!BCC_EOS
! 2916         case 4:
! 2917 ;
.3E0:
!BCC_EOS
! 2918           inhibit_mouse_int_and_events();
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2919           ret = send_to_mouse_ctrl(0xF2);
! Debug: list int = const $F2 (used reg = )
mov	ax,#$F2
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2920           if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3E1
.3E2:
! 2921             ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2922             ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2923             FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2924             regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2925             regs.u.r8.bh = mouse_data2;
! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,-$D[bp]
mov	$D[bp],al
!BCC_EOS
! 2926           } else {
jmp .3E3
.3E1:
! 2927             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2928             regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2929           }
! 2930           break;
.3E3:
br 	.396
!BCC_EOS
! 2931         case 6:
! 2932 ;
.3E4:
!BCC_EOS
! 2933           switch (regs.u.r8.bh) {
mov	al,$D[bp]
br 	.3E7
! 2934             case 0:
! 2935               comm_byte = inhibit_mouse_int_and_events();
.3E8:
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2936               ret = send_to_mouse_ctrl(0xE9);
! Debug: list int = const $E9 (used reg = )
mov	ax,#$E9
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2937               if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
bne 	.3E9
.3EA:
! 2938                 ret = get_mouse
! 2938 _data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2939                 if (mouse_data1 != 0xfa)
! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
je  	.3EB
.3EC:
! 2940                   bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3ED+0 (used reg = )
mov	bx,#.3ED
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2941                 if (ret == 0) {
.3EB:
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3EE
.3EF:
! 2942                   ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2943                   if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3F0
.3F1:
! 2944                     ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2945                     if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3F2
.3F3:
! 2946                       ret = get_mouse_data(&mouse_data3);
! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2947                       if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3F4
.3F5:
! 2948                         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2949                         regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2950                         regs.u.r8.bl = mouse_data1;
! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
mov	al,-$C[bp]
mov	$C[bp],al
!BCC_EOS
! 2951                         regs.u.r8.cl = mouse_data2;
! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$E] (used reg = )
mov	al,-$D[bp]
mov	$10[bp],al
!BCC_EOS
! 2952                         regs.u.r8.dl = mouse_data3;
! Debug: eq unsigned char mouse_data3 = [S+$10-$10] to unsigned char regs = [S+$10+$C] (used reg = )
mov	al,-$E[bp]
mov	$E[bp],al
!BCC_EOS
! 2953                         set_kbd_command_byte(comm_byte);
! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	al,-9[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_kbd_command_byte+0 (used reg = )
call	_set_kbd_command_byte
inc	sp
inc	sp
!BCC_EOS
! 2954                         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2955                       }
! 2956                     }
.3F4:
! 2957                   }
.3F2:
! 2958                 }
.3F0:
! 2959               }
.3EE:
! 2960               FLAGS |= 0x0001;
.3E9:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2961               regs.u.r8.ah = ret;
! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,-$B[bp]
mov	$13[bp],al
!BCC_EOS
! 2962               set_kbd_command_byte(comm_byte);
! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	al,-9[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_kbd_command_byte+0 (used reg = )
call	_set_kbd_command_byte
inc	sp
inc	sp
!BCC_EOS
! 2963               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2964             case 1:
! 2965             case 2:
.3F6:
! 2966               comm_byte = inhibit_mouse_int_and_events();
.3F7:
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2967               if (regs.u.r8.bh == 1) {
! Debug: logeq int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
cmp	al,*1
jne 	.3F8
.3F9:
! 2968                 ret = send_to_mouse_ctrl(0xE6);
! Debug: list int = const $E6 (used reg = )
mov	ax,#$E6
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2969               } else {
jmp .3FA
.3F8:
! 2970                 ret = send_to_mouse_ctrl(0xE7);
! Debug: list int = const $E7 (used reg = )
mov	ax,#$E7
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2971               }
! 2972               if (ret == 0) {
.3FA:
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3FB
.3FC:
! 2973                 get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
!BCC_EOS
! 2974                 ret = (mouse_data1 != 0xFA);
! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
je 	.3FD
mov	al,*1
jmp	.3FE
.3FD:
xor	al,al
.3FE:
! Debug: eq char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2975               }
! 2976               if (ret == 0) {
.3FB:
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3FF
.400:
! 2977                 FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2978                 regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2979               } else {
jmp .401
.3FF:
! 2980                 FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2981                 regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2982               }
! 2983               set_kbd_command_byte(comm_byte);
.401:
! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	al,-9[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_kbd_command_byte+0 (used reg = )
call	_set_kbd_command_byte
inc	sp
inc	sp
!BCC_EOS
! 2984               break;
jmp .3E5
!BCC_EOS
! 2985             default:
! 2986               bios_printf((2 | 4 | 1), "INT 15h C2 AL=6, BH=%02x\n", (unsigned) regs.u.r8.bh);
.402:
! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
xor	ah,ah
push	ax
! Debug: list * char = .403+0 (used reg = )
mov	bx,#.403
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2987           }
! 2988           break;
jmp .3E5
.3E7:
sub	al,*0
beq 	.3E8
sub	al,*1
beq 	.3F6
sub	al,*1
beq 	.3F7
jmp	.402
.3E5:
br 	.396
!BCC_EOS
! 2989         case 7:
! 2990 ;
.404:
!BCC_EOS
! 2991           mouse_driver_seg = ES;
! Debug: eq unsigned short ES = [S+$10+$12] to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
mov	ax,$14[bp]
mov	-6[bp],ax
!BCC_EOS
! 2992           mouse_driver_offset = regs.u.r16.bx;
! Debug: eq unsigned short regs = [S+$10+$A] to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
mov	ax,$C[bp]
mov	-8[bp],ax
!BCC_EOS
! 2993           write_word(ebda_seg, 0x0022, mouse_driver_offset);
! Debug: list unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
push	-8[bp]
! Debug: list int = const $22 (used reg = )
mov	ax,*$22
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2994           writ
! 2994 e_word(ebda_seg, 0x0024, mouse_driver_seg);
! Debug: list unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
push	-6[bp]
! Debug: list int = const $24 (used reg = )
mov	ax,*$24
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2995           mouse_flags_2 = read_byte(ebda_seg, 0x0027);
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 2996           if (mouse_driver_offset == 0 && mouse_driver_seg == 0) {
! Debug: logeq int = const 0 to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
test	ax,ax
jne 	.405
.407:
! Debug: logeq int = const 0 to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
mov	ax,-6[bp]
test	ax,ax
jne 	.405
.406:
! 2997             if ( (mouse_flags_2 & 0x80) != 0 ) {
! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
and	al,#$80
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.408
.409:
! 2998               mouse_flags_2 &= ~0x80;
! Debug: andab int = const -$81 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
and	al,*$7F
mov	-4[bp],al
!BCC_EOS
! 2999               inhibit_mouse_int_and_events();
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 3000             }
! 3001           }
.408:
! 3002           else {
jmp .40A
.405:
! 3003             mouse_flags_2 |= 0x80;
! Debug: orab int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
or	al,#$80
mov	-4[bp],al
!BCC_EOS
! 3004           }
! 3005           write_byte(ebda_seg, 0x0027, mouse_flags_2);
.40A:
! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3006           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 3007           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 3008           break;
jmp .396
!BCC_EOS
! 3009         default:
! 3010 ;
.40B:
!BCC_EOS
! 3011           regs.u.r8.ah = 1;
! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,*1
mov	$13[bp],al
!BCC_EOS
! 3012           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 3013       }
! 3014       break;
jmp .396
.398:
sub	al,*0
jb 	.40B
cmp	al,*7
ja  	.40C
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.40D[bx]
.40D:
.word	.399
.word	.3AC
.word	.3BF
.word	.3D3
.word	.3E0
.word	.3AD
.word	.3E4
.word	.404
.40C:
jmp	.40B
.396:
jmp .392
!BCC_EOS
! 3015     default:
! 3016       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
.40E:
! Debug: list unsigned short regs = [S+$10+$A] (used reg = )
push	$C[bp]
! Debug: list unsigned short regs = [S+$12+$10] (used reg = )
push	$12[bp]
! Debug: list * char = .40F+0 (used reg = )
mov	bx,#.40F
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3017       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 3018       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 3019       break;
jmp .392
!BCC_EOS
! 3020   }
! 3021 }
jmp .392
.394:
sub	al,#$C2
beq 	.395
jmp	.40E
.392:
..FFF6	=	-$10
mov	sp,bp
pop	bp
ret
! 3022 void set_e820_range(ES, DI, start, end, extra_start, extra_end, type)
! Register BX used in function int15_function_mouse
! 3023      Bit16u ES;
export	_set_e820_range
_set_e820_range:
!BCC_EOS
! 3024      Bit16u DI;
!BCC_EOS
! 3025      Bit32u start;
!BCC_EOS
! 3026      Bit32u end;
!BCC_EOS
! 3027      Bit8u extra_start;
!BCC_EOS
! 3028      Bit8u extra_end;
!BCC_EOS
! 3029      Bit16u type;
!BCC_EOS
! 3030 {
! 3031     write_word(ES, DI, start);
push	bp
mov	bp,sp
! Debug: list unsigned long start = [S+2+6] (used reg = )
push	$A[bp]
push	8[bp]
! Debug: list unsigned short DI = [S+6+4] (used reg = )
push	6[bp]
! Debug: list unsigned short ES = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3032     write_word(ES, DI+2, start >> 16);
! Debug: sr int = const $10 to unsigned long start = [S+2+6] (used reg = )
mov	ax,8[bp]
mov	bx,$A[bp]
xchg	bx,ax
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 2 to unsigned short DI = [S+6+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short ES = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3033     write_word(ES, DI+4, extra_start);
! Debug: list unsigned char extra_start = [S+2+$E] (used reg = )
mov	al,$10[bp]
xor	ah,ah
push	ax
! Debug: add int = const 4 to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3034     write_word(ES, DI+6, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 6 to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3035     end -= start;
! Debug: subab unsigned long start = [S+2+6] to unsigned long end = [S+2+$A] (used reg = )
mov	ax,$C[bp]
mov	bx,$E[bp]
lea	di,8[bp]
call	lsubul
mov	$C[bp],ax
mov	$E[bp],bx
!BCC_EOS
! 3036     extra_end -= extra_start;
! Debug: subab unsigned char extra_start = [S+2+$E] to unsigned char extra_end = [S+2+$10] (used reg = )
mov	al,$12[bp]
xor	ah,ah
sub	al,$10[bp]
sbb	ah,*0
mov	$12[bp],al
!BCC_EOS
! 3037     write_word(ES, DI+8, end);
! Debug: list unsigned long end = [S+2+$A] (used reg = )
push	$E[bp]
push	$C[bp]
! Debug: add int = const 8 to unsigned short DI = [S+6+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short ES = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3038     write_word(ES, DI+10, end >> 16);
! Debug: sr int = const $10 to unsigned long end = [S+2+$A] (used reg = )
mov	ax,$C[bp]
mov	bx,$E[bp]
xchg	bx,ax
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const $A to unsigned short DI = [S+6+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$A (used reg = )
add	ax,*$A
push	ax
! Debug: list unsigned short ES = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3039     write_word(ES, DI+12, extra_end);
! Debug: list unsigned char extra_end = [S+2+$10] (used reg = )
mov	al,$12[bp]
xor	ah,ah
push	ax
! Debug: add int = const $C to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3040     write_word(ES, DI+14, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $E to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$E (used reg = )
add	ax,*$E
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3041     write_word(ES, DI+16, type);
! Debug: list unsigned short type = [S+2+$12] (used reg = )
push	$14[bp]
! Debug: add int = const $10 to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3042     write_word(ES, DI+18, 0x0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $12 to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$12 (used reg = )
add	ax,*$12
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3043 }
pop	bp
ret
! 3044   void
! Register BX used in function set_e820_range
! 3045 int15_function32(regs, ES, DS, FLAGS)
! 3046   pushad_regs_t regs;
export	_int15_function32
_int15_function32:
!BCC_EOS
! 3047   Bit16u ES, DS, FLAGS;
!BCC_EOS
! 3048 {
! 3049   Bit32u extended_memory_size=0;
push	bp
mov	bp,sp
add	sp,*-4
! Debug: eq int = const 0 to unsigned long extended_memory_size = [S+6-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3050   Bit32u extra_lowbits_memory_size=0;
add	sp,*-4
! Debug: eq int = const 0 to unsigned long extra_lowbits_memory_size = [S+$A-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 3051   Bit16u CX,DX;
!BCC_EOS
! 3052   Bit8u extra_highbits_memory_size=0;
add	sp,*-5
! Debug: eq int = const 0 to unsigned char extra_highbits_memory_size = [S+$F-$F] (used reg = )
xor	al,al
mov	-$D[bp],al
!BCC_EOS
! 3053 ;
dec	sp
!BCC_EOS
! 3054   switch (regs.u.r8.ah) {
mov	al,$21[bp]
br 	.412
! 3055     case 0x86:
! 3056       CX = regs.u.r16.cx;
.413:
! Debug: eq unsigned short regs = [S+$10+$1A] to unsigned short CX = [S+$10-$C] (used reg = )
mov	ax,$1C[bp]
mov	-$A[bp],ax
!BCC_EOS
! 3057       DX = regs.u.r16.dx;
! Debug: eq unsigned short regs = [S+$10+$16] to unsigned short DX = [S+$10-$E] (used reg = )
mov	ax,$18[bp]
mov	-$C[bp],ax
!BCC_EOS
! 3058 #asm
!BCC_EOS
!BCC_ASM
_int15_function32.CX	set	4
.int15_function32.CX	set	-$A
_int15_function32.extra_highbits_memory_size	set	1
.int15_function32.extra_highbits_memory_size	set	-$D
_int15_function32.extra_lowbits_memory_size	set	6
.int15_function32.extra_lowbits_memory_size	set	-8
_int15_function32.extended_memory_size	set	$A
.int15_function32.extended_memory_size	set	-4
_int15_function32.FLAGS	set	$36
.int15_function32.FLAGS	set	$28
_int15_function32.DS	set	$34
.int15_function32.DS	set	$26
_int15_function32.DX	set	2
.int15_function32.DX	set	-$C
_int15_function32.ES	set	$32
.int15_function32.ES	set	$24
_int15_function32.regs	set	$12
.int15_function32.regs	set	4
      sti
      ;; Get the count in eax
      mov bx, sp
      SEG SS
        mov ax, _int15_function32.CX [bx]
      shl eax, #16
      SEG SS
        mov ax, _int15_function32.DX [bx]
      ;; convert to numbers of 15usec ticks
      mov ebx, #15
      xor edx, edx
      div eax, ebx
      mov ecx, eax
      ;; wait for ecx number of refresh requests
      in al, #0x61
      and al,#0x10
      mov ah, al
      or ecx, ecx
      je int1586_tick_end
int1586_tick:
      in al, #0x61
      and al,#0x10
      cmp al, ah
      je int1586_tick
      mov ah, al
      dec ecx
      jnz int1586_tick
int1586_tick_end:
! 3087 endasm
!BCC_ENDASM
!BCC_EOS
! 3088       break;
br 	.410
!BCC_EOS
! 3089     case 0xe8:
! 3090         switch(regs.u.r8.al) {
.414:
mov	al,$20[bp]
br 	.417
! 3091          case 0x20:
! 3092             if(regs.u.r32.edx == 0x534D4150)
.418:
! Debug: logeq long = const $534D4150 to unsigned long regs = [S+$10+$16] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$4150
mov	bx,#$534D
push	bx
push	ax
mov	ax,$18[bp]
mov	bx,$1A[bp]
lea	di,-2+..FFF5[bp]
call	lcmpul
lea	sp,2+..FFF5[bp]
bne 	.419
.41A:
! 3093             {
! 3094                 extended_memory_size = inb_cmos(0x35);
! Debug: list int = const $35 (used reg = )
mov	ax,*$35
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
xor	ah,ah
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3095                 extended_memory_size <<= 8;
! Debug: slab int = const 8 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
mov	bh,bl
mov	bl,ah
mov	ah,al
xor	al,al
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3096                 extended_memory_size |= inb_cmos(0x34);
! Debug: list int = const $34 (used reg = )
mov	ax,*$34
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: cast unsigned long = const 0 to unsigned char = al+0 (used reg = )
xor	ah,ah
xor	bx,bx
! Debug: orab unsigned long = bx+0 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
push	bx
push	ax
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-2+..FFF5[bp]
call	lorul
mov	-4[bp],ax
mov	-2[bp],bx
add	sp,*4
!BCC_EOS
! 3097                 extended_memory_size *= 64;
! Debug: mulab unsigned long = const $40 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
mov	ax,*$40
xor	bx,bx
push	bx
push	ax
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-2+..FFF5[bp]
call	lmulul
mov	-4[bp],ax
mov	-2[bp],bx
add	sp,*4
!BCC_EOS
! 3098                 if(extended_memory_size > 0x3bc000) {
! Debug: gt long = const $3BC000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
mov	ax,#$C000
mov	bx,*$3B
lea	di,-4[bp]
call	lcmpul
jae 	.41B
.41C:
! 3099                     extended_memory_size = 0x3bc000;
! Debug: eq long = const $3BC000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
mov	ax,#$C000
mov	bx,*$3B
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3100                 }
! 3101                 extended_memory_size *= 1024;
.41B:
! Debug: mulab unsigned long = const $400 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
mov	ax,#$400
xor	bx,bx
push	bx
push	ax
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-2+..FFF5[bp]
call	lmulul
mov	-4[bp],ax
mov	-2[bp],bx
add	sp,*4
!BCC_EOS
! 3102                 extended_memory_size += (16L * 1024 * 1024);
! Debug: addab long = const $1000000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
xor	ax,ax
mov	bx,#$100
push	bx
push	ax
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-2+..FFF5[bp]
call	laddul
mov	-4[bp],ax
mov	-2[bp],bx
add	sp,*4
!BCC_EOS
! 3103                 if(extended_memory_size <= (16L * 1024 * 1024)) {
! Debug: le long = const $1000000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
xor	ax,ax
mov	bx,#$100
lea	di,-4[bp]
call	lcmpul
blo 	.41D
.41E:
! 3104                     extended_memory_size = inb_cmos(0x31);
! Debug: list int = const $31 (used reg = )
mov	ax,*$31
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
xor	ah,ah
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3105                     extended_memory_size <<= 8;
! Debug: slab int = const 8 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
mov	bh,bl
mov	bl,ah
mov	ah,al
xor	al,al
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3106                     extended_memory_size |= inb_cmos(0x30);
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: cast unsigned long = const 0 to unsigned char = al+0 (used reg = )
xor	ah,ah
xor	bx,bx
! Debug: orab unsigned long = bx+0 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
push	bx
push	ax
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-2+..FFF5[bp]
call	lorul
mov	-4[bp],ax
mov	-2[bp],bx
add	sp,*4
!BCC_EOS
! 3107                     extended_memory_size *= 1024;
! Debug: mulab unsigned long = const $400 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
mov	ax,#$400
xor	bx,bx
push	bx
push	ax
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-2+..FFF5[bp]
call	lmulul
mov	-4[bp],ax
mov	-2[bp],bx
add	sp,*4
!BCC_EOS
! 3108                     extended_memory_size += (1L * 1024 * 1024);
! Debug: addab long = const $100000 to unsigned long extended_memory_size = [S+$10-6] (used reg = )
xor	ax,ax
mov	bx,*$10
push	bx
push	ax
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-2+..FFF5[bp]
call	laddul
mov	-4[bp],ax
mov	-2[bp],bx
add	sp,*4
!BCC_EOS
! 3109                 }
! 3110                 extra_lowbits_memory_size = inb_cmos(0x5c);
.41D:
! Debug: list int = const $5C (used reg = )
mov	ax,*$5C
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned long extra_lowbits_memory_size = [S+$10-$A] (used reg = )
xor	ah,ah
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 3111                 extra_lowbits_memory_size <<= 8;
! Debug: slab int = const 8 to unsigned long extra_lowbits_memory_size = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
mov	bx,-6[bp]
mov	bh,bl
mov	bl,ah
mov	ah,al
xor	al,al
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 3112                 extra_lowbits_memory_size |= inb_cmos(0x5b);
! Debug: list int = const $5B (used reg = )
mov	ax,*$5B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: cast unsigned long = const 0 to unsigned char = al+0 (used reg = )
xor	ah,ah
xor	bx,bx
! Debug: orab unsigned long = bx+0 to unsigned long extra_lowbits_memory_size = [S+$10-$A] (used reg = )
push	bx
push	ax
mov	ax,-8[bp]
mov	bx,-6[bp]
lea	di,-2+..FFF5[bp]
call	lorul
mov	-8[bp],ax
mov	-6[bp],bx
add	sp,*4
!BCC_EOS
! 3113                 extra_lowbits_memory_size *= 64;
! Debug: mulab unsigned long = const $40 to unsigned long extra_lowbits_memory_size = [S+$10-$A] (used reg = )
mov	ax,*$40
xor	bx,bx
push	bx
push	ax
mov	ax,-8[bp]
mov	bx,-6[bp]
lea	di,-2+..FFF5[bp]
call	lmulul
mov	-8[bp],ax
mov	-6[bp],bx
add	sp,*4
!BCC_EOS
! 3114                 extra_lowbits_memory_size *= 1024;
! Debug: mulab unsigned long = const $400 to unsigned long extra_lowbits_memory_size = [S+$10-$A] (used reg = )
mov	ax,#$400
xor	bx,bx
push	bx
push	ax
mov	ax,-8[bp]
mov	bx,-6[bp]
lea	di,-2+..FFF5[bp]
call	lmulul
mov	-8[bp],ax
mov	-6[bp],bx
add	sp,*4
!BCC_EOS
! 3115                 extra_highbits_memory_size = inb_cmos(0x5d);
! Debug: list int = const $5D (used reg = )
mov	ax,*$5D
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char extra_highbits_memory_size = [S+$10-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 3116                 switch(regs.u.r16.bx)
mov	ax,$14[bp]
! 3117                 {
br 	.421
! 3118                     case 0:
! 3119                         set_e820_range(ES, regs.u.r16.di,
.422:
! 3120                                        0x0000000L, 0x0009f000L, 0, 0, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list long = const $9F000 (used reg = )
mov	ax,#$F000
mov	bx,*9
push	bx
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
push	$24[bp]
! Debug: func () void = set_e820_range+0 (used reg = )
call	_set_e820_range
add	sp,*$12
!BCC_EOS
! 3121                         regs.u.r32.ebx = 1;
! Debug: eq int = const 1 to unsigned long regs = [S+$10+$12] (used reg = )
mov	ax,*1
xor	bx,bx
mov	$14[bp],ax
mov	$16[bp],bx
!BCC_EOS
! 3122                         break;
br 	.41F
!BCC_EOS
! 3123                     case 1:
! 3124                         set_e820_range(ES, regs.u.r16.di,
.423:
! 3125                                        0x0009f000L, 0x000a0000L, 0, 0, 2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list long = const $A0000 (used reg = )
xor	ax,ax
mov	bx,*$A
push	bx
push	ax
! Debug: list long = const $9F000 (used reg = )
mov	ax,#$F000
mov	bx,*9
push	bx
push	ax
! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
push	$24[bp]
! Debug: func () void = set_e820_range+0 (used reg = )
call	_set_e820_range
add	sp,*$12
!BCC_EOS
! 3126      
! 3126                    regs.u.r32.ebx = 2;
! Debug: eq int = const 2 to unsigned long regs = [S+$10+$12] (used reg = )
mov	ax,*2
xor	bx,bx
mov	$14[bp],ax
mov	$16[bp],bx
!BCC_EOS
! 3127                         break;
br 	.41F
!BCC_EOS
! 3128                     case 2:
! 3129                         set_e820_range(ES, regs.u.r16.di,
.424:
! 3130                                        0x000e8000L, 0x00100000L, 0, 0, 2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list long = const $100000 (used reg = )
xor	ax,ax
mov	bx,*$10
push	bx
push	ax
! Debug: list long = const $E8000 (used reg = )
mov	ax,#$8000
mov	bx,*$E
push	bx
push	ax
! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
push	$24[bp]
! Debug: func () void = set_e820_range+0 (used reg = )
call	_set_e820_range
add	sp,*$12
!BCC_EOS
! 3131                         regs.u.r32.ebx = 3;
! Debug: eq int = const 3 to unsigned long regs = [S+$10+$12] (used reg = )
mov	ax,*3
xor	bx,bx
mov	$14[bp],ax
mov	$16[bp],bx
!BCC_EOS
! 3132                         break;
br 	.41F
!BCC_EOS
! 3133                     case 3:
! 3134                         set_e820_range(ES, regs.u.r16.di,
.425:
! 3135                                        0x00100000L,
! 3136                                        extended_memory_size, 0, 0, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned long extended_memory_size = [S+$16-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list long = const $100000 (used reg = )
xor	ax,ax
mov	bx,*$10
push	bx
push	ax
! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
push	$24[bp]
! Debug: func () void = set_e820_range+0 (used reg = )
call	_set_e820_range
add	sp,*$12
!BCC_EOS
! 3137                         regs.u.r32.ebx = 5;
! Debug: eq int = const 5 to unsigned long regs = [S+$10+$12] (used reg = )
mov	ax,*5
xor	bx,bx
mov	$14[bp],ax
mov	$16[bp],bx
!BCC_EOS
! 3138                         break;
br 	.41F
!BCC_EOS
! 3139                     case 4:
! 3140                         set_e820_range(ES, regs.u.r16.di,
.426:
! 3141                                        extended_memory_size - 0x00010000L,
! 3142                                        extended_memory_size, 0, 0, 3);
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned long extended_memory_size = [S+$16-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: sub long = const $10000 to unsigned long extended_memory_size = [S+$1A-6] (used reg = )
xor	ax,ax
mov	bx,*1
push	bx
push	ax
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-$C+..FFF5[bp]
call	lsubul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
push	$24[bp]
! Debug: func () void = set_e820_range+0 (used reg = )
call	_set_e820_range
add	sp,*$12
!BCC_EOS
! 3143                         regs.u.r32.ebx = 5;
! Debug: eq int = const 5 to unsigned long regs = [S+$10+$12] (used reg = )
mov	ax,*5
xor	bx,bx
mov	$14[bp],ax
mov	$16[bp],bx
!BCC_EOS
! 3144                         break;
br 	.41F
!BCC_EOS
! 3145                     case 5:
! 3146                         set_e820_range(ES, regs.u.r16.di,
.427:
! 3147                                        0xfffc0000L, 0x00000000L, 0, 0, 2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list unsigned long = const $FFFC0000 (used reg = )
xor	ax,ax
mov	bx,#$FFFC
push	bx
push	ax
! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
push	$24[bp]
! Debug: func () void = set_e820_range+0 (used reg = )
call	_set_e820_range
add	sp,*$12
!BCC_EOS
! 3148                         if (extra_highbits_memory_size || extra_lowbits_memory_size)
! Debug: cast unsigned long = const 0 to unsigned char extra_highbits_memory_size = [S+$10-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
xor	bx,bx
call	ltstl
jne 	.429
.42A:
mov	ax,-8[bp]
mov	bx,-6[bp]
call	ltstl
je  	.428
.429:
! 3149                             regs.u.r32.ebx = 6;
! Debug: eq int = const 6 to unsigned long regs = [S+$10+$12] (used reg = )
mov	ax,*6
xor	bx,bx
mov	$14[bp],ax
mov	$16[bp],bx
!BCC_EOS
! 3150                         else
! 3151                             regs.u.r32.ebx = 0;
jmp .42B
.428:
! Debug: eq int = const 0 to unsigned long regs = [S+$10+$12] (used reg = )
xor	ax,ax
xor	bx,bx
mov	$14[bp],ax
mov	$16[bp],bx
!BCC_EOS
! 3152                         break;
.42B:
jmp .41F
!BCC_EOS
! 3153                     case 6:
! 3154                         set_e820_range(ES, regs.u.r16.di, 0x00000000L,
.42C:
! 3155                             extra_lowbits_memory_size, 1, extra_highbits_memory_size
! 3156                                        + 1, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: add int = const 1 to unsigned char extra_highbits_memory_size = [S+$12-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list unsigned long extra_lowbits_memory_size = [S+$16-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list unsigned short regs = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ES = [S+$20+$22] (used reg = )
push	$24[bp]
! Debug: func () void = set_e820_range+0 (used reg = )
call	_set_e820_range
add	sp,*$12
!BCC_EOS
! 3157                         regs.u.r32.ebx = 0;
! Debug: eq int = const 0 to unsigned long regs = [S+$10+$12] (used reg = )
xor	ax,ax
xor	bx,bx
mov	$14[bp],ax
mov	$16[bp],bx
!BCC_EOS
! 3158                         break;
jmp .41F
!BCC_EOS
! 3159                     default:
! 3160                         goto int15_unimplemented;
.42D:
add	sp,#..FFF4-..FFF5
br 	.FFF4
!BCC_EOS
! 3161                         break;
jmp .41F
!BCC_EOS
! 3162                 }
! 3163                 regs.u.r32.eax = 0x534D4150;
jmp .41F
.421:
sub	ax,*0
jl 	.42D
cmp	ax,*6
ja  	.42E
shl	ax,*1
mov	bx,ax
seg	cs
br	.42F[bx]
.42F:
.word	.422
.word	.423
.word	.424
.word	.425
.word	.426
.word	.427
.word	.42C
.42E:
jmp	.42D
.41F:
! Debug: eq long = const $534D4150 to unsigned long regs = [S+$10+$1E] (used reg = )
mov	ax,#$4150
mov	bx,#$534D
mov	$20[bp],ax
mov	$22[bp],bx
!BCC_EOS
! 3164                 regs.u.r32.ecx = 0x14;
! Debug: eq int = const $14 to unsigned long regs = [S+$10+$1A] (used reg = )
mov	ax,*$14
xor	bx,bx
mov	$1C[bp],ax
mov	$1E[bp],bx
!BCC_EOS
! 3165                 FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$26] (used reg = )
mov	ax,$28[bp]
and	al,#$FE
mov	$28[bp],ax
!BCC_EOS
! 3166             } else {
jmp .430
.419:
! 3167               goto int15_unimplemented;
add	sp,#..FFF4-..FFF5
jmp .FFF4
!BCC_EOS
! 3168             }
! 3169             break;
.430:
jmp .415
!BCC_EOS
! 3170         case 0x01:
! 3171           FLAGS &= 0xfffe;
.431:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$26] (used reg = )
mov	ax,$28[bp]
and	al,#$FE
mov	$28[bp],ax
!BCC_EOS
! 3172           regs.u.r8.cl = inb_cmos(0x30);
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$1A] (used reg = )
mov	$1C[bp],al
!BCC_EOS
! 3173           regs.u
! 3173 .r8.ch = inb_cmos(0x31);
! Debug: list int = const $31 (used reg = )
mov	ax,*$31
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$1B] (used reg = )
mov	$1D[bp],al
!BCC_EOS
! 3174           if(regs.u.r16.cx > 0x3c00)
! Debug: gt int = const $3C00 to unsigned short regs = [S+$10+$1A] (used reg = )
mov	ax,$1C[bp]
cmp	ax,#$3C00
jbe 	.432
.433:
! 3175           {
! 3176             regs.u.r16.cx = 0x3c00;
! Debug: eq int = const $3C00 to unsigned short regs = [S+$10+$1A] (used reg = )
mov	ax,#$3C00
mov	$1C[bp],ax
!BCC_EOS
! 3177           }
! 3178           regs.u.r8.dl = inb_cmos(0x34);
.432:
! Debug: list int = const $34 (used reg = )
mov	ax,*$34
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$16] (used reg = )
mov	$18[bp],al
!BCC_EOS
! 3179           regs.u.r8.dh = inb_cmos(0x35);
! Debug: list int = const $35 (used reg = )
mov	ax,*$35
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$10+$17] (used reg = )
mov	$19[bp],al
!BCC_EOS
! 3180           regs.u.r16.ax = regs.u.r16.cx;
! Debug: eq unsigned short regs = [S+$10+$1A] to unsigned short regs = [S+$10+$1E] (used reg = )
mov	ax,$1C[bp]
mov	$20[bp],ax
!BCC_EOS
! 3181           regs.u.r16.bx = regs.u.r16.dx;
! Debug: eq unsigned short regs = [S+$10+$16] to unsigned short regs = [S+$10+$12] (used reg = )
mov	ax,$18[bp]
mov	$14[bp],ax
!BCC_EOS
! 3182           break;
jmp .415
!BCC_EOS
! 3183         default:
! 3184           goto int15_unimplemented;
.434:
add	sp,#..FFF4-..FFF5
jmp .FFF4
!BCC_EOS
! 3185        }
! 3186        break;
jmp .415
.417:
sub	al,*1
je 	.431
sub	al,*$1F
beq 	.418
jmp	.434
.415:
jmp .410
!BCC_EOS
! 3187     int15_unimplemented:
.FFF4:
! 3188     default:
! 3189       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
.435:
! Debug: list unsigned short regs = [S+$10+$12] (used reg = )
push	$14[bp]
! Debug: list unsigned short regs = [S+$12+$1E] (used reg = )
push	$20[bp]
! Debug: list * char = .436+0 (used reg = )
mov	bx,#.436
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3190       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$26] (used reg = )
mov	ax,$28[bp]
or	al,*1
mov	$28[bp],ax
!BCC_EOS
! 3191       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$1F] (used reg = )
mov	al,#$86
mov	$21[bp],al
!BCC_EOS
! 3192       break;
jmp .410
!BCC_EOS
! 3193     }
! 3194 }
jmp .410
.412:
sub	al,#$86
beq 	.413
sub	al,*$62
beq 	.414
jmp	.435
.410:
..FFF5	=	-$10
..FFF4	=	-$10
mov	sp,bp
pop	bp
ret
! 3195   void
! Register BX used in function int15_function32
! 3196 int16_function(DI, SI, BP, SP, BX, DX, CX, AX, FLAGS)
! 3197   Bit16u DI, SI, BP, SP, BX, DX, CX, AX, FLAGS;
export	_int16_function
_int16_function:
!BCC_EOS
! 3198 {
! 3199   Bit8u scan_code, ascii_code, shift_flags, led_flags, count;
!BCC_EOS
! 3200   Bit16u kbd_code, max;
!BCC_EOS
! 3201   ;
push	bp
mov	bp,sp
add	sp,*-$A
!BCC_EOS
! 3202   shift_flags = read_byte(0x0040, 0x17);
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3203   led_flags = read_byte(0x0040, 0x97);
! Debug: list int = const $97 (used reg = )
mov	ax,#$97
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3204   if ((((shift_flags >> 4) & 0x07) ^ (led_flags & 0x07)) != 0) {
! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
mov	al,-4[bp]
and	al,*7
push	ax
! Debug: sr int = const 4 to unsigned char shift_flags = [S+$E-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
and	al,*7
! Debug: eor unsigned char (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
xor	al,-$C[bp]
inc	sp
inc	sp
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
beq 	.437
.438:
! 3205 #asm
!BCC_EOS
!BCC_ASM
_int16_function.BP	set	$12
.int16_function.BP	set	8
_int16_function.count	set	5
.int16_function.count	set	-5
_int16_function.CX	set	$1A
.int16_function.CX	set	$10
_int16_function.ascii_code	set	8
.int16_function.ascii_code	set	-2
_int16_function.DI	set	$E
.int16_function.DI	set	4
_int16_function.FLAGS	set	$1E
.int16_function.FLAGS	set	$14
_int16_function.kbd_code	set	2
.int16_function.kbd_code	set	-8
_int16_function.scan_code	set	9
.int16_function.scan_code	set	-1
_int16_function.DX	set	$18
.int16_function.DX	set	$E
_int16_function.led_flags	set	6
.int16_function.led_flags	set	-4
_int16_function.SI	set	$10
.int16_function.SI	set	6
_int16_function.AX	set	$1C
.int16_function.AX	set	$12
_int16_function.SP	set	$14
.int16_function.SP	set	$A
_int16_function.BX	set	$16
.int16_function.BX	set	$C
_int16_function.shift_flags	set	7
.int16_function.shift_flags	set	-3
_int16_function.max	set	0
.int16_function.max	set	-$A
    cli
! 3207 endasm
!BCC_ENDASM
!BCC_EOS
! 3208     outb(0x60, 0xed);
! Debug: list int = const $ED (used reg = )
mov	ax,#$ED
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3209     while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
jmp .43A
.43B:
! Debug: list int = const $21 (used reg = )
mov	ax,*$21
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3210     if ((inb(0x60) == 0xfa)) {
.43A:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je 	.43B
.43C:
.439:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
jne 	.43D
.43E:
! 3211       led_flags &= 0xf8;
! Debug: andab int = const $F8 to unsigned char led_flags = [S+$C-6] (used reg = )
mov	al,-4[bp]
and	al,#$F8
mov	-4[bp],al
!BCC_EOS
! 3212       led_flags |= ((shift_flags >> 4) & 0x07);
! Debug: sr int = const 4 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
and	al,*7
! Debug: orab unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
or	al,-4[bp]
mov	-4[bp],al
!BCC_EOS
! 3213       outb(0x60, led_flags & 0x07);
! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
mov	al,-4[bp]
and	al,*7
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3214       while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
jmp .440
.441:
! Debug: list int = const $21 (used reg = )
mov	ax,*$21
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3215       inb(0x60);
.440:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je 	.441
.442:
.43F:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
!BCC_EOS
! 3216       write_byte(0x0040, 0x97, led_flags);
! Debug: list unsigned char led_flags = [S+$C-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $97 (used reg = )
mov	ax,#$97
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3217     }
! 3218 #asm
.43D:
!BCC_EOS
!BCC_ASM
_int16_function.BP	set	$12
.int16_function.BP	set	8
_int16_function.count	set	5
.int16_function.count	set	-5
_int16_function.CX	set	$1A
.int16_function.CX	set	$10
_int16_function.ascii_code	set	8
.int16_function.ascii_code	set	-2
_int16_function.DI	set	$E
.int16_function.DI	set	4
_int16_function.FLAGS	set	$1E
.int16_function.FLAGS	set	$14
_int16_function.kbd_code	set	2
.int16_function.kbd_code	set	-8
_int16_function.scan_code	set	9
.int16_function.scan_code	set	-1
_int16_function.DX	set	$18
.int16_function.DX	set	$E
_int16_function.led_flags	set	6
.int16_function.led_flags	set	-4
_int16_function.SI	set	$10
.int16_function.SI	set	6
_int16_function.AX	set	$1C
.int16_function.AX	set	$12
_int16_function.SP	set	$14
.int16_function.SP	set	$A
_int16_function.BX	set	$16
.int16_function.BX	set	$C
_int16_function.shift_flags	set	7
.int16_function.shift_flags	set	-3
_int16_function.max	set	0
.int16_function.max	set	-$A
    sti
! 3220 endasm
!BCC_ENDASM
!BCC_EOS
! 3221   }
! 3222   switch (( AX >> 8 )) {
.437:
! Debug: sr int = const 8 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
br 	.445
! 3223     case 0x00:
! 3224       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
.446:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
lea	bx,-2[bp]
push	bx
! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
lea	bx,-1[bp]
push	bx
! Debug: func () unsigned int = dequeue_key+0 (used reg = )
call	_dequeue_key
add	sp,*6
test	ax,ax
jne 	.447
.448:
! 3225         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
! Debug: list * char = .449+0 (used reg = )
mov	bx,#.449
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 3226       }
! 3227       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
.447:
! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
test	al,al
je  	.44A
.44C:
! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$F0
jne 	.44A
.44B:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3228       else if (ascii_code == 0xE0) ascii_code = 0;
jmp .44D
.44A:
! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$E0
jne 	.44E
.44F:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3229       AX = (scan_code << 8) | ascii_code;
.44E:
.44D:
! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
or	al,-2[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3230       break;
br 	.443
!BCC_EOS
! 3231     case 0x01:
! 3232       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
.450:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
lea	bx,-2[bp]
push	bx
! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
lea	bx,-1[bp]
push	bx
! Debug: func () unsigned int = dequeue_key+0 (used reg = )
call	_dequeue_key
add	sp,*6
test	ax,ax
jne 	.451
.452:
! 3233         FLAGS |= 0x0040;
! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
mov	ax,$14[bp]
or	al,*$40
mov	$14[bp],ax
!BCC_EOS
! 3234         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3235       }
! 3236       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
.451:
! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
test	al,al
je  	.453
.455:
! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$F0
jne 	.453
.454:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3237       else if (ascii_code == 0xE0) ascii_code = 0;
jmp .456
.453:
! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$E0
jne 	.457
.458:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3238       AX = (scan_code << 8) | ascii_code;
.457:
.456:
! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
or	al,-2[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3239       FLAGS &= 0xffbf;
! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
mov	ax,$14[bp]
and	al,#$BF
mov	$14[bp],ax
!BCC_EOS
! 3240       break;
br 	.443
!BCC_EOS
! 3241     case 0x02:
! 3242       shift_flags = 
.459:
! 3242 read_byte(0x0040, 0x17);
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3243       AX = ((AX & 0xff00) | (shift_flags));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
or	al,-3[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3244       break;
br 	.443
!BCC_EOS
! 3245     case 0x05:
! 3246       if ( !enqueue_key(( CX >> 8 ), ( CX & 0x00ff )) ) {
.45A:
! Debug: and int = const $FF to unsigned short CX = [S+$C+$E] (used reg = )
mov	al,$10[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short CX = [S+$E+$E] (used reg = )
mov	ax,$10[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: func () unsigned int = enqueue_key+0 (used reg = )
call	_enqueue_key
add	sp,*4
test	ax,ax
jne 	.45B
.45C:
! 3247         AX = ((AX & 0xff00) | (1));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
or	al,*1
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3248       }
! 3249       else {
jmp .45D
.45B:
! 3250         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3251       }
! 3252       break;
.45D:
br 	.443
!BCC_EOS
! 3253     case 0x09:
! 3254       AX = ((AX & 0xff00) | (0x30));
.45E:
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or int = const $30 to unsigned int = ax+0 (used reg = )
or	al,*$30
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3255       break;
br 	.443
!BCC_EOS
! 3256     case 0x0A:
! 3257       count = 2;
.45F:
! Debug: eq int = const 2 to unsigned char count = [S+$C-7] (used reg = )
mov	al,*2
mov	-5[bp],al
!BCC_EOS
! 3258       kbd_code = 0x0;
! Debug: eq int = const 0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
xor	ax,ax
mov	-8[bp],ax
!BCC_EOS
! 3259       outb(0x60, 0xf2);
! Debug: list int = const $F2 (used reg = )
mov	ax,#$F2
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3260       max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
mov	ax,#$FFFF
mov	-$A[bp],ax
!BCC_EOS
! 3261       while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
jmp .461
.462:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3262       if (max>0x0) {
.461:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.463
.464:
! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
mov	ax,-$A[bp]
dec	ax
mov	-$A[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.462
.463:
.460:
! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
mov	ax,-$A[bp]
test	ax,ax
je  	.465
.466:
! 3263         if ((inb(0x60) == 0xfa)) {
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
jne 	.467
.468:
! 3264           do {
.46B:
! 3265             max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
mov	ax,#$FFFF
mov	-$A[bp],ax
!BCC_EOS
! 3266             while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
jmp .46D
.46E:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3267             if (max>0x0) {
.46D:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.46F
.470:
! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
mov	ax,-$A[bp]
dec	ax
mov	-$A[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.46E
.46F:
.46C:
! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
mov	ax,-$A[bp]
test	ax,ax
je  	.471
.472:
! 3268               kbd_code >>= 8;
! Debug: srab int = const 8 to unsigned short kbd_code = [S+$C-$A] (used reg = )
mov	ax,-8[bp]
mov	al,ah
xor	ah,ah
mov	-8[bp],ax
!BCC_EOS
! 3269               kbd_code |= (inb(0x60) << 8);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: orab unsigned int = ax+0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
or	ax,-8[bp]
mov	-8[bp],ax
!BCC_EOS
! 3270             }
! 3271           } while (--count>0);
.471:
.46A:
! Debug: predec unsigned char count = [S+$C-7] (used reg = )
mov	al,-5[bp]
dec	ax
mov	-5[bp],al
! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne	.46B
.473:
!BCC_EOS
! 3272         }
.469:
! 3273       }
.467:
! 3274       BX=kbd_code;
.465:
! Debug: eq unsigned short kbd_code = [S+$C-$A] to unsigned short BX = [S+$C+$A] (used reg = )
mov	ax,-8[bp]
mov	$C[bp],ax
!BCC_EOS
! 3275       break;
br 	.443
!BCC_EOS
! 3276     case 0x10:
! 3277       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
.474:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
lea	bx,-2[bp]
push	bx
! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
lea	bx,-1[bp]
push	bx
! Debug: func () unsigned int = dequeue_key+0 (used reg = )
call	_dequeue_key
add	sp,*6
test	ax,ax
jne 	.475
.476:
! 3278         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
! Debug: list * char = .477+0 (used reg = )
mov	bx,#.477
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 3279       }
! 3280       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
.475:
! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
test	al,al
je  	.478
.47A:
! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$F0
jne 	.478
.479:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3281       AX = (scan_code << 8) | ascii_code;
.478:
! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
or	al,-2[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3282       break;
br 	.443
!BCC_EOS
! 3283     case 0x11:
! 3284       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
.47B:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
lea	bx,-2[bp]
push	bx
! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
lea	bx,-1[bp]
push	bx
! Debug: func () unsigned int = dequeue_key+0 (used reg = )
call	_dequeue_key
add	sp,*6
test	ax,ax
jne 	.47C
.47D:
! 3285         FLAGS |= 0x0040;
! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
mov	ax,$14[bp]
or	al,*$40
mov	$14[bp],ax
!BCC_EOS
! 3286         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3287       }
! 3288       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
.47C:
! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
test	al,al
je  	.47E
.480:
! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$F0
jne 	.47E
.47F:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3289       AX = (scan_code << 8) | ascii_code;
.47E:
! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
or	al,-2[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3290       FLAGS &= 0xffbf;
! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
mov	ax,$14[bp]
and	al,#$BF
mov	$14[bp],ax
!BCC_EOS
! 3291       break;
br 	.443
!BCC_EOS
! 3292     case 0x12:
! 3293       shift_flags = read_byte(0x0040, 0x17);
.481:
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3294       AX = ((AX & 0xff00) | (shift_flags));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
or	al,-3[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3295       shift_flags = read_byte(0x0040, 0x18) & 0x73;
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $73 to unsigned char = al+0 (used reg = )
and	al,*$73
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3296       shift_flags |= read_byte(0x0040, 0x96) & 0x0c;
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $C to unsigned char = al+0 (used reg = )
and	al,*$C
! Debug: orab unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
or	al,-3[bp]
mov	-3[bp],al
!BCC_EOS
! 3297       AX = ((AX & 0x00ff) | ((shift_flags) << 8));
! Debug: sl int = const 8 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$E+$10] (used reg = )
mov	al,$12[bp]
! Debug: or unsigned int (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFF3[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3298       ;
!BCC_EOS
! 3299       break;
br 	.443
!BCC_EOS
! 3300     case 0x92:
! 3301       AX = ((AX & 0x00ff) | ((0x80) << 8));
.482:
! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3302       break;
jmp .443
!BCC_EOS
! 3303     case 0xA2:
! 3304       break;
.483:
jmp .443
!BCC_EOS
! 3305     case 0x6F:
! 3306       if (( AX & 0x00ff ) == 0x08)
.484:
! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
mov	al,$12[bp]
! Debug: logeq int = const 8 to unsigned char = al+0 (used reg = )
cmp	al,*8
jne 	.485
.486:
! 3307         AX = ((AX & 0x00ff) | ((0x02) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$200
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3308     default:
.485:
! 3309       bios_printf(4, "KBD: unsupported int 16h function %02x\n", ( AX >> 8 ));
.487:
! Debug: sr int = const 8 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .488+0 (used reg = )
mov	bx,#.488
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3310   }
! 3311 }
jmp .443
.445:
sub	ax,*0
jl 	.487
cmp	ax,*$12
ja  	.489
shl	ax,*1
mov	bx,ax
seg	cs
br	.48A[bx]
.48A:
.word	.446
.word	.450
.word	.459
.word	.487
.word	.487
.word	.45A
.word	.487
.word	.487
.word	.487
.word	.45E
.word	.45F
.word	.487
.word	.487
.word	.487
.word	.487
.word	.487
.word	.474
.word	.47B
.word	.481
.489:
sub	ax,*$6F
je 	.484
sub	ax,*$23
je 	.482
sub	ax,*$10
je 	.483
jmp	.487
.443:
..FFF3	=	-$C
mov	sp,bp
pop	bp
ret
! 3312   unsigned int
! Register BX used in function int16_function
! 3313 dequeue_key(scan_code, ascii_code, incr)
! 3314   Bit8u *sca
export	_dequeue_key
_dequeue_key:
! 3314 n_code;
!BCC_EOS
! 3315   Bit8u *ascii_code;
!BCC_EOS
! 3316   unsigned int incr;
!BCC_EOS
! 3317 {
! 3318   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail;
!BCC_EOS
! 3319   Bit16u ss;
!BCC_EOS
! 3320   Bit8u acode, scode;
!BCC_EOS
! 3321   buffer_start = read_word(0x0040, 0x0080);
push	bp
mov	bp,sp
add	sp,*-$C
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$E-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 3322   buffer_end = read_word(0x0040, 0x0082);
! Debug: list int = const $82 (used reg = )
mov	ax,#$82
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$E-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 3323   buffer_head = read_word(0x0040, 0x001a);
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 3324   buffer_tail = read_word(0x0040, 0x001c);
! Debug: list int = const $1C (used reg = )
mov	ax,*$1C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$E-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 3325   if (buffer_head != buffer_tail) {
! Debug: ne unsigned short buffer_tail = [S+$E-$A] to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-6[bp]
cmp	ax,-8[bp]
beq 	.48B
.48C:
! 3326     ss = get_SS();
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$E-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 3327     acode = read_byte(0x0040, buffer_head);
! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
push	-6[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char acode = [S+$E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 3328     scode = read_byte(0x0040, buffer_head+1);
! Debug: add int = const 1 to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char scode = [S+$E-$E] (used reg = )
mov	-$C[bp],al
!BCC_EOS
! 3329     write_byte(ss, ascii_code, acode);
! Debug: list unsigned char acode = [S+$E-$D] (used reg = )
mov	al,-$B[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char ascii_code = [S+$10+4] (used reg = )
push	6[bp]
! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3330     write_byte(ss, scan_code, scode);
! Debug: list unsigned char scode = [S+$E-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char scan_code = [S+$10+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3331     if (incr) {
mov	ax,8[bp]
test	ax,ax
je  	.48D
.48E:
! 3332       buffer_head += 2;
! Debug: addab int = const 2 to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-6[bp]
inc	ax
inc	ax
mov	-6[bp],ax
!BCC_EOS
! 3333       if (buffer_head >= buffer_end)
! Debug: ge unsigned short buffer_end = [S+$E-6] to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-6[bp]
cmp	ax,-4[bp]
jb  	.48F
.490:
! 3334         buffer_head = buffer_start;
! Debug: eq unsigned short buffer_start = [S+$E-4] to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-2[bp]
mov	-6[bp],ax
!BCC_EOS
! 3335       write_word(0x0040, 0x001a, buffer_head);
.48F:
! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
push	-6[bp]
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3336     }
! 3337     return(1);
.48D:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3338   }
! 3339   else {
jmp .491
.48B:
! 3340     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3341   }
! 3342 }
.491:
mov	sp,bp
pop	bp
ret
! 3343 static char panic_msg_keyb_buffer_full[] = "%s: keyboard input buffer full\n";
.data
_panic_msg_keyb_buffer_full:
.492:
.ascii	"%s: keyboard input buffer full"
.byte	$A
.byte	0
!BCC_EOS
! 3344   Bit8u
! 3345 inhibit_mouse_int_and_events()
! 3346 {
.text
export	_inhibit_mouse_int_and_events
_inhibit_mouse_int_and_events:
! 3347   Bit8u command_byte, prev_command_byte;
!BCC_EOS
! 3348   if ( inb(0x64) & 0x02 )
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.493
.494:
! 3349     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
! Debug: list * char = .495+0 (used reg = )
mov	bx,#.495
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3350   outb(0x64, 0x20);
.493:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3351   while ( (inb(0x64) & 0x01) != 0x01 );
jmp .497
.498:
!BCC_EOS
! 3352   prev_command_byte = inb(0x60);
.497:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
cmp	al,*1
jne	.498
.499:
.496:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char prev_command_byte = [S+4-4] (used reg = )
mov	-2[bp],al
!BCC_EOS
! 3353   command_byte = prev_command_byte;
! Debug: eq unsigned char prev_command_byte = [S+4-4] to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-2[bp]
mov	-1[bp],al
!BCC_EOS
! 3354   if ( inb(0x64) & 0x02 )
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.49A
.49B:
! 3355     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
! Debug: list * char = .49C+0 (used reg = )
mov	bx,#.49C
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3356   command_byte &= 0xfd;
.49A:
! Debug: andab int = const $FD to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$FD
mov	-1[bp],al
!BCC_EOS
! 3357   command_byte |= 0x20;
! Debug: orab int = const $20 to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
or	al,*$20
mov	-1[bp],al
!BCC_EOS
! 3358   outb(0x64, 0x60);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3359   outb(0x60, command_byte);
! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3360   return(prev_command_byte);
mov	al,-2[bp]
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3361 }
! 3362   void
! Register BX used in function inhibit_mouse_int_and_events
! 3363 enable_mouse_int_and_events()
! 3364 {
export	_enable_mouse_int_and_events
_enable_mouse_int_and_events:
! 3365   Bit8u command_byte;
!BCC_EOS
! 3366   if ( inb(0x64) & 0x02 )
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.49D
.49E:
! 3367     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
! Debug: list * char = .49F+0 (used reg = )
mov	bx,#.49F
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3368   outb(0x64, 0x20);
.49D:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3369   while ( (inb(0x64) & 0x01) != 0x01 );
jmp .4A1
.4A2:
!BCC_EOS
! 3370   command_byte = inb(0x60);
.4A1:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
cmp	al,*1
jne	.4A2
.4A3:
.4A0:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char command_byte = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3371   if ( inb(0x64) & 0x02 )
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.4A4
.4A5:
! 3372     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
! Debug: list * char = .4A6+0 (used reg = )
mov	bx,#.4A6
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3373   command_byte |= 0x02;
.4A4:
! Debug: orab int = const 2 to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
or	al,*2
mov	-1[bp],al
!BCC_EOS
! 3374   command_byte &= 0xdf;
! Debug: andab int = const $DF to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$DF
mov	-1[bp],al
!BCC_EOS
! 3375   outb(0x64, 0x60);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3376   outb(0x60, command_byte);
! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3377 }
mov	sp,bp
pop	bp
ret
! 3378   Bit8u
! Register BX used in function enable_mouse_int_and_events
! 3379 send_to_mouse_ctrl(sendbyte)
! 3380   Bit8u sendbyte;
export	_send_to_mouse_ctrl
_send_to_mouse_ctrl:
!BCC_EOS
! 3381 {
! 3382   Bit8u response;
!BCC_EOS
! 3383   if ( inb(0x64) & 0x02 )
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.4A7
.4A8:
! 3384     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"sendmouse");
! Debug: list * char = .4A9+0 (used reg = )
mov	bx,#.4A9
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3385   outb(0x64, 0xD4);
.4A7:
! Debug: list int = const $D4 (used reg = )
mov	ax,#$D4
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3386   outb(0x60, sendbyte);
! Debug: list unsigned char sendbyte = [S+4+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3387   return(0);
xor	al,al
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3388 }
! 3389   Bit8u
! Register BX used in function send_to_mouse_ctrl
! 3390 get
! 3390 _mouse_data(data)
! 3391   Bit8u *data;
export	_get_mouse_data
_get_mouse_data:
!BCC_EOS
! 3392 {
! 3393   Bit8u response;
!BCC_EOS
! 3394   Bit16u ss;
!BCC_EOS
! 3395   while ((inb(0x64) & 0x21) != 0x21) { }
push	bp
mov	bp,sp
add	sp,*-4
jmp .4AB
.4AC:
! 3396   response = inb(0x60);
.4AB:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const $21 to unsigned char = al+0 (used reg = )
and	al,*$21
! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
cmp	al,*$21
jne	.4AC
.4AD:
.4AA:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char response = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3397   ss = get_SS();
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 3398   write_byte(ss, data, response);
! Debug: list unsigned char response = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char data = [S+8+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ss = [S+$A-6] (used reg = )
push	-4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3399   return(0);
xor	al,al
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3400 }
! 3401   void
! 3402 set_kbd_command_byte(command_byte)
! 3403   Bit8u command_byte;
export	_set_kbd_command_byte
_set_kbd_command_byte:
!BCC_EOS
! 3404 {
! 3405   if ( inb(0x64) & 0x02 )
push	bp
mov	bp,sp
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
mov	sp,bp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.4AE
.4AF:
! 3406     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"setkbdcomm");
! Debug: list * char = .4B0+0 (used reg = )
mov	bx,#.4B0
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 3407   outb(0x64, 0xD4);
.4AE:
! Debug: list int = const $D4 (used reg = )
mov	ax,#$D4
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 3408   outb(0x64, 0x60);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 3409   outb(0x60, command_byte);
! Debug: list unsigned char command_byte = [S+2+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 3410 }
pop	bp
ret
! 3411   void
! Register BX used in function set_kbd_command_byte
! 3412 int09_function(DI, SI, BP, SP, BX, DX, CX, AX)
! 3413   Bit16u DI, SI, BP, SP, BX, DX, CX, AX;
export	_int09_function
_int09_function:
!BCC_EOS
! 3414 {
! 3415   Bit8u scancode, asciicode, shift_flags;
!BCC_EOS
! 3416   Bit8u mf2_flags, mf2_state;
!BCC_EOS
! 3417   scancode = ( AX & 0x00ff );
push	bp
mov	bp,sp
add	sp,*-6
! Debug: and int = const $FF to unsigned short AX = [S+8+$10] (used reg = )
mov	al,$12[bp]
! Debug: eq unsigned char = al+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3418   if (scancode == 0) {
! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.4B1
.4B2:
! 3419     bios_printf(4, "KBD: int09 handler: AL=0\n");
! Debug: list * char = .4B3+0 (used reg = )
mov	bx,#.4B3
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 3420     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3421   }
! 3422   shift_flags = read_byte(0x0040, 0x17);
.4B1:
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3423   mf2_flags = read_byte(0x0040, 0x18);
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3424   mf2_state = read_byte(0x0040, 0x96);
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 3425   asciicode = 0;
! Debug: eq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3426   switch (scancode) {
mov	al,-1[bp]
br 	.4B6
! 3427     case 0x3a:
! 3428       shift_flags ^= 0x40;
.4B7:
! Debug: eorab int = const $40 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	al,*$40
mov	-3[bp],al
!BCC_EOS
! 3429       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3430       mf2_flags |= 0x40;
! Debug: orab int = const $40 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*$40
mov	-4[bp],al
!BCC_EOS
! 3431       write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3432       break;
br 	.4B4
!BCC_EOS
! 3433     case 0xba:
! 3434       mf2_flags &= ~0x40;
.4B8:
! Debug: andab int = const -$41 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$BF
mov	-4[bp],al
!BCC_EOS
! 3435       write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3436       break;
br 	.4B4
!BCC_EOS
! 3437     case 0x2a:
! 3438       shift_flags |= 0x02;
.4B9:
! Debug: orab int = const 2 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
or	al,*2
mov	-3[bp],al
!BCC_EOS
! 3439       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3440       break;
br 	.4B4
!BCC_EOS
! 3441     case 0xaa:
! 3442       shift_flags &= ~0x02;
.4BA:
! Debug: andab int = const -3 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,#$FD
mov	-3[bp],al
!BCC_EOS
! 3443       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3444       break;
br 	.4B4
!BCC_EOS
! 3445     case 0x36:
! 3446       shift_flags |= 0x01;
.4BB:
! Debug: orab int = const 1 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
or	al,*1
mov	-3[bp],al
!BCC_EOS
! 3447       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3448       break;
br 	.4B4
!BCC_EOS
! 3449     case 0xb6:
! 3450       shift_flags &= ~0x01;
.4BC:
! Debug: andab int = const -2 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,#$FE
mov	-3[bp],al
!BCC_EOS
! 3451       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3452       break;
br 	.4B4
!BCC_EOS
! 3453     case 0x1d:
! 3454       if ((mf2_state & 0x01) == 0) {
.4BD:
! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.4BE
.4BF:
! 3455         shift_flags |= 0x04;
! Debug: orab int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
or	al,*4
mov	-3[bp],al
!BCC_EOS
! 3456         write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3457         if (mf2_state & 0x02) {
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
test	al,al
je  	.4C0
.4C1:
! 3458           mf2_state |= 0x04;
! Debug: orab int = const 4 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
or	al,*4
mov	-5[bp],al
!BCC_EOS
! 3459           write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3460         } else {
jmp .4C2
.4C0:
! 3461           mf2_flags |= 0x01;
! Debug: orab int = const 1 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*1
mov	-4[bp],al
!BCC_EOS
! 3462           write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3463         }
! 3464       }
.4C2:
! 3465       break;
.4BE:
br 	.4B4
!BCC_EOS
! 3466     case 0x9d:
! 3467       if ((mf2_state & 0x01) == 0) {
.4C3:
! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.4C4
.4C5:
! 3468         shift_flags &= ~0x04;
! Debug: andab int = const -5 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,#$FB
mov	-3[bp],al
!BCC_EOS
! 3469         write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3470         if (mf2_
! 3470 state & 0x02) {
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
test	al,al
je  	.4C6
.4C7:
! 3471           mf2_state &= ~0x04;
! Debug: andab int = const -5 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FB
mov	-5[bp],al
!BCC_EOS
! 3472           write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3473         } else {
jmp .4C8
.4C6:
! 3474           mf2_flags &= ~0x01;
! Debug: andab int = const -2 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$FE
mov	-4[bp],al
!BCC_EOS
! 3475           write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3476         }
! 3477       }
.4C8:
! 3478       break;
.4C4:
br 	.4B4
!BCC_EOS
! 3479     case 0x38:
! 3480       shift_flags |= 0x08;
.4C9:
! Debug: orab int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
or	al,*8
mov	-3[bp],al
!BCC_EOS
! 3481       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3482       if (mf2_state & 0x02) {
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
test	al,al
je  	.4CA
.4CB:
! 3483         mf2_state |= 0x08;
! Debug: orab int = const 8 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
or	al,*8
mov	-5[bp],al
!BCC_EOS
! 3484         write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3485       } else {
jmp .4CC
.4CA:
! 3486         mf2_flags |= 0x02;
! Debug: orab int = const 2 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*2
mov	-4[bp],al
!BCC_EOS
! 3487         write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3488       }
! 3489       break;
.4CC:
br 	.4B4
!BCC_EOS
! 3490     case 0xb8:
! 3491       shift_flags &= ~0x08;
.4CD:
! Debug: andab int = const -9 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,#$F7
mov	-3[bp],al
!BCC_EOS
! 3492       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3493       if (mf2_state & 0x02) {
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
test	al,al
je  	.4CE
.4CF:
! 3494         mf2_state &= ~0x08;
! Debug: andab int = const -9 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$F7
mov	-5[bp],al
!BCC_EOS
! 3495         write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3496       } else {
jmp .4D0
.4CE:
! 3497         mf2_flags &= ~0x02;
! Debug: andab int = const -3 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$FD
mov	-4[bp],al
!BCC_EOS
! 3498         write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3499       }
! 3500       break;
.4D0:
br 	.4B4
!BCC_EOS
! 3501     case 0x45:
! 3502       if ((mf2_state & 0x03) == 0) {
.4D1:
! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*3
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.4D2
.4D3:
! 3503         mf2_flags |= 0x20;
! Debug: orab int = const $20 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*$20
mov	-4[bp],al
!BCC_EOS
! 3504         write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3505         shift_flags ^= 0x20;
! Debug: eorab int = const $20 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	al,*$20
mov	-3[bp],al
!BCC_EOS
! 3506         write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3507       }
! 3508       break;
.4D2:
br 	.4B4
!BCC_EOS
! 3509     case 0xc5:
! 3510       if ((mf2_state & 0x03) == 0) {
.4D4:
! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*3
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.4D5
.4D6:
! 3511         mf2_flags &= ~0x20;
! Debug: andab int = const -$21 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$DF
mov	-4[bp],al
!BCC_EOS
! 3512         write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3513       }
! 3514       break;
.4D5:
br 	.4B4
!BCC_EOS
! 3515     case 0x46:
! 3516       mf2_flags |= 0x10;
.4D7:
! Debug: orab int = const $10 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*$10
mov	-4[bp],al
!BCC_EOS
! 3517       write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3518       shift_flags ^= 0x10;
! Debug: eorab int = const $10 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	al,*$10
mov	-3[bp],al
!BCC_EOS
! 3519       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3520       break;
br 	.4B4
!BCC_EOS
! 3521     case 0xc6:
! 3522       mf2_flags &= ~0x10;
.4D8:
! Debug: andab int = const -$11 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$EF
mov	-4[bp],al
!BCC_EOS
! 3523       write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3524       break;
br 	.4B4
!BCC_EOS
! 3525     default:
! 3526       if (scancode & 0x80) {
.4D9:
! Debug: and int = const $80 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
and	al,#$80
test	al,al
je  	.4DA
.4DB:
! 3527         break;
br 	.4B4
!BCC_EOS
! 3528       }
! 3529       if (scancode > 0x58) {
.4DA:
! Debug: gt int = const $58 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$58
jbe 	.4DC
.4DD:
! 3530         bios_printf(4, "KBD: int09h_handler(): unknown scancode read: 0x%02x!\n", scancode);
! Debug: list unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list * char = .4DE+0 (used reg = )
mov	bx,#.4DE
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3531         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3532       }
! 3533       if (shift_flags & 0x08) {
.4DC:
! Debug: and int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,*8
test	al,al
je  	.4DF
.4E0:
! 3534         asciicode = scan_to_scanascii[scancode].alt;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: eq unsigned short = [bx+6] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,6[bx]
mov	-2[bp],al
!BCC_EOS
! 3535         scancode = scan_to_scanascii[scancode].alt >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: sr int = const 8 to unsigned short = [bx+6] (used reg = )
mov	ax,6[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3536       } else if (shift_flags & 0x04) {
br 	.4E1
.4DF:
! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,*4
test	al,al
je  	.4E2
.4E3:
! 3537         asciicode = scan_to_scanascii[scancode].control;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: eq unsigned short = [bx+4] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,4[bx]
mov	-2[bp],al
!BCC_EOS
! 3538         scancode = scan_to_scanascii[scancode].control >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: sr int = const 8 to unsigned short = [bx+4] (used reg = )
mov	ax,4[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3539       } else if (((mf2_state & 0x02) > 0) && ((scancode >= 0x47) && (scancode <= 0x53))) {
br 	.4E4
.4E2:
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.4E5
.4E7:
! Debug: ge int = const $47 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$47
jb  	.4E5
.4E8:
! Debug: le int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$53
ja  	.4E5
.4E6:
! 3540 
! 3540         asciicode = 0xe0;
! Debug: eq int = const $E0 to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,#$E0
mov	-2[bp],al
!BCC_EOS
! 3541         scancode = scan_to_scanascii[scancode].normal >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
mov	ax,_scan_to_scanascii[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3542       } else if (shift_flags & 0x03) {
br 	.4E9
.4E5:
! Debug: and int = const 3 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,*3
test	al,al
beq 	.4EA
.4EB:
! 3543         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,8[bx]
test	al,al
je  	.4EC
.4ED:
! 3544           asciicode = scan_to_scanascii[scancode].normal;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,_scan_to_scanascii[bx]
mov	-2[bp],al
!BCC_EOS
! 3545           scancode = scan_to_scanascii[scancode].normal >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
mov	ax,_scan_to_scanascii[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3546         } else {
jmp .4EE
.4EC:
! 3547           asciicode = scan_to_scanascii[scancode].shift;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,2[bx]
mov	-2[bp],al
!BCC_EOS
! 3548           scancode = scan_to_scanascii[scancode].shift >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
mov	ax,2[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3549         }
! 3550       } else {
.4EE:
br 	.4EF
.4EA:
! 3551         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,8[bx]
test	al,al
je  	.4F0
.4F1:
! 3552           asciicode = scan_to_scanascii[scancode].shift;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,2[bx]
mov	-2[bp],al
!BCC_EOS
! 3553           scancode = scan_to_scanascii[scancode].shift >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
mov	ax,2[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3554         } else {
jmp .4F2
.4F0:
! 3555           asciicode = scan_to_scanascii[scancode].normal;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,_scan_to_scanascii[bx]
mov	-2[bp],al
!BCC_EOS
! 3556           scancode = scan_to_scanascii[scancode].normal >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
mov	ax,_scan_to_scanascii[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3557         }
! 3558       }
.4F2:
! 3559       if (scancode==0 && asciicode==0) {
.4EF:
.4E9:
.4E4:
.4E1:
! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.4F3
.4F5:
! Debug: logeq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,-2[bp]
test	al,al
jne 	.4F3
.4F4:
! 3560         bios_printf(4, "KBD: int09h_handler(): scancode & asciicode are zero?\n");
! Debug: list * char = .4F6+0 (used reg = )
mov	bx,#.4F6
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 3561       }
! 3562       enqueue_key(scancode, asciicode);
.4F3:
! Debug: list unsigned char asciicode = [S+8-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char scancode = [S+$A-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned int = enqueue_key+0 (used reg = )
call	_enqueue_key
add	sp,*4
!BCC_EOS
! 3563       break;
jmp .4B4
!BCC_EOS
! 3564   }
! 3565   if ((scancode & 0x7f) != 0x1d) {
jmp .4B4
.4B6:
sub	al,*$1D
beq 	.4BD
sub	al,*$D
beq 	.4B9
sub	al,*$C
beq 	.4BB
sub	al,*2
beq 	.4C9
sub	al,*2
beq 	.4B7
sub	al,*$B
beq 	.4D1
sub	al,*1
beq 	.4D7
sub	al,*$57
beq 	.4C3
sub	al,*$D
beq 	.4BA
sub	al,*$C
beq 	.4BC
sub	al,*2
beq 	.4CD
sub	al,*2
beq 	.4B8
sub	al,*$B
beq 	.4D4
sub	al,*1
beq 	.4D8
br 	.4D9
.4B4:
..FFF2	=	-8
! Debug: and int = const $7F to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
! Debug: ne int = const $1D to unsigned char = al+0 (used reg = )
cmp	al,*$1D
je  	.4F7
.4F8:
! 3566     mf2_state &= ~0x01;
! Debug: andab int = const -2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FE
mov	-5[bp],al
!BCC_EOS
! 3567   }
! 3568   mf2_state &= ~0x02;
.4F7:
! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FD
mov	-5[bp],al
!BCC_EOS
! 3569   write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3570 }
mov	sp,bp
pop	bp
ret
! 3571   unsigned int
! Register BX used in function int09_function
! 3572 enqueue_key(scan_code, ascii_code)
! 3573   Bit8u scan_code, ascii_code;
export	_enqueue_key
_enqueue_key:
!BCC_EOS
! 3574 {
! 3575   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail, temp_tail;
!BCC_EOS
! 3576   buffer_start = read_word(0x0040, 0x0080);
push	bp
mov	bp,sp
add	sp,*-$A
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$C-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 3577   buffer_end = read_word(0x0040, 0x0082);
! Debug: list int = const $82 (used reg = )
mov	ax,#$82
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$C-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 3578   buffer_head = read_word(0x0040, 0x001A);
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$C-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 3579   buffer_tail = read_word(0x0040, 0x001C);
! Debug: list int = const $1C (used reg = )
mov	ax,*$1C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 3580   temp_tail = buffer_tail;
! Debug: eq unsigned short buffer_tail = [S+$C-$A] to unsigned short temp_tail = [S+$C-$C] (used reg = )
mov	ax,-8[bp]
mov	-$A[bp],ax
!BCC_EOS
! 3581   buffer_tail += 2;
! Debug: addab int = const 2 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	ax,-8[bp]
inc	ax
inc	ax
mov	-8[bp],ax
!BCC_EOS
! 3582   if (buffer_tail >= buffer_end)
! Debug: ge unsigned short buffer_end = [S+$C-6] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-4[bp]
jb  	.4F9
.4FA:
! 3583     buffer_tail = buffer_start;
! Debug: eq unsigned short buffer_start = [S+$C-4] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	ax,-2[bp]
mov	-8[bp],ax
!BCC_EOS
! 3584   if (buffer_tail == buffer_head) {
.4F9:
! Debug: logeq unsigned short buffer_head = [S+$C-8] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-6[bp]
jne 	.4FB
.4FC:
! 3585     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3586   }
! 3587   write_byte(0x0040, temp_tail, ascii_code);
.4FB:
! Debug: list unsigned char ascii_code = [S+$C+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short temp_tail = [S+$E-$C] (used reg = )
push	-$A[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3588   write_byte(0x0040, temp_tail+1, scan_code);
! Debug: list unsigned char scan_code = [S+$C+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: add int = const 1 to unsigned short temp_tail = [S+$E-$C] (used reg = )
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3589   write_word(0x0040, 0x001C, buffer_tail);
! Debug: list unsigned short buffer_tail = [S+$C-$A] (used reg = )
push	-8[bp]
! Debug: list int = const $1C (used reg = )
mov	ax,*$1C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3590   return(1);
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3591 }
! 3592   void
! 3593 int74_function(make_farcall, Z, Y, X, status)
! 3594   Bit16u make_farcall, Z, Y, X, status;
export	_int74_function
_int74_function:
!BCC_EOS
! 3595 {
! 3596   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 3597   Bit8u in_byte, index, package_count;
!BCC_EOS
! 3598   Bit8u mouse_flags_1, mouse_flags_2;
!BCC_EOS
! 3599 ;
add	sp,*-6
!BCC_EOS
! 3600   make_farcall = 0;
! Debug: eq int = const 0 to unsigned short make_farcall = [S+$A+2] (used reg = )
xor	ax,ax
mov	4[bp],ax
!BCC_EOS
! 3601   in_byte = inb(0x64);
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3602   if ((in_byte 
! 3602 & 0x21) != 0x21) {
! Debug: and int = const $21 to unsigned char in_byte = [S+$A-5] (used reg = )
mov	al,-3[bp]
and	al,*$21
! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
cmp	al,*$21
je  	.4FD
.4FE:
! 3603     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3604   }
! 3605   in_byte = inb(0x60);
.4FD:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3606 ;
!BCC_EOS
! 3607   mouse_flags_1 = read_byte(ebda_seg, 0x0026);
! Debug: list int = const $26 (used reg = )
mov	ax,*$26
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
mov	-6[bp],al
!BCC_EOS
! 3608   mouse_flags_2 = read_byte(ebda_seg, 0x0027);
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 3609   if ((mouse_flags_2 & 0x80) != 0x80) {
! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
mov	al,-7[bp]
and	al,#$80
! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
cmp	al,#$80
je  	.4FF
.500:
! 3610       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3611   }
! 3612   package_count = mouse_flags_2 & 0x07;
.4FF:
! Debug: and int = const 7 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
mov	al,-7[bp]
and	al,*7
! Debug: eq unsigned char = al+0 to unsigned char package_count = [S+$A-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 3613   index = mouse_flags_1 & 0x07;
! Debug: and int = const 7 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
mov	al,-6[bp]
and	al,*7
! Debug: eq unsigned char = al+0 to unsigned char index = [S+$A-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3614   write_byte(ebda_seg, 0x28 + index, in_byte);
! Debug: list unsigned char in_byte = [S+$A-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: add unsigned char index = [S+$C-6] to int = const $28 (used reg = )
! Debug: expression subtree swapping
mov	al,-4[bp]
xor	ah,ah
! Debug: list unsigned int = ax+$28 (used reg = )
add	ax,*$28
push	ax
! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3615   if ( (index+1) >= package_count ) {
! Debug: add int = const 1 to unsigned char index = [S+$A-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
! Debug: ge unsigned char package_count = [S+$A-7] to unsigned int = ax+1 (used reg = )
inc	ax
push	ax
mov	al,-5[bp]
xor	ah,ah
cmp	ax,-$A[bp]
lea	sp,-8[bp]
ja  	.501
.502:
! 3616 ;
!BCC_EOS
! 3617     status = read_byte(ebda_seg, 0x0028 + 0);
! Debug: list int = const $28 (used reg = )
mov	ax,*$28
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned short status = [S+$A+$A] (used reg = )
xor	ah,ah
mov	$C[bp],ax
!BCC_EOS
! 3618     X = read_byte(ebda_seg, 0x0028 + 1);
! Debug: list int = const $29 (used reg = )
mov	ax,*$29
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned short X = [S+$A+8] (used reg = )
xor	ah,ah
mov	$A[bp],ax
!BCC_EOS
! 3619     Y = read_byte(ebda_seg, 0x0028 + 2);
! Debug: list int = const $2A (used reg = )
mov	ax,*$2A
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned short Y = [S+$A+6] (used reg = )
xor	ah,ah
mov	8[bp],ax
!BCC_EOS
! 3620     Z = 0;
! Debug: eq int = const 0 to unsigned short Z = [S+$A+4] (used reg = )
xor	ax,ax
mov	6[bp],ax
!BCC_EOS
! 3621     mouse_flags_1 = 0;
! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 3622     if (mouse_flags_2 & 0x80)
! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
mov	al,-7[bp]
and	al,#$80
test	al,al
je  	.503
.504:
! 3623       make_farcall = 1;
! Debug: eq int = const 1 to unsigned short make_farcall = [S+$A+2] (used reg = )
mov	ax,*1
mov	4[bp],ax
!BCC_EOS
! 3624     }
.503:
! 3625   else {
jmp .505
.501:
! 3626     mouse_flags_1++;
! Debug: postinc unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
mov	al,-6[bp]
inc	ax
mov	-6[bp],al
!BCC_EOS
! 3627   }
! 3628   write_byte(ebda_seg, 0x0026, mouse_flags_1);
.505:
! Debug: list unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
mov	al,-6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $26 (used reg = )
mov	ax,*$26
push	ax
! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3629 }
mov	sp,bp
pop	bp
ret
! 3630   void
! 3631 int13_harddisk(EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
! 3632   Bit16u EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_harddisk
_int13_harddisk:
!BCC_EOS
! 3633 {
! 3634   Bit32u lba_low, lba_high;
!BCC_EOS
! 3635   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
add	sp,*-$A
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$C-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 3636   Bit16u cylinder, head, sector;
!BCC_EOS
! 3637   Bit16u segment, offset;
!BCC_EOS
! 3638   Bit16u npc, nph, npspt, nlc, nlh, nlspt;
!BCC_EOS
! 3639   Bit16u size, count;
!BCC_EOS
! 3640   Bit8u device, status;
!BCC_EOS
! 3641   ;
add	sp,*-$1C
!BCC_EOS
! 3642   write_byte(0x0040, 0x008e, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $8E (used reg = )
mov	ax,#$8E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3643   if ( (( ELDX & 0x00ff ) < 0x80) || (( ELDX & 0x00ff ) >= 0x80 + (4*2)) ) {
! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
mov	al,$10[bp]
! Debug: lt int = const $80 to unsigned char = al+0 (used reg = )
cmp	al,#$80
jb  	.507
.508:
! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
mov	al,$10[bp]
! Debug: ge int = const $88 to unsigned char = al+0 (used reg = )
cmp	al,#$88
jb  	.506
.507:
! 3644     bios_printf(4, "int13_harddisk: function %02x, ELDL out of range %02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
mov	al,$10[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .509+0 (used reg = )
mov	bx,#.509
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3645     goto int13_fail;
add	sp,#..FFF1+$28
br 	.FFF1
!BCC_EOS
! 3646   }
! 3647   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[( ELDX & 0x00ff )-0x80]);
.506:
! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
mov	al,$10[bp]
! Debug: sub int = const $80 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: ptradd unsigned int = ax-$80 to [8] unsigned char = const $233 (used reg = )
add	ax,*-$80
mov	bx,ax
! Debug: address unsigned char = [bx+$233] (used reg = )
! Debug: list * unsigned char = bx+$233 (used reg = )
add	bx,#$233
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char device = [S+$28-$27] (used reg = )
mov	-$25[bp],al
!BCC_EOS
! 3648   if (device >= (4*2)) {
! Debug: ge int = const 8 to unsigned char device = [S+$28-$27] (used reg = )
mov	al,-$25[bp]
cmp	al,*8
jb  	.50A
.50B:
! 3649     bios_printf(4, "int13_harddisk: function %02x, unmapped device for ELDL=%02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
mov	al,$10[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .50C+0 (used reg = )
mov	bx,#.50C
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3650     goto int13_fail;
add	sp,#..FFF1+$28
br 	.FFF1
!BCC_EOS
! 3651   }
! 3652   switch (( AX >> 8 )) {
.50A:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
br 	.50F
! 3653     case 0x00:
! 3654       ata_reset (device);
.510:
! Debug: list unsigned char device = [S+$28-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () void = ata_reset+0 (used reg = )
call	_ata_reset
inc	sp
inc	sp
!BCC_EOS
! 3655       goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3656       break;
br 	.50D
!BCC_EOS
! 3657     case 0x01:
! 3658       status = read_byte(0x0040, 0x0074);
.511:
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3659       AX = ((AX & 0x00ff) | ((status) << 8));
! Debug: sl int = const 8 to unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$2A+$16] (used reg = )
mov	al,$18[bp]
! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3660       write_byte(0x0040, 0x0074, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3661       if (status) goto int13_fail_nostatus;
mov	al,-$26[bp]
test	al,al
je  	.512
.513:
add	sp,#..FFEE-..FFF0
br 	.FFEE
!BCC_EOS
! 3662       else goto int13_success_noah;
jmp .514
.512:
add	sp,#..FFED-..FFF0
br 	.FFED
!BCC_EOS
! 3663       break;
.514:
br 	.50D
!BCC_EOS
! 3664     case 0x02:
! 3665     case 0x03:
.515:
! 3666     case 0x04:
.516:
! 3667       count = ( AX & 0x00ff );
.517:
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
xor	ah,ah
mov	-$24[bp],ax
!BCC_EOS
! 3668       cylinder = ( CX >> 8 );
! Debug: sr int = const 8 to unsigned short CX = [S+$28+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 3669       cylinder |= ( ((Bit16u) ( CX & 0x00ff
! 3669  )) << 2) & 0x300;
! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
mov	al,$16[bp]
! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: sl int = const 2 to unsigned short = ax+0 (used reg = )
shl	ax,*1
shl	ax,*1
! Debug: and int = const $300 to unsigned int = ax+0 (used reg = )
and	ax,#$300
! Debug: orab unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
or	ax,-$C[bp]
mov	-$C[bp],ax
!BCC_EOS
! 3670       sector = (( CX & 0x00ff ) & 0x3f);
! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
mov	al,$16[bp]
! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
and	al,*$3F
! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$28-$12] (used reg = )
xor	ah,ah
mov	-$10[bp],ax
!BCC_EOS
! 3671       head = ( DX >> 8 );
! Debug: sr int = const 8 to unsigned short DX = [S+$28+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$28-$10] (used reg = )
mov	-$E[bp],ax
!BCC_EOS
! 3672       segment = ES;
! Debug: eq unsigned short ES = [S+$28+6] to unsigned short segment = [S+$28-$14] (used reg = )
mov	ax,8[bp]
mov	-$12[bp],ax
!BCC_EOS
! 3673       offset = BX;
! Debug: eq unsigned short BX = [S+$28+$10] to unsigned short offset = [S+$28-$16] (used reg = )
mov	ax,$12[bp]
mov	-$14[bp],ax
!BCC_EOS
! 3674       if ((count > 128) || (count == 0) || (sector == 0)) {
! Debug: gt int = const $80 to unsigned short count = [S+$28-$26] (used reg = )
mov	ax,-$24[bp]
cmp	ax,#$80
ja  	.519
.51B:
! Debug: logeq int = const 0 to unsigned short count = [S+$28-$26] (used reg = )
mov	ax,-$24[bp]
test	ax,ax
je  	.519
.51A:
! Debug: logeq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
mov	ax,-$10[bp]
test	ax,ax
jne 	.518
.519:
! 3675         bios_printf(4, "int13_harddisk: function %02x, parameter out of range!\n",( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .51C+0 (used reg = )
mov	bx,#.51C
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3676         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3677       }
! 3678       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
.518:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	-$1C[bp],ax
!BCC_EOS
! 3679       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 3680       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	-$20[bp],ax
!BCC_EOS
! 3681       if( (cylinder >= nlc) || (head >= nlh) || (sector > nlspt) ) {
! Debug: ge unsigned short nlc = [S+$28-$1E] to unsigned short cylinder = [S+$28-$E] (used reg = )
mov	ax,-$C[bp]
cmp	ax,-$1C[bp]
jae 	.51E
.520:
! Debug: ge unsigned short nlh = [S+$28-$20] to unsigned short head = [S+$28-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,-$1E[bp]
jae 	.51E
.51F:
! Debug: gt unsigned short nlspt = [S+$28-$22] to unsigned short sector = [S+$28-$12] (used reg = )
mov	ax,-$10[bp]
cmp	ax,-$20[bp]
jbe 	.51D
.51E:
! 3682         bios_printf(4, "int13_harddisk: function %02x, parameters out of range %04x/%04x/%04x!\n", ( AX >> 8 ), cylinder, head, sector);
! Debug: list unsigned short sector = [S+$28-$12] (used reg = )
push	-$10[bp]
! Debug: list unsigned short head = [S+$2A-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short cylinder = [S+$2C-$E] (used reg = )
push	-$C[bp]
! Debug: sr int = const 8 to unsigned short AX = [S+$2E+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .521+0 (used reg = )
mov	bx,#.521
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*$C
!BCC_EOS
! 3683         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3684       }
! 3685       if (( AX >> 8 ) == 0x04) goto int13_success;
.51D:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
cmp	ax,*4
jne 	.522
.523:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3686       nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
.522:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$152] (used reg = )
! Debug: list * unsigned short = bx+$152 (used reg = )
add	bx,#$152
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$28-$1A] (used reg = )
mov	-$18[bp],ax
!BCC_EOS
! 3687       npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$156] (used reg = )
! Debug: list * unsigned short = bx+$156 (used reg = )
add	bx,#$156
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$28-$1C] (used reg = )
mov	-$1A[bp],ax
!BCC_EOS
! 3688       if ( (nph != nlh) || (npspt != nlspt)) {
! Debug: ne unsigned short nlh = [S+$28-$20] to unsigned short nph = [S+$28-$1A] (used reg = )
mov	ax,-$18[bp]
cmp	ax,-$1E[bp]
jne 	.525
.526:
! Debug: ne unsigned short nlspt = [S+$28-$22] to unsigned short npspt = [S+$28-$1C] (used reg = )
mov	ax,-$1A[bp]
cmp	ax,-$20[bp]
je  	.524
.525:
! 3689         lba_low = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32u)sector - 1;
! Debug: cast unsigned long = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$2C-$22] (used reg = )
mov	ax,-$20[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short head = [S+$30-$10] (used reg = )
mov	ax,-$E[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$34-$20] (used reg = )
mov	ax,-$1E[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$38-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
! Debug: mul unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
lea	di,-$E+..FFF0[bp]
call	lmulul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
lea	di,-$A+..FFF0[bp]
call	laddul
add	sp,*4
! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
lea	di,-6+..FFF0[bp]
call	lmulul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFF0[bp]
call	laddul
add	sp,*4
! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFF0[bp]
mov	bx,0+..FFF0[bp]
lea	di,-6+..FFF0[bp]
call	lsubul
add	sp,*8
! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3690         lba_high = 0;
! Debug: eq int = const 0 to unsigned long lba_high = [S+$28-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 3691         sector = 0;
! Debug: eq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
xor	ax,ax
mov	-$10[bp],ax
!BCC_EOS
! 3692       }
! 3693       if (( AX >> 8 ) == 0x02)
.524:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const 2 to unsigned int = ax+0 (used reg = )
cmp	ax,*2
jne 	.527
.528:
! 3694         status=ata_cmd_data_in(device, 0x20, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
push	-$12[bp]
! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
push	-$10[bp]
! Debug: list unsigned short head = [S+$36-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
push	-$24[bp]
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
call	_ata_cmd_data_in
add	sp,*$18
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3695       else
! 3696         status=ata_cmd_data_out(device, 0x30, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
jmp .529
.527:
! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
push	-$12[bp]
! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
push	-$10[bp]
! Debug: list unsigned short head = [S+$36-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
push	-$24[bp]
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
call	_ata_cmd_data_out
add	sp,*$18
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3697       AX = ((AX & 0xff00) | (read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors)));
.529:
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$2A+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or unsigned short (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
or	ax,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3698       if (status != 0) {
! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
test	al,al
je  	.52A
.52B:
! 3699         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",( AX >> 8 ),status);
! Debug: list unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .52C+0 (used reg = )
mov	bx,#.52C
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3700         AX = ((AX & 0x00ff) | ((0x0c) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3701         goto int13_fail_noah;
add	sp,#..FFEC-..FFF0
br 	.FFEC
!BCC_EOS
! 3702       }
! 3703       goto int13_success;
.52A:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3704       break;
br 	.50D
!BCC_EOS
! 3705     case 0x05:
! 3706       bios_printf(4, "format disk track called\n");
.52D:
! Debug: list * char = .52E+0 (used reg = )
mov	bx,#.52E
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 3707       goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3708       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3709       break;
br 	.50D
!BCC_EOS
! 3710     case 0x08:
! 3711       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices
.52F:
! 3711 [device].lchs.cylinders);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	-$1C[bp],ax
!BCC_EOS
! 3712       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 3713       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	-$20[bp],ax
!BCC_EOS
! 3714       count = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount);
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
xor	ah,ah
mov	-$24[bp],ax
!BCC_EOS
! 3715       nlc = nlc - 2;
! Debug: sub int = const 2 to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	ax,-$1C[bp]
! Debug: eq unsigned int = ax-2 to unsigned short nlc = [S+$28-$1E] (used reg = )
dec	ax
dec	ax
mov	-$1C[bp],ax
!BCC_EOS
! 3716       AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3717       CX = ((CX & 0x00ff) | ((nlc & 0xff) << 8));
! Debug: and int = const $FF to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	al,-$1C[bp]
! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short CX = [S+$2A+$14] (used reg = )
mov	al,$16[bp]
! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 3718       CX = ((CX & 0xff00) | (((nlc >> 2) & 0xc0) | (nlspt & 0x3f)));
! Debug: and int = const $3F to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	al,-$20[bp]
and	al,*$3F
push	ax
! Debug: sr int = const 2 to unsigned short nlc = [S+$2A-$1E] (used reg = )
mov	ax,-$1C[bp]
shr	ax,*1
shr	ax,*1
! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
and	al,#$C0
! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
or	al,0+..FFF0[bp]
inc	sp
inc	sp
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$2A+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
or	al,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 3719       DX = ((DX & 0x00ff) | ((nlh - 1) << 8));
! Debug: sub int = const 1 to unsigned short nlh = [S+$28-$20] (used reg = )
mov	ax,-$1E[bp]
! Debug: sl int = const 8 to unsigned int = ax-1 (used reg = )
dec	ax
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short DX = [S+$2A+$12] (used reg = )
mov	al,$14[bp]
! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 3720       DX = ((DX & 0xff00) | (count));
! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$28+$12] (used reg = )
mov	ax,$14[bp]
xor	al,al
! Debug: or unsigned short count = [S+$28-$26] to unsigned int = ax+0 (used reg = )
or	ax,-$24[bp]
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 3721       goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3722       break;
br 	.50D
!BCC_EOS
! 3723     case 0x10:
! 3724       status = inb(read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[device/2].iobase1) + 7);
.530:
! Debug: div int = const 2 to unsigned char device = [S+$28-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
shr	ax,*1
! Debug: ptradd unsigned int = ax+0 to [4] struct  = const $122 (used reg = )
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: add int = const 7 to unsigned short = ax+0 (used reg = )
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3725       if ( (status & (0x80 | 0x40)) == 0x40 ) {
! Debug: and int = const $C0 to unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
and	al,#$C0
! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
jne 	.531
.532:
! 3726         goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3727       }
! 3728       else {
jmp .533
.531:
! 3729         AX = ((AX & 0x00ff) | ((0xAA) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$5600 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$5600
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3730         goto int13_fail_noah;
add	sp,#..FFEC-..FFF0
br 	.FFEC
!BCC_EOS
! 3731       }
! 3732       break;
.533:
br 	.50D
!BCC_EOS
! 3733     case 0x15:
! 3734       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
.534:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	-$1C[bp],ax
!BCC_EOS
! 3735       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 3736       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	-$20[bp],ax
!BCC_EOS
! 3737       lba_low = (Bit32u)(nlc - 1) * (Bit32u)nlh * (Bit32u)nlspt;
! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	ax,-$20[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$2C-$20] (used reg = )
mov	ax,-$1E[bp]
xor	bx,bx
push	bx
push	ax
! Debug: sub int = const 1 to unsigned short nlc = [S+$30-$1E] (used reg = )
mov	ax,-$1C[bp]
! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
dec	ax
xor	bx,bx
! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
lea	di,-6+..FFF0[bp]
call	lmulul
add	sp,*4
! Debug: mul unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFF0[bp]
call	lmulul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3738       CX = lba_low >> 16;
! Debug: sr int = const $10 to unsigned long lba_low = [S+$28-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned short CX = [S+$28+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 3739       DX = lba_low & 0xffff;
! Debug: and unsigned long = const $FFFF to unsigned long lba_low = [S+$28-6] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FFFF
xor	bx,bx
lea	di,-4[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned short DX = [S+$28+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 3740       AX = ((AX & 0x00ff) | ((3) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$300
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3741       goto int13_success_noah;
add	sp,#..FFED-..FFF0
br 	.FFED
!BCC_EOS
! 3742       break;
br 	.50D
!BCC_EOS
! 3743     case 0x41:
! 3744       BX=0xaa55;
.535:
! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$28+$10] (used reg = )
mov	ax,#$AA55
mov	$12[bp],ax
!BCC_EOS
! 3745       AX = ((AX & 0x00ff) | ((0x30) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$3000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3746       CX=0x0007;
! Debug: eq int = const 7 to unsigned short CX = [S+$28+$14] (used reg = )
mov	ax,*7
mov	$16[bp],ax
!BCC_EOS
! 3747       goto int13_success_noah;
add	sp,#..FFED-..FFF0
br 	.FFED
!BCC_EOS
! 3748       break;
br 	.50D
!BCC_EOS
! 3749     case 0x42:
! 3750     case 0x43:
.536:
! 3751     case 0x44:
.537:
! 3752     case 0x47:
.538:
! 3753       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
.539:
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
mov	-$24[bp],ax
!BCC_EOS
! 3754       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
! Debug: add unsigned short = const 6 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$28-$14] (used reg = )
mov	-$12[bp],ax
!BCC_EOS
! 3755       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$28-$16] (used reg = )
mov	-$14[bp],ax
!BCC_EOS
! 3756       lba_high=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
! Debug: add unsigned short = const $C to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 3757       if (lba_high > read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high) ) {
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: gt unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
lea	di,-8[bp]
call	lcmpul
jae 	.53A
.53B:
! 3758         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .53C+0 (used reg = )
mov	bx,#.53C
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3759         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3760  
! 3760      }
! 3761       lba_low=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
.53A:
! Debug: add unsigned short = const 8 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3762       if (lba_high == read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high)
! 3763           && lba_low >= read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low) ) {
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: logeq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
! Debug: expression subtree swapping
lea	di,-8[bp]
call	lcmpul
jne 	.53D
.53F:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: ge unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
lea	di,-4[bp]
call	lcmpul
ja  	.53D
.53E:
! 3764         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .540+0 (used reg = )
mov	bx,#.540
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3765         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3766       }
! 3767       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
.53D:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
cmp	ax,*$44
je  	.542
.543:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
cmp	ax,*$47
jne 	.541
.542:
! 3768         goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3769       if (( AX >> 8 ) == 0x42)
.541:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $42 to unsigned int = ax+0 (used reg = )
cmp	ax,*$42
jne 	.544
.545:
! 3770         status=ata_cmd_data_in(device, 0x20, count, 0, 0, 0, lba_low, lba_high, segment, offset);
! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
push	-$12[bp]
! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
push	-$24[bp]
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
call	_ata_cmd_data_in
add	sp,*$18
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3771       else
! 3772         status=ata_cmd_data_out(device, 0x30, count, 0, 0, 0, lba_low, lba_high, segment, offset);
jmp .546
.544:
! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
push	-$12[bp]
! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
push	-$24[bp]
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
call	_ata_cmd_data_out
add	sp,*$18
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3773       count=read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors);
.546:
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
mov	-$24[bp],ax
!BCC_EOS
! 3774       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
! Debug: list unsigned short count = [S+$28-$26] (used reg = )
push	-$24[bp]
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3775       if (status != 0) {
! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
test	al,al
je  	.547
.548:
! 3776         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",( AX >> 8 ),status);
! Debug: list unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .549+0 (used reg = )
mov	bx,#.549
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3777         AX = ((AX & 0x00ff) | ((0x0c) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3778         goto int13_fail_noah;
add	sp,#..FFEC-..FFF0
br 	.FFEC
!BCC_EOS
! 3779       }
! 3780       goto int13_success;
.547:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3781       break;
br 	.50D
!BCC_EOS
! 3782     case 0x45:
! 3783     case 0x49:
.54A:
! 3784       goto int13_success;
.54B:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3785       break;
br 	.50D
!BCC_EOS
! 3786     case 0x46:
! 3787       AX = ((AX & 0x00ff) | ((0xb2) << 8));
.54C:
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$4E00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$4E00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3788       goto int13_fail_noah;
add	sp,#..FFEC-..FFF0
br 	.FFEC
!BCC_EOS
! 3789       break;
br 	.50D
!BCC_EOS
! 3790     case 0x48:
! 3791       size=read_word(DS,SI+(Bit16u)&((dpt_t *) 0)->size);
.54D:
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$28-$24] (used reg = )
mov	-$22[bp],ax
!BCC_EOS
! 3792       if(size < 0x1a)
! Debug: lt int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$1A
jae 	.54E
.54F:
! 3793         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3794       if(size >= 0x1a) {
.54E:
! Debug: ge int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$1A
blo 	.550
.551:
! 3795         Bit16u blksize;
!BCC_EOS
! 3796         npc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$154] (used reg = )
! Debug: list * unsigned short = bx+$154 (used reg = )
add	bx,#$154
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short npc = [S+$2A-$18] (used reg = )
mov	-$16[bp],ax
!BCC_EOS
! 3797         nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$152] (used reg = )
! Debug: list * unsigned short = bx+$152 (used reg = )
add	bx,#$152
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$2A-$1A] (used reg = )
mov	-$18[bp],ax
!BCC_EOS
! 3798         npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$156] (used reg = )
! Debug: list * unsigned short = bx+$156 (used reg = )
add	bx,#$156
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
mov	-$1A[bp],ax
!BCC_EOS
! 3799         lba_low = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$2A-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3800         lba_high = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$2A-$A] (used reg = )
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 3801         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
mov	-$28[bp],ax
!BCC_EOS
! 3802         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)
! 3802 ->size, 0x1a);
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3803         if (lba_high || (lba_low/npspt)/nph > 0x3fff)
mov	ax,-8[bp]
mov	bx,-6[bp]
call	ltstl
jne 	.553
.554:
! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
mov	ax,-$18[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2E-$1C] (used reg = )
mov	ax,-$1A[bp]
xor	bx,bx
! Debug: div unsigned long = bx+0 to unsigned long lba_low = [S+$2E-6] (used reg = )
push	bx
push	ax
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-6+..FFF0[bp]
call	ldivul
add	sp,*4
! Debug: div unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFF0[bp]
call	ldivul
add	sp,*4
! Debug: gt unsigned long = const $3FFF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$3FFF
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFF0[bp]
mov	bx,0+..FFF0[bp]
lea	di,-6+..FFF0[bp]
call	lcmpul
jbe	.555
mov	al,*1
jmp	.556
.555:
xor	al,al
.556:
add	sp,*8
! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
xor	ah,ah
cwd
mov	bx,dx
call	ltstl
je  	.552
.553:
! 3804         {
! 3805           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3806           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0x3fff);
! Debug: list int = const $3FFF (used reg = )
mov	ax,#$3FFF
push	ax
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*6
!BCC_EOS
! 3807         }
! 3808         else
! 3809         {
jmp .558
.552:
! 3810           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3811           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, (Bit32u)npc);
! Debug: cast unsigned long = const 0 to unsigned short npc = [S+$2A-$18] (used reg = )
mov	ax,-$16[bp]
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3812         }
! 3813         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, (Bit32u)nph);
.558:
! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
mov	ax,-$18[bp]
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3814         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, (Bit32u)npspt);
! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
mov	ax,-$1A[bp]
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3815         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, lba_low);
! Debug: list unsigned long lba_low = [S+$2A-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3816         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, lba_high);
! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$14 (used reg = )
add	ax,*$14
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3817         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
push	-$28[bp]
! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$18 (used reg = )
add	ax,*$18
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3818       }
! 3819       if(size >= 0x1e) {
.550:
! Debug: ge int = const $1E to unsigned short size = [S+$28-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$1E
blo 	.559
.55A:
! 3820         Bit8u channel, dev, irq, mode, checksum, i, translation;
!BCC_EOS
! 3821         Bit16u iobase1, iobase2, options;
!BCC_EOS
! 3822         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
! Debug: list int = const $1E (used reg = )
mov	ax,*$1E
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$38+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3823         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
! Debug: list unsigned short ebda_seg = [S+$36-$C] (used reg = )
push	-$A[bp]
! Debug: add unsigned short = const $1C to unsigned short SI = [S+$38+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1C (used reg = )
add	ax,*$1C
push	ax
! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3824         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
! Debug: list * struct  = const $244 (used reg = )
mov	ax,#$244
push	ax
! Debug: add unsigned short = const $1A to unsigned short SI = [S+$38+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1A (used reg = )
add	ax,*$1A
push	ax
! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3825         channel = device / 2;
! Debug: div int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$36-$29] (used reg = )
mov	-$27[bp],al
!BCC_EOS
! 3826         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$36-$32] (used reg = )
mov	-$30[bp],ax
!BCC_EOS
! 3827         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$36-$34] (used reg = )
mov	-$32[bp],ax
!BCC_EOS
! 3828         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$128] (used reg = )
! Debug: list * unsigned char = bx+$128 (used reg = )
add	bx,#$128
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$36-$2B] (used reg = )
mov	-$29[bp],al
!BCC_EOS
! 3829         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$36-$2C] (used reg = )
mov	-$2A[bp],al
!BCC_EOS
! 3830         translation = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].translation);
! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$14A] (used reg = )
! Debug: list * unsigned char = bx+$14A (used reg = )
add	bx,#$14A
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$36-$2F] (used reg = )
mov	-$2D[bp],al
!BCC_EOS
! 3831         options = (translation==0?0:1)<<3;
! Debug: logeq int = const 0 to unsigned char translation = [S+$36-$2F] (used reg = )
mov	al,-$2D[bp]
test	al,al
jne 	.55B
.55C:
xor	al,al
jmp .55D
.55B:
mov	al,*1
.55D:
! Debug: sl int = const 3 to char = al+0 (used reg = )
xor	ah,ah
mov	cl,*3
shl	ax,cl
! Debug: eq int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
mov	-$34[bp],ax
!BCC_EOS
! 3832         options |= (1<<4);
! Debug: orab int = const $10 to unsigned short options = [S+$36-$36] (used reg = )
mov	ax,-$34[bp]
or	al,*$10
mov	-$34[bp],ax
!BCC_EOS
! 3833         options |= (mode==0x01?1:0)<<7;
! Debug: logeq int = const 1 to unsigned char mode = [S+$36-$2C] (used reg = )
mov	al,-$2A[bp]
cmp	al,*1
jne 	.55E
.55F:
mov	al,*1
jmp .560
.55E:
xor	al,al
.560:
! Debug: sl int = const 7 to char = al+0 (used reg = )
xor	ah,ah
mov	cl,*7
shl	ax,cl
! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
or	ax,-$34[bp]
mov	-$34[bp],ax
!BCC_EOS
! 3834         options |= (translation==1?1:0)<<9;
! Debug: logeq int = const 1 to unsigned char translation = [S+$36-$2F] (used reg = )
mov	al,-$2D[bp]
cmp	al,*1
jne 	.561
.562:
mov	al,*1
jmp .563
.561:
xor	al,al
.563:
! Debug: sl int = const 9 to char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
shl	ax,*1
! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
or	ax,-$34[bp]
mov	-$34[bp],ax
!BCC_EOS
! 3835         options |= (translation==3?3:0)<<9;
! Debug: logeq int = const 3 to unsigned char translation = [S+$36-$2F] (used reg = )
mov	al,-$2D[bp]
cmp	al,*3
jne 	.564
.565:
mov	al,*3
jmp .566
.564:
xor	al,al
.566:
! Debug: sl int = const 9 to char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
shl	ax,*1
! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
or	ax,-$34[bp]
mov	-$34[bp],ax
!BCC_EOS
! 3836         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
! Debug: list unsigned short iobase1 = [S+$36-$32] (used reg = )
push	-$30[bp]
! Debug: list * unsigned short = const $244 (used reg = )
mov	ax,#$244
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3837         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
! Debug: add int = const 6 to unsigned short iobase2 = [S+$36-$34] (used reg = )
mov	ax,-$32[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list * unsigned short = const $246 (used reg = )
mov	ax,#$246
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3838         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pre
! 3838 fix, (0xe | (device % 2))<<4 );
! Debug: mod int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
and	al,*1
! Debug: or unsigned char = al+0 to int = const $E (used reg = )
! Debug: expression subtree swapping
or	al,*$E
! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cl,*4
shl	ax,cl
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * unsigned char = const $248 (used reg = )
mov	ax,#$248
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3839         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
! Debug: list int = const $CB (used reg = )
mov	ax,#$CB
push	ax
! Debug: list * unsigned char = const $249 (used reg = )
mov	ax,#$249
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3840         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
! Debug: list unsigned char irq = [S+$36-$2B] (used reg = )
mov	al,-$29[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $24A (used reg = )
mov	ax,#$24A
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3841         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char = const $24B (used reg = )
mov	ax,#$24B
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3842         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $24C (used reg = )
mov	ax,#$24C
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3843         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $24D (used reg = )
mov	ax,#$24D
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3844         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
! Debug: list unsigned short options = [S+$36-$36] (used reg = )
push	-$34[bp]
! Debug: list * unsigned short = const $24E (used reg = )
mov	ax,#$24E
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3845         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $250 (used reg = )
mov	ax,#$250
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3846         if (size >=0x42)
! Debug: ge int = const $42 to unsigned short size = [S+$36-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$42
jb  	.567
.568:
! 3847           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
! Debug: list int = const $11 (used reg = )
mov	ax,*$11
push	ax
! Debug: list * unsigned char = const $252 (used reg = )
mov	ax,#$252
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3848         else
! 3849           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x10);
jmp .569
.567:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list * unsigned char = const $252 (used reg = )
mov	ax,#$252
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3850         checksum=0;
.569:
! Debug: eq int = const 0 to unsigned char checksum = [S+$36-$2D] (used reg = )
xor	al,al
mov	-$2B[bp],al
!BCC_EOS
! 3851         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
! Debug: eq int = const 0 to unsigned char i = [S+$36-$2E] (used reg = )
xor	al,al
mov	-$2C[bp],al
!BCC_EOS
!BCC_EOS
jmp .56C
.56D:
! Debug: ptradd unsigned char i = [S+$36-$2E] to * unsigned char = const $244 (used reg = )
mov	al,-$2C[bp]
xor	ah,ah
! Debug: list * unsigned char = ax+$244 (used reg = )
add	ax,#$244
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
xor	ah,ah
add	al,-$2B[bp]
adc	ah,*0
mov	-$2B[bp],al
!BCC_EOS
! 3852         checksum = ~checksum;
.56B:
! Debug: postinc unsigned char i = [S+$36-$2E] (used reg = )
mov	al,-$2C[bp]
inc	ax
mov	-$2C[bp],al
.56C:
! Debug: lt int = const $F to unsigned char i = [S+$36-$2E] (used reg = )
mov	al,-$2C[bp]
cmp	al,*$F
jb 	.56D
.56E:
.56A:
! Debug: not unsigned char checksum = [S+$36-$2D] (used reg = )
mov	al,-$2B[bp]
xor	ah,ah
not	ax
! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
mov	-$2B[bp],al
!BCC_EOS
! 3853         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
! Debug: list unsigned char checksum = [S+$36-$2D] (used reg = )
mov	al,-$2B[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $253 (used reg = )
mov	ax,#$253
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3854       }
! 3855       if(size >= 0x42) {
.559:
! Debug: ge int = const $42 to unsigned short size = [S+$28-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$42
blo 	.56F
.570:
! 3856         Bit8u channel, iface, checksum, i;
!BCC_EOS
! 3857         Bit16u iobase1;
!BCC_EOS
! 3858         channel = device / 2;
! Debug: div int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$29] (used reg = )
mov	-$27[bp],al
!BCC_EOS
! 3859         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$122] (used reg = )
! Debug: list * unsigned char = bx+$122 (used reg = )
add	bx,#$122
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$2E-$2A] (used reg = )
mov	-$28[bp],al
!BCC_EOS
! 3860         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2E] (used reg = )
mov	-$2C[bp],ax
!BCC_EOS
! 3861         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3862         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
! Debug: list unsigned int = const $BEDD (used reg = )
mov	ax,#$BEDD
push	ax
! Debug: add unsigned short = const $1E to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1E (used reg = )
add	ax,*$1E
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3863         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
! Debug: list int = const $24 (used reg = )
mov	ax,*$24
push	ax
! Debug: add unsigned short = const $20 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$20 (used reg = )
add	ax,*$20
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3864         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $21 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$21 (used reg = )
add	ax,*$21
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3865         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $22 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$22 (used reg = )
add	ax,*$22
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3866         if (iface==0x00) {
! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
mov	al,-$28[bp]
test	al,al
jne 	.571
.572:
! 3867           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
! Debug: list int = const $49 (used reg = )
mov	ax,*$49
push	ax
! Debug: add unsigned short = const $24 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$24 (used reg = )
add	ax,*$24
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3868           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
! Debug: list int = const $53 (used reg = )
mov	ax,*$53
push	ax
! Debug: add unsigned short = const $25 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$25 (used reg = )
add	ax,*$25
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3869           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $26 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$26 (used reg = )
add	ax,*$26
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3870           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $27 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$27 (used reg = )
add	ax,*$27
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3871         }
! 3872         else {
jmp .573
.571:
! 3873         }
! 3874         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
.573:
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $28 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$28 (used reg = )
add	ax,*$28
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3875         write_
! 3875 byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
! Debug: list int = const $54 (used reg = )
mov	ax,*$54
push	ax
! Debug: add unsigned short = const $29 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$29 (used reg = )
add	ax,*$29
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3876         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $2A to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$2A (used reg = )
add	ax,*$2A
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3877         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $2B to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$2B (used reg = )
add	ax,*$2B
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3878         if (iface==0x00) {
! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
mov	al,-$28[bp]
test	al,al
jne 	.574
.575:
! 3879           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
! Debug: list unsigned short iobase1 = [S+$2E-$2E] (used reg = )
push	-$2C[bp]
! Debug: add unsigned short = const $30 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$30 (used reg = )
add	ax,*$30
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3880           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $32 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$32 (used reg = )
add	ax,*$32
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3881           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned short = const $34 to unsigned short SI = [S+$32+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$34 (used reg = )
add	ax,*$34
push	ax
! Debug: list unsigned short DS = [S+$34+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3882         }
! 3883         else {
jmp .576
.574:
! 3884         }
! 3885         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
.576:
! Debug: mod int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
and	al,*1
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add unsigned short = const $38 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$38 (used reg = )
add	ax,*$38
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3886         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $39 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$39 (used reg = )
add	ax,*$39
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3887         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $3A to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$3A (used reg = )
add	ax,*$3A
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3888         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned short = const $3C to unsigned short SI = [S+$32+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$3C (used reg = )
add	ax,*$3C
push	ax
! Debug: list unsigned short DS = [S+$34+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3889         checksum=0;
! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
xor	al,al
mov	-$29[bp],al
!BCC_EOS
! 3890         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
! Debug: eq int = const $1E to unsigned char i = [S+$2E-$2C] (used reg = )
mov	al,*$1E
mov	-$2A[bp],al
!BCC_EOS
!BCC_EOS
jmp .579
.57A:
! Debug: add unsigned char i = [S+$2E-$2C] to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
add	al,-$2A[bp]
adc	ah,*0
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
xor	ah,ah
add	al,-$29[bp]
adc	ah,*0
mov	-$29[bp],al
!BCC_EOS
! 3891         checksum = ~checksum;
.578:
! Debug: postinc unsigned char i = [S+$2E-$2C] (used reg = )
mov	al,-$2A[bp]
inc	ax
mov	-$2A[bp],al
.579:
! Debug: lt int = const $40 to unsigned char i = [S+$2E-$2C] (used reg = )
mov	al,-$2A[bp]
cmp	al,*$40
jb 	.57A
.57B:
.577:
! Debug: not unsigned char checksum = [S+$2E-$2B] (used reg = )
mov	al,-$29[bp]
xor	ah,ah
not	ax
! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
mov	-$29[bp],al
!BCC_EOS
! 3892         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
! Debug: list unsigned char checksum = [S+$2E-$2B] (used reg = )
mov	al,-$29[bp]
xor	ah,ah
push	ax
! Debug: add unsigned short = const $41 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$41 (used reg = )
add	ax,*$41
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3893       }
! 3894       goto int13_success;
.56F:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3895       break;
br 	.50D
!BCC_EOS
! 3896     case 0x4e:
! 3897       switch (( AX & 0x00ff )) {
.57C:
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
jmp .57F
! 3898         case 0x01:
! 3899         case 0x03:
.580:
! 3900         case 0x04:
.581:
! 3901         case 0x06:
.582:
! 3902           goto int13_success;
.583:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3903           break;
jmp .57D
!BCC_EOS
! 3904         default:
! 3905           goto int13_fail;
.584:
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3906       }
! 3907       break;
jmp .57D
.57F:
sub	al,*1
je 	.580
sub	al,*2
je 	.581
sub	al,*1
je 	.582
sub	al,*2
je 	.583
jmp	.584
.57D:
br 	.50D
!BCC_EOS
! 3908     case 0x09:
! 3909     case 0x0c:
.585:
! 3910     case 0x0d:
.586:
! 3911     case 0x11:
.587:
! 3912     case 0x14:
.588:
! 3913       bios_printf(4, "int13_harddisk: function %02xh unimplemented, returns success\n", ( AX >> 8 ));
.589:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .58A+0 (used reg = )
mov	bx,#.58A
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3914       goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3915       break;
br 	.50D
!BCC_EOS
! 3916     case 0x0a:
! 3917     case 0x0b:
.58B:
! 3918     case 0x18:
.58C:
! 3919     case 0x50:
.58D:
! 3920     default:
.58E:
! 3921       bios_printf(4, "int13_harddisk: function %02xh unsupported, returns fail\n", ( AX >> 8 ));
.58F:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .590+0 (used reg = )
mov	bx,#.590
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3922       goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3923       break;
br 	.50D
!BCC_EOS
! 3924   }
! 3925 int13_fail:
jmp .50D
.50F:
add	sp,*-$E
sub	ax,*0
jl 	.58F
cmp	ax,*$18
ja  	.591
shl	ax,*1
mov	bx,ax
seg	cs
br	.592[bx]
.592:
.word	.510
.word	.511
.word	.515
.word	.516
.word	.517
.word	.52D
.word	.58F
.word	.58F
.word	.52F
.word	.585
.word	.58B
.word	.58C
.word	.586
.word	.587
.word	.58F
.word	.58F
.word	.530
.word	.588
.word	.58F
.word	.58F
.word	.589
.word	.534
.word	.58F
.word	.58F
.word	.58D
.591:
sub	ax,*$41
jb 	.58F
cmp	ax,*$F
ja  	.593
shl	ax,*1
mov	bx,ax
seg	cs
br	.594[bx]
.594:
.word	.535
.word	.536
.word	.537
.word	.538
.word	.54A
.word	.54C
.word	.539
.word	.54D
.word	.54B
.word	.58F
.word	.58F
.word	.58F
.word	.58F
.word	.57C
.word	.58F
.word	.58E
.593:
br 	.58F
.50D:
..FFF0	=	-$36
add	sp,*$E
.FFF1:
..FFF1	=	-$28
! 3926   AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3927 int13_fail_noah:
.FFEC:
..FFEC	=	-$28
! 3928   write_byte(0x0040, 0x0074, ( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3929 int13_fail_nostatus:
.FFEE:
..FFEE	=	-$28
! 3930   FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$28+$1C] (used reg = )
mov	ax,$1E[bp]
or	al,*1
mov	$1E[bp],ax
!BCC_EOS
! 3931   return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3932 int13_success:
.FFEF:
..FFEF	=	-$28
! 3933   AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$28+$16] (used reg = )
xor	ah,ah
mov	$18[bp],ax
!BCC_EOS
! 3934 int13_success_noah:
.FFED:
..FFED	=	-$28
! 3935   write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3936   FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$28+$1C] (used reg = )
mov	ax,$1E[bp]
and	al,#$FE
mov	$1E[bp],ax
!BCC_EOS
! 3937 }
mov	sp,bp
pop	bp
ret
! 3938   void
! Register BX used in function int13_harddisk
! 3939 int13_cdrom(EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
! 3940   Bit16u E
export	_int13_cdrom
_int13_cdrom:
! 3940 HBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
!BCC_EOS
! 3941 {
! 3942   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 3943   Bit8u device, status, locks;
!BCC_EOS
! 3944   Bit8u atacmd[12];
!BCC_EOS
! 3945   Bit32u lba;
!BCC_EOS
! 3946   Bit16u count, segment, offset, i, size;
!BCC_EOS
! 3947   ;
add	sp,*-$1E
!BCC_EOS
! 3948   write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3949   if( (( ELDX & 0x00ff ) < 0xE0) || (( ELDX & 0x00ff ) >= 0xE0+(4*2)) ) {
! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
mov	al,$10[bp]
! Debug: lt int = const $E0 to unsigned char = al+0 (used reg = )
cmp	al,#$E0
jb  	.596
.597:
! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
mov	al,$10[bp]
! Debug: ge int = const $E8 to unsigned char = al+0 (used reg = )
cmp	al,#$E8
jb  	.595
.596:
! 3950     bios_printf(4, "int13_cdrom: function %02x, ELDL out of range %02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
mov	al,$10[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .598+0 (used reg = )
mov	bx,#.598
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3951     goto int13_fail;
add	sp,#..FFEB+$22
br 	.FFEB
!BCC_EOS
! 3952   }
! 3953   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[( ELDX & 0x00ff )-0xE0]);
.595:
! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
mov	al,$10[bp]
! Debug: sub int = const $E0 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: ptradd unsigned int = ax-$E0 to [8] unsigned char = const $23C (used reg = )
add	ax,#-$E0
mov	bx,ax
! Debug: address unsigned char = [bx+$23C] (used reg = )
! Debug: list * unsigned char = bx+$23C (used reg = )
add	bx,#$23C
push	bx
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char device = [S+$22-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3954   if (device >= (4*2)) {
! Debug: ge int = const 8 to unsigned char device = [S+$22-5] (used reg = )
mov	al,-3[bp]
cmp	al,*8
jb  	.599
.59A:
! 3955     bios_printf(4, "int13_cdrom: function %02x, unmapped device for ELDL=%02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
mov	al,$10[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .59B+0 (used reg = )
mov	bx,#.59B
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3956     goto int13_fail;
add	sp,#..FFEB+$22
br 	.FFEB
!BCC_EOS
! 3957   }
! 3958   switch (( AX >> 8 )) {
.599:
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
br 	.59E
! 3959     case 0x00:
! 3960     case 0x09:
.59F:
! 3961     case 0x0c:
.5A0:
! 3962     case 0x0d:
.5A1:
! 3963     case 0x10:
.5A2:
! 3964     case 0x11:
.5A3:
! 3965     case 0x14:
.5A4:
! 3966     case 0x16:
.5A5:
! 3967       goto int13_success;
.5A6:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 3968       break;
br 	.59C
!BCC_EOS
! 3969     case 0x03:
! 3970     case 0x05:
.5A7:
! 3971     case 0x43:
.5A8:
! 3972       AX = ((AX & 0x00ff) | ((0x03) << 8));
.5A9:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$300
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3973       goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 3974       break;
br 	.59C
!BCC_EOS
! 3975     case 0x01:
! 3976       status = read_byte(0x0040, 0x0074);
.5AA:
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3977       AX = ((AX & 0x00ff) | ((status) << 8));
! Debug: sl int = const 8 to unsigned char status = [S+$22-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$24+$16] (used reg = )
mov	al,$18[bp]
! Debug: or unsigned int (temp) = [S+$24-$24] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFEA[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3978       write_byte(0x0040, 0x0074, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3979       if (status) goto int13_fail_nostatus;
mov	al,-4[bp]
test	al,al
je  	.5AB
.5AC:
add	sp,#..FFE7-..FFEA
br 	.FFE7
!BCC_EOS
! 3980       else goto int13_success_noah;
jmp .5AD
.5AB:
add	sp,#..FFE6-..FFEA
br 	.FFE6
!BCC_EOS
! 3981       break;
.5AD:
br 	.59C
!BCC_EOS
! 3982     case 0x15:
! 3983       AX = ((AX & 0x00ff) | ((0x02) << 8));
.5AE:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$200
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3984       goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 3985       break;
br 	.59C
!BCC_EOS
! 3986     case 0x41:
! 3987       BX=0xaa55;
.5AF:
! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$22+$10] (used reg = )
mov	ax,#$AA55
mov	$12[bp],ax
!BCC_EOS
! 3988       AX = ((AX & 0x00ff) | ((0x30) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$3000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3989       CX=0x0007;
! Debug: eq int = const 7 to unsigned short CX = [S+$22+$14] (used reg = )
mov	ax,*7
mov	$16[bp],ax
!BCC_EOS
! 3990       goto int13_success_noah;
add	sp,#..FFE6-..FFEA
br 	.FFE6
!BCC_EOS
! 3991       break;
br 	.59C
!BCC_EOS
! 3992     case 0x42:
! 3993     case 0x44:
.5B0:
! 3994     case 0x47:
.5B1:
! 3995       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
.5B2:
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
mov	-$18[bp],ax
!BCC_EOS
! 3996       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
! Debug: add unsigned short = const 6 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$22-$1C] (used reg = )
mov	-$1A[bp],ax
!BCC_EOS
! 3997       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$22-$1E] (used reg = )
mov	-$1C[bp],ax
!BCC_EOS
! 3998       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
! Debug: add unsigned short = const $C to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
mov	-$16[bp],ax
mov	-$14[bp],bx
!BCC_EOS
! 3999       if (lba != 0L) {
! Debug: ne long = const 0 to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
xor	bx,bx
push	bx
push	ax
mov	ax,-$16[bp]
mov	bx,-$14[bp]
lea	di,-2+..FFEA[bp]
call	lcmpul
lea	sp,2+..FFEA[bp]
je  	.5B3
.5B4:
! 4000         bios_printf((2 | 4 | 1), "int13_cdrom: function %02x. Can't use 64bits lba\n",( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .5B5+0 (used reg = )
mov	bx,#.5B5
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 4001         goto int13_fail;
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 4002       }
! 4003       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
.5B3:
! Debug: add unsigned short = const 8 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
mov	-$16[bp],ax
mov	-$14[bp],bx
!BCC_EOS
! 4004       if ((( AX 
! 4004 >> 8 ) == 0x44) || (( AX >> 8 ) == 0x47))
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
cmp	ax,*$44
je  	.5B7
.5B8:
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
cmp	ax,*$47
jne 	.5B6
.5B7:
! 4005         goto int13_success;
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4006       memsetb(get_SS(),atacmd,0,12);
.5B6:
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$26-$13 (used reg = )
lea	bx,-$11[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 4007       atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$22-$13] (used reg = )
mov	al,*$28
mov	-$11[bp],al
!BCC_EOS
! 4008       atacmd[7]=(count & 0xff00) >> 8;
! Debug: and unsigned int = const $FF00 to unsigned short count = [S+$22-$1A] (used reg = )
mov	ax,-$18[bp]
xor	al,al
! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$22-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 4009       atacmd[8]=(count & 0x00ff);
! Debug: and int = const $FF to unsigned short count = [S+$22-$1A] (used reg = )
mov	al,-$18[bp]
! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$22-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 4010       atacmd[2]=(lba & 0xff000000) >> 24;
! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF00
lea	di,-$16[bp]
call	landul
! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4011       atacmd[3]=(lba & 0x00ff0000) >> 16;
! Debug: and long = const $FF0000 to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF
lea	di,-$16[bp]
call	landul
! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$10] (used reg = )
mov	-$E[bp],al
!BCC_EOS
! 4012       atacmd[4]=(lba & 0x0000ff00) >> 8;
! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF00
xor	bx,bx
lea	di,-$16[bp]
call	landul
! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 4013       atacmd[5]=(lba & 0x000000ff);
! Debug: and unsigned long = const $FF to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,-$16[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$E] (used reg = )
mov	-$C[bp],al
!BCC_EOS
! 4014       status = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, count*2048L, 0x01, segment,offset);
! Debug: list unsigned short offset = [S+$22-$1E] (used reg = )
push	-$1C[bp]
! Debug: list unsigned short segment = [S+$24-$1C] (used reg = )
push	-$1A[bp]
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: cast unsigned long = const 0 to unsigned short count = [S+$28-$1A] (used reg = )
mov	ax,-$18[bp]
xor	bx,bx
! Debug: mul long = const $800 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
mov	ax,-8+..FFEA[bp]
mov	bx,-6+..FFEA[bp]
lea	di,-$C+..FFEA[bp]
call	lmulul
add	sp,*8
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$2E-$13 (used reg = )
lea	bx,-$11[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$34-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$22-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 4015       count = (Bit16u)(read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes) >> 11);
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*3
call	lsrul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
mov	-$18[bp],ax
!BCC_EOS
! 4016       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
! Debug: list unsigned short count = [S+$22-$1A] (used reg = )
push	-$18[bp]
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$24+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$26+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4017       if (status != 0) {
! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
mov	al,-4[bp]
test	al,al
je  	.5B9
.5BA:
! 4018         bios_printf(4, "int13_cdrom: function %02x, status %02x !\n",( AX >> 8 ),status);
! Debug: list unsigned char status = [S+$22-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .5BB+0 (used reg = )
mov	bx,#.5BB
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 4019         AX = ((AX & 0x00ff) | ((0x0c) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4020         goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 4021       }
! 4022       goto int13_success;
.5B9:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4023       break;
br 	.59C
!BCC_EOS
! 4024     case 0x45:
! 4025       if (( AX & 0x00ff ) > 2) goto int13_fail;
.5BC:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: gt int = const 2 to unsigned char = al+0 (used reg = )
cmp	al,*2
jbe 	.5BD
.5BE:
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 4026       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
.5BD:
! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4027       switch (( AX & 0x00ff )) {
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
br 	.5C1
! 4028         case 0 :
! 4029           if (locks == 0xff) {
.5C2:
! Debug: logeq int = const $FF to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
cmp	al,#$FF
jne 	.5C3
.5C4:
! 4030             AX = ((AX & 0x00ff) | ((0xb4) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$4C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$4C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4031             AX = ((AX & 0xff00) | (1));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
or	al,*1
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4032             goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 4033           }
! 4034           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, ++locks);
.5C3:
! Debug: preinc unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
inc	ax
mov	-5[bp],al
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4035           AX = ((AX & 0xff00) | (1));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
or	al,*1
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4036           break;
br 	.5BF
!BCC_EOS
! 4037         case 1 :
! 4038           if (locks == 0x00) {
.5C5:
! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
test	al,al
jne 	.5C6
.5C7:
! 4039             AX = ((AX & 0x00ff) | ((0xb0) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$5000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$5000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4040             AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4041             goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 4042           }
! 4043           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, --locks);
.5C6:
! Debug: predec unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
dec	ax
mov	-5[bp],al
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4044           AX = ((AX & 0xff00) | (locks==0?0:1));
! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
test	al,al
jne 	.5C8
.5C9:
xor	al,al
jmp .5CA
.5C8:
mov	al,*1
.5CA:
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
or	al,0+..FFEA[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4045           break;
jmp .5BF
!BCC_EOS
! 4046         case 2 :
! 4047           AX = ((AX & 0xff00) | (locks==0?0:1));
.5CB:
! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
test	al,al
jne 	.5CC
.5CD:
xor	al,al
jmp .5CE
.5CC:
mov	al,*1
.5CE:
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
or	al,0+..FFEA[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4048           break;
jmp .5BF
!BCC_EOS
! 4049       }
! 4050       goto int13_success;
jmp .5BF
.5C1:
sub	al,*0
beq 	.5C2
sub	al,*1
beq 	.5C5
sub	al,*1
je 	.5CB
.5BF:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4051       break;
br 	.59C
!BCC_EOS
! 4052     case 0x46:
! 4053       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
.5CF:
! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4054       if (locks != 0) {
! Debug: ne int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
test	al,al
je  	.5D0
.5D1:
! 4055         AX = ((AX & 0x00ff) | ((0xb1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$4F00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4056         goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 4057       }
! 4058 #asm
.5D0:
!BCC_EOS
!BCC_ASM
_int13_cdrom.BP	set	$2E
.int13_cdrom.BP	set	$E
_int13_cdrom.EHBX	set	$24
.int13_cdrom.EHBX	set	4
_int13_cdrom.CS	set	$3C
.int13_cdrom.CS	set	$1C
_int13_cdrom.count	set	8
.int13_cdrom.count	set	-$18
_int13_cdrom.CX	set	$36
.int13_cdrom.CX	set	$16
_int13_cdrom.segment	set	6
.int13_cdrom.segment	set	-$1A
_int13_cdrom.DI	set	$2A
.int13_cdrom.DI	set	$A
_int13_cdrom.FLAGS	set	$3E
.int13_cdrom.FLAGS	set	$1E
_int13_cdrom.DS	set	$26
.int13_cdrom.DS	set	6
_int13_cdrom.ELDX	set	$30
.int13_cdrom.ELDX	set	$10
_int13_cdrom.DX	set	$34
.int13_cdrom.DX	set	$14
_int13_cdrom.size	set	0
.int13_cdrom.size	set	-$20
_int13_cdrom.i	set	2
.int13_cdrom.i	set	-$1E
_int13_cdrom.device	set	$1D
.int13_cdrom.device	set	-3
_int13_cdrom.ES	set	$28
.int13_cdrom.ES	set	8
_int13_cdrom.ebda_seg	set	$1E
.int13_cdrom.ebda_seg	set	-2
_int13_cdrom.SI	set	$2C
.int13_cdrom.SI	set	$C
_int13_cdrom.IP	set	$3A
.int13_cdrom.IP	set	$1A
_int13_cdrom.lba	set	$A
.int13_cdrom.lba	set	-$16
_int13_cdrom.status	set	$1C
.int13_cdrom.status	set	-4
_int13_cdrom.atacmd	set	$F
.int13_cdrom.atacmd	set	-$11
_int13_cdrom.AX	set	$38
.int13_cdrom.AX	set	$18
_int13_cdrom.offset	set	4
.int13_cdrom.offset	set	-$1C
_int13_cdrom.BX	set	$32
.int13_cdrom.BX	set	$12
_int13_cdrom.locks	set	$1B
.int13_cdrom.locks	set	-5
        push bp
        mov bp, sp
        mov ah, #0x52
        int #0x15
        mov _int13_cdrom.status + 2[bp], ah
        jnc int13_cdrom_rme_end
        mov _int13_cdrom.status, #1
int13_cdrom_rme_end:
        pop bp
! 4068 endasm
!BCC_ENDASM
!BCC_EOS
! 4069       if (status != 0) {
! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
mov	al,-4[bp]
test	al,al
je  	.5D2
.5D3:
! 4070         AX = ((AX & 0x00ff) | ((0xb1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$4F00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4071         goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 4072       }
! 4073       goto int13_success;
.5D2:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4074       break;
br 	.59C
!BCC_EOS
! 4075     case 0x48:
! 4076       size = read_word(DS,SI+(Bit16u)&((int13ext_t *) 0)->size);
.5D4:
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$22-$22] (used reg = )
mov	-$20[bp],ax
!BCC_EOS
! 4077       if(size < 0x1a)
! Debug: lt int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
mov	ax,-$20[bp]
cmp	ax,*$1A
jae 	.5D5
.5D6:
! 4078         goto int13_fail;
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 4079       if(size >= 0x1a) {
.5D5:
! Debug: ge int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
mov	ax,-$20[bp]
cmp	ax,*$1A
blo 	.5D7
.5D8:
! 4080         Bit16u cylinders, heads, spt, blksize;
!BCC_EOS
! 4081         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
! Debug: ptradd unsigned char device = [S+$2A-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
mov	-$28[bp],ax
!BCC_EOS
! 4082         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4083         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x74);
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4084         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4085         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4086         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4087         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4088         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$14 (used reg = )
add	ax,*$14
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4089         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
push	-$28[bp]
! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$18 (used reg = )
add	ax,*$18
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4090       }
! 4091       if(size >= 0x1e) {
.5D7:
! Debug: ge int = const $1E to unsigned short size = [S+$22-$22] (used reg = )
mov	ax,-$20[bp]
cmp	ax,*$1E
blo 	.5D9
.5DA:
! 4092         Bit8u channel, dev, irq, mode, checksum, i;
!BCC_EOS
! 4093         Bit16u iobase1, iobase2, options;
!BCC_EOS
! 4094         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
! Debug: list int = const $1E (used reg = )
mov	ax,*$1E
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4095         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
! Debug: list unsigned short ebda_seg = [S+$2E-4] (used reg = )
push	-2[bp]
! Debug: add unsigned short = const $1C to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1C (used reg = )
add	ax,*$1C
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4096         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
! Debug: list * struct  = const $244 (used reg = )
mov	ax,#$244
push	ax
! Debug: add unsigned short = const $1A to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1A (used reg = )
add	ax,*$1A
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4097         channel = device / 2;
! Debug: div int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$23] (used reg = )
mov	-$21[bp],al
!BCC_EOS
! 4098         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2A] (used reg = )
mov	-$28[bp],ax
!BCC_EOS
! 4099         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
mov	-$2A[bp],ax
!BCC_EOS
! 4100         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$128] (used reg = )
! Debug: list * unsigned char = bx+$128 (used reg = )
add	bx,#$128
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$2E-$25] (used reg = )
mov	-$23[bp],al
!BCC_EOS
! 4101         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned char device = [S+$2E-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$2E-$26] (used reg = )
mov	-$24[bp],al
!BCC_EOS
! 4102         options = (1<<4);
! Debug: eq int = const $10 to unsigned short options = [S+$2E-$2E] (used reg = )
mov	ax,*$10
mov	-$2C[bp],ax
!BCC_EOS
! 4103         options |= (1<<5);
! Debug: orab int = const $20 to unsigned short options = [S+$2E-$2E] (used reg = )
mov	ax,-$2C[bp]
or	al,*$20
mov	-$2C[bp],ax
!BCC_EOS
! 4104         options |= 
! 4104 (1<<6);
! Debug: orab int = const $40 to unsigned short options = [S+$2E-$2E] (used reg = )
mov	ax,-$2C[bp]
or	al,*$40
mov	-$2C[bp],ax
!BCC_EOS
! 4105         options |= (mode==0x01?1:0<<7);
! Debug: logeq int = const 1 to unsigned char mode = [S+$2E-$26] (used reg = )
mov	al,-$24[bp]
cmp	al,*1
jne 	.5DB
.5DC:
mov	al,*1
jmp .5DD
.5DB:
xor	al,al
.5DD:
! Debug: orab char = al+0 to unsigned short options = [S+$2E-$2E] (used reg = )
xor	ah,ah
or	ax,-$2C[bp]
mov	-$2C[bp],ax
!BCC_EOS
! 4106         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
! Debug: list unsigned short iobase1 = [S+$2E-$2A] (used reg = )
push	-$28[bp]
! Debug: list * unsigned short = const $244 (used reg = )
mov	ax,#$244
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4107         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
! Debug: add int = const 6 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
mov	ax,-$2A[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list * unsigned short = const $246 (used reg = )
mov	ax,#$246
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4108         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
! Debug: mod int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
and	al,*1
! Debug: or unsigned char = al+0 to int = const $E (used reg = )
! Debug: expression subtree swapping
or	al,*$E
! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cl,*4
shl	ax,cl
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * unsigned char = const $248 (used reg = )
mov	ax,#$248
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4109         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
! Debug: list int = const $CB (used reg = )
mov	ax,#$CB
push	ax
! Debug: list * unsigned char = const $249 (used reg = )
mov	ax,#$249
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4110         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
! Debug: list unsigned char irq = [S+$2E-$25] (used reg = )
mov	al,-$23[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $24A (used reg = )
mov	ax,#$24A
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4111         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char = const $24B (used reg = )
mov	ax,#$24B
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4112         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $24C (used reg = )
mov	ax,#$24C
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4113         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $24D (used reg = )
mov	ax,#$24D
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4114         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
! Debug: list unsigned short options = [S+$2E-$2E] (used reg = )
push	-$2C[bp]
! Debug: list * unsigned short = const $24E (used reg = )
mov	ax,#$24E
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4115         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $250 (used reg = )
mov	ax,#$250
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4116         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
! Debug: list int = const $11 (used reg = )
mov	ax,*$11
push	ax
! Debug: list * unsigned char = const $252 (used reg = )
mov	ax,#$252
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4117         checksum=0;
! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$27] (used reg = )
xor	al,al
mov	-$25[bp],al
!BCC_EOS
! 4118         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
! Debug: eq int = const 0 to unsigned char i = [S+$2E-$28] (used reg = )
xor	al,al
mov	-$26[bp],al
!BCC_EOS
!BCC_EOS
jmp .5E0
.5E1:
! Debug: ptradd unsigned char i = [S+$2E-$28] to * unsigned char = const $244 (used reg = )
mov	al,-$26[bp]
xor	ah,ah
! Debug: list * unsigned char = ax+$244 (used reg = )
add	ax,#$244
push	ax
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
xor	ah,ah
add	al,-$25[bp]
adc	ah,*0
mov	-$25[bp],al
!BCC_EOS
! 4119         checksum = ~checksum;
.5DF:
! Debug: postinc unsigned char i = [S+$2E-$28] (used reg = )
mov	al,-$26[bp]
inc	ax
mov	-$26[bp],al
.5E0:
! Debug: lt int = const $F to unsigned char i = [S+$2E-$28] (used reg = )
mov	al,-$26[bp]
cmp	al,*$F
jb 	.5E1
.5E2:
.5DE:
! Debug: not unsigned char checksum = [S+$2E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
not	ax
! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
mov	-$25[bp],al
!BCC_EOS
! 4120         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
! Debug: list unsigned char checksum = [S+$2E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $253 (used reg = )
mov	ax,#$253
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4121       }
! 4122       if(size >= 0x42) {
.5D9:
! Debug: ge int = const $42 to unsigned short size = [S+$22-$22] (used reg = )
mov	ax,-$20[bp]
cmp	ax,*$42
blo 	.5E3
.5E4:
! 4123         Bit8u channel, iface, checksum, i;
!BCC_EOS
! 4124         Bit16u iobase1;
!BCC_EOS
! 4125         channel = device / 2;
! Debug: div int = const 2 to unsigned char device = [S+$28-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$28-$23] (used reg = )
mov	-$21[bp],al
!BCC_EOS
! 4126         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$122] (used reg = )
! Debug: list * unsigned char = bx+$122 (used reg = )
add	bx,#$122
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$28-$24] (used reg = )
mov	-$22[bp],al
!BCC_EOS
! 4127         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$28-$28] (used reg = )
mov	-$26[bp],ax
!BCC_EOS
! 4128         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4129         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
! Debug: list unsigned int = const $BEDD (used reg = )
mov	ax,#$BEDD
push	ax
! Debug: add unsigned short = const $1E to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1E (used reg = )
add	ax,*$1E
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4130         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
! Debug: list int = const $24 (used reg = )
mov	ax,*$24
push	ax
! Debug: add unsigned short = const $20 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$20 (used reg = )
add	ax,*$20
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4131         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $21 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$21 (used reg = )
add	ax,*$21
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4132         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $22 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$22 (used reg = )
add	ax,*$22
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4133         if (iface==0x00) {
! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
mov	al,-$22[bp]
test	al,al
jne 	.5E5
.5E6:
! 4134           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
! Debug: list int = const $49 (used reg = )
mov	ax,*$49
push	ax
! Debug: add unsigned short = const $24 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$24 (used reg = )
add	ax,*$24
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4135           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
! Debug: list int = const $53 (used reg = )
mov	ax,*$53
push	ax
! Debug: add unsigned short = const $25 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$25 (used reg = )
add	ax,*$25
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4136           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $26 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$26 (used reg = )
add	ax,*$26
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4137           write_byte(DS, SI+(Bit16u
! 4137 )&((dpt_t *) 0)->host_bus[3], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $27 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$27 (used reg = )
add	ax,*$27
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4138         }
! 4139         else {
jmp .5E7
.5E5:
! 4140         }
! 4141         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
.5E7:
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $28 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$28 (used reg = )
add	ax,*$28
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4142         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
! Debug: list int = const $54 (used reg = )
mov	ax,*$54
push	ax
! Debug: add unsigned short = const $29 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$29 (used reg = )
add	ax,*$29
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4143         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $2A to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$2A (used reg = )
add	ax,*$2A
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4144         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $2B to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$2B (used reg = )
add	ax,*$2B
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4145         if (iface==0x00) {
! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
mov	al,-$22[bp]
test	al,al
jne 	.5E8
.5E9:
! 4146           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
! Debug: list unsigned short iobase1 = [S+$28-$28] (used reg = )
push	-$26[bp]
! Debug: add unsigned short = const $30 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$30 (used reg = )
add	ax,*$30
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4147           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $32 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$32 (used reg = )
add	ax,*$32
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4148           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned short = const $34 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$34 (used reg = )
add	ax,*$34
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4149         }
! 4150         else {
jmp .5EA
.5E8:
! 4151         }
! 4152         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
.5EA:
! Debug: mod int = const 2 to unsigned char device = [S+$28-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
and	al,*1
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add unsigned short = const $38 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$38 (used reg = )
add	ax,*$38
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4153         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $39 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$39 (used reg = )
add	ax,*$39
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4154         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $3A to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$3A (used reg = )
add	ax,*$3A
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4155         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned short = const $3C to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$3C (used reg = )
add	ax,*$3C
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4156         checksum=0;
! Debug: eq int = const 0 to unsigned char checksum = [S+$28-$25] (used reg = )
xor	al,al
mov	-$23[bp],al
!BCC_EOS
! 4157         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
! Debug: eq int = const $1E to unsigned char i = [S+$28-$26] (used reg = )
mov	al,*$1E
mov	-$24[bp],al
!BCC_EOS
!BCC_EOS
jmp .5ED
.5EE:
! Debug: add unsigned char i = [S+$28-$26] to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
add	al,-$24[bp]
adc	ah,*0
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$28-$25] (used reg = )
xor	ah,ah
add	al,-$23[bp]
adc	ah,*0
mov	-$23[bp],al
!BCC_EOS
! 4158         checksum = ~checksum;
.5EC:
! Debug: postinc unsigned char i = [S+$28-$26] (used reg = )
mov	al,-$24[bp]
inc	ax
mov	-$24[bp],al
.5ED:
! Debug: lt int = const $40 to unsigned char i = [S+$28-$26] (used reg = )
mov	al,-$24[bp]
cmp	al,*$40
jb 	.5EE
.5EF:
.5EB:
! Debug: not unsigned char checksum = [S+$28-$25] (used reg = )
mov	al,-$23[bp]
xor	ah,ah
not	ax
! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$28-$25] (used reg = )
mov	-$23[bp],al
!BCC_EOS
! 4159         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
! Debug: list unsigned char checksum = [S+$28-$25] (used reg = )
mov	al,-$23[bp]
xor	ah,ah
push	ax
! Debug: add unsigned short = const $41 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$41 (used reg = )
add	ax,*$41
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4160       }
! 4161       goto int13_success;
.5E3:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4162       break;
br 	.59C
!BCC_EOS
! 4163     case 0x49:
! 4164       AX = ((AX & 0x00ff) | ((06) << 8));
.5F0:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$600
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4165       goto int13_fail_nostatus;
add	sp,#..FFE7-..FFEA
br 	.FFE7
!BCC_EOS
! 4166       break;
br 	.59C
!BCC_EOS
! 4167     case 0x4e:
! 4168       switch (( AX & 0x00ff )) {
.5F1:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
jmp .5F4
! 4169         case 0x01:
! 4170         case 0x03:
.5F5:
! 4171         case 0x04:
.5F6:
! 4172         case 0x06:
.5F7:
! 4173           goto int13_success;
.5F8:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4174           break;
jmp .5F2
!BCC_EOS
! 4175         default:
! 4176           goto int13_fail;
.5F9:
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 4177       }
! 4178       break;
jmp .5F2
.5F4:
sub	al,*1
je 	.5F5
sub	al,*2
je 	.5F6
sub	al,*1
je 	.5F7
sub	al,*2
je 	.5F8
jmp	.5F9
.5F2:
br 	.59C
!BCC_EOS
! 4179     case 0x02:
! 4180     case 0x04:
.5FA:
! 4181     case 0x08:
.5FB:
! 4182     case 0x0a:
.5FC:
! 4183     case 0x0b:
.5FD:
! 4184     case 0x18:
.5FE:
! 4185     case 0x50:
.5FF:
! 4186     default:
.600:
! 4187       bios_printf(4, "int13_cdrom: unsupported AH=%02x\n", ( AX >> 8 ));
.601:
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .602+0 (used reg = )
mov	bx,#.602
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 4188       goto int13_fail;
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 4189       break;
br 	.59C
!BCC_EOS
! 4190   }
! 4191 int13_fail:
jmp .59C
.59E:
add	sp,*-$C
sub	ax,*0
jl 	.601
cmp	ax,*$18
ja  	.603
shl	ax,*1
mov	bx,ax
seg	cs
br	.604[bx]
.604:
.word	.59F
.word	.5AA
.word	.5FA
.word	.5A7
.word	.5FB
.word	.5A8
.word	.601
.word	.601
.word	.5FC
.word	.5A0
.word	.5FD
.word	.5FE
.word	.5A1
.word	.5A2
.word	.601
.word	.601
.word	.5A3
.word	.5A4
.word	.601
.word	.601
.word	.5A5
.word	.5AE
.word	.5A6
.word	.601
.word	.5FF
.603:
sub	ax,*$41
jb 	.601
cmp	ax,*$F
ja  	.605
shl	ax,*1
mov	bx,ax
seg	cs
br	.606[bx]
.606:
.word	.5AF
.word	.5B0
.word	.5A9
.word	.5B1
.word	.5BC
.word	.5CF
.word	.5B2
.word	.5D4
.word	.5F0
.word	.601
.word	.601
.word	.601
.word	.601
.word	.5F1
.word	.601
.word	.600
.605:
br 	.601
.59C:
..FFEA	=	-$2E
add	sp,*$C
.FFEB:
..FFEB	=	-$22
! 4192   AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4193 int13_fail_noah:
.FFE8:
..FFE8	=	-$22
! 4194   write_byte(0x0040, 0x0074, ( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4195 int13_fail_nostatus:
.FFE7:
..FFE7	=	-$22
! 4196   FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$22+$1C] (used reg = )
mov	ax,$1E[bp]
or	al,*1
mov	$1E[bp],ax
!BCC_EOS
! 4197   return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4198 int13_success:
.FFE9:
..FFE9	=	-$22
! 4199   AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$22+$16] (used reg = )
xor	ah,ah
mov	$18[bp],ax
!BCC_EOS
! 4200 int13_success_noah:
.FFE6:
..FFE6	=	-$22
! 4201   write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4202   FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$22+$1C] (used reg = )
mov	ax,$1E[bp]
and	al,#$FE
mov	$1E[bp],ax
!BCC_EOS
! 4203 }
mov	sp,bp
pop	bp
ret
! 4204   void
! Register BX used in function int13_cdrom
! 4205 int13_eltorito(DS, ES, D
! 4205 I, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
! 4206   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_eltorito
_int13_eltorito:
!BCC_EOS
! 4207 {
! 4208   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 4209   ;
!BCC_EOS
! 4210   switch (( AX >> 8 )) {
! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
br 	.609
! 4211     case 0x4a:
! 4212     case 0x4c:
.60A:
! 4213     case 0x4d:
.60B:
! 4214       bios_printf((2 | 4 | 1), "Int13 eltorito call with AX=%04x. Please report\n",AX);
.60C:
! Debug: list unsigned short AX = [S+4+$14] (used reg = )
push	$16[bp]
! Debug: list * char = .60D+0 (used reg = )
mov	bx,#.60D
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 4215       goto int13_fail;
add	sp,#..FFE4-..FFE5
br 	.FFE4
!BCC_EOS
! 4216       break;
br 	.607
!BCC_EOS
! 4217     case 0x4b:
! 4218       write_byte(DS,SI+0x00,0x13);
.60E:
! Debug: list int = const $13 (used reg = )
mov	ax,*$13
push	ax
! Debug: add int = const 0 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4219       write_byte(DS,SI+0x01,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media));
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 1 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4220       write_byte(DS,SI+0x02,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4221       write_byte(DS,SI+0x03,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index));
! Debug: list * unsigned char = const $25D (used reg = )
mov	ax,#$25D
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 3 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4222       write_dword(DS,SI+0x04,read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba));
! Debug: list * unsigned long = const $260 (used reg = )
mov	ax,#$260
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 4 to unsigned short SI = [S+8+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4223       write_word(DS,SI+0x08,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec));
! Debug: list * unsigned short = const $25E (used reg = )
mov	ax,#$25E
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: add int = const 8 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4224       write_word(DS,SI+0x0a,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment));
! Debug: list * unsigned short = const $264 (used reg = )
mov	ax,#$264
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: add int = const $A to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$A (used reg = )
add	ax,*$A
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4225       write_word(DS,SI+0x0c,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment));
! Debug: list * unsigned short = const $266 (used reg = )
mov	ax,#$266
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: add int = const $C to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4226       write_word(DS,SI+0x0e,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count));
! Debug: list * unsigned short = const $268 (used reg = )
mov	ax,#$268
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: add int = const $E to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$E (used reg = )
add	ax,*$E
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4227       write_byte(DS,SI+0x10,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders));
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const $10 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4228       write_byte(DS,SI+0x11,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt));
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const $11 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$11 (used reg = )
add	ax,*$11
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4229       write_byte(DS,SI+0x12,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads));
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const $12 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$12 (used reg = )
add	ax,*$12
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4230       if(( AX & 0x00ff ) == 0x00) {
! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
mov	al,$16[bp]
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.60F
.610:
! 4231         write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4232       }
! 4233       goto int13_success;
.60F:
add	sp,#..FFE3-..FFE5
jmp .FFE3
!BCC_EOS
! 4234       break;
jmp .607
!BCC_EOS
! 4235     default:
! 4236       bios_printf(4, "int13_eltorito: unsupported AH=%02x\n", ( AX >> 8 ));
.611:
! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .612+0 (used reg = )
mov	bx,#.612
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 4237       goto int13_fail;
add	sp,#..FFE4-..FFE5
jmp .FFE4
!BCC_EOS
! 4238       break;
jmp .607
!BCC_EOS
! 4239   }
! 4240 int13_fail:
jmp .607
.609:
sub	ax,*$4A
beq 	.60A
sub	ax,*1
beq 	.60E
sub	ax,*1
beq 	.60B
sub	ax,*1
beq 	.60C
jmp	.611
.607:
..FFE5	=	-4
.FFE4:
..FFE4	=	-4
! 4241   AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+4+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4242   write_byte(0x0040, 0x0074, ( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4243   FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4244   return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4245 int13_success:
.FFE3:
..FFE3	=	-4
! 4246   AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+4+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4247   write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4248   FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+4+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4249 }
mov	sp,bp
pop	bp
ret
! 4250   void
! Register BX used in function int13_eltorito
! 4251 int13_cdemu(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
! 4252   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP
export	_int13_cdemu
_int13_cdemu:
! 4252 , CS, FLAGS;
!BCC_EOS
! 4253 {
! 4254   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 4255   Bit8u device, status;
!BCC_EOS
! 4256   Bit16u vheads, vspt, vcylinders;
!BCC_EOS
! 4257   Bit16u head, sector, cylinder, nbsectors;
!BCC_EOS
! 4258   Bit32u vlba, ilba, slba, elba;
!BCC_EOS
! 4259   Bit16u before, segment, offset;
!BCC_EOS
! 4260   Bit8u atacmd[12];
!BCC_EOS
! 4261   ;
add	sp,*-$32
!BCC_EOS
! 4262   device = read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index) * 2;
! Debug: list * unsigned char = const $25D (used reg = )
mov	ax,#$25D
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: mul int = const 2 to unsigned char = al+0 (used reg = )
xor	ah,ah
shl	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char device = [S+$36-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 4263   device += read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec);
! Debug: list * unsigned short = const $25E (used reg = )
mov	ax,#$25E
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char device = [S+$36-5] (used reg = )
xor	ah,ah
add	al,-3[bp]
adc	ah,*0
mov	-3[bp],al
!BCC_EOS
! 4264   write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4265   if( (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active) ==0) ||
! 4266       (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive ) != ( DX & 0x00ff ))) {
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.614
.615:
! Debug: expression subtree swapping
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
mov	al,$12[bp]
! Debug: ne unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
cmp	al,-$36[bp]
lea	sp,-$34[bp]
je  	.613
.614:
! 4267     bios_printf(4, "int13_cdemu: function %02x, emulation not active for DL= %02x\n", ( AX >> 8 ), ( DX & 0x00ff ));
! Debug: and int = const $FF to unsigned short DX = [S+$36+$10] (used reg = )
mov	al,$12[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$38+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .616+0 (used reg = )
mov	bx,#.616
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 4268     goto int13_fail;
add	sp,#..FFE2+$36
br 	.FFE2
!BCC_EOS
! 4269   }
! 4270   switch (( AX >> 8 )) {
.613:
! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
br 	.619
! 4271     case 0x00:
! 4272     case 0x09:
.61A:
! 4273     case 0x0c:
.61B:
! 4274     case 0x0d:
.61C:
! 4275     case 0x10:
.61D:
! 4276     case 0x11:
.61E:
! 4277     case 0x14:
.61F:
! 4278     case 0x16:
.620:
! 4279       goto int13_success;
.621:
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4280       break;
br 	.617
!BCC_EOS
! 4281     case 0x03:
! 4282     case 0x05:
.622:
! 4283       AX = ((AX & 0x00ff) | ((0x03) << 8));
.623:
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$300
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4284       goto int13_fail_noah;
add	sp,#..FFDF-..FFE1
br 	.FFDF
!BCC_EOS
! 4285       break;
br 	.617
!BCC_EOS
! 4286     case 0x01:
! 4287       status=read_byte(0x0040, 0x0074);
.624:
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$36-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 4288       AX = ((AX & 0x00ff) | ((status) << 8));
! Debug: sl int = const 8 to unsigned char status = [S+$36-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$38+$14] (used reg = )
mov	al,$16[bp]
! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4289       write_byte(0x0040, 0x0074, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4290       if (status) goto int13_fail_nostatus;
mov	al,-4[bp]
test	al,al
je  	.625
.626:
add	sp,#..FFDE-..FFE1
br 	.FFDE
!BCC_EOS
! 4291       else goto int13_success_noah;
jmp .627
.625:
add	sp,#..FFDD-..FFE1
br 	.FFDD
!BCC_EOS
! 4292       break;
.627:
br 	.617
!BCC_EOS
! 4293     case 0x02:
! 4294     case 0x04:
.628:
! 4295       vspt = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
.629:
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4296       vcylinders = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders);
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short vcylinders = [S+$36-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 4297       vheads = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads);
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short vheads = [S+$36-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 4298       ilba = read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba);
! Debug: list * unsigned long = const $260 (used reg = )
mov	ax,#$260
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	-$1A[bp],ax
mov	-$18[bp],bx
!BCC_EOS
! 4299       sector = ( CX & 0x00ff ) & 0x003f;
! Debug: and int = const $FF to unsigned short CX = [S+$36+$12] (used reg = )
mov	al,$14[bp]
! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
and	al,*$3F
! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$36-$10] (used reg = )
xor	ah,ah
mov	-$E[bp],ax
!BCC_EOS
! 4300       cylinder = (( CX & 0x00ff ) & 0x00c0) << 2 | ( CX >> 8 );
! Debug: sr int = const 8 to unsigned short CX = [S+$36+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
push	ax
! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
mov	al,$14[bp]
! Debug: and int = const $C0 to unsigned char = al+0 (used reg = )
and	al,#$C0
! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
or	ax,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$36-$12] (used reg = )
mov	-$10[bp],ax
!BCC_EOS
! 4301       head = ( DX >> 8 );
! Debug: sr int = const 8 to unsigned short DX = [S+$36+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$36-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 4302       nbsectors = ( AX & 0x00ff );
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: eq unsigned char = al+0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
xor	ah,ah
mov	-$12[bp],ax
!BCC_EOS
! 4303       segment = ES;
! Debug: eq unsigned short ES = [S+$36+4] to unsigned short segment = [S+$36-$28] (used reg = )
mov	ax,6[bp]
mov	-$26[bp],ax
!BCC_EOS
! 4304       offset = BX;
! Debug: eq unsigned short BX = [S+$36+$E] to unsigned short offset = [S+$36-$2A] (used reg = )
mov	ax,$10[bp]
mov	-$28[bp],ax
!BCC_EOS
! 4305       if(nbsectors==0) goto int13_success;
! Debug: logeq int = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
mov	ax,-$12[bp]
test	ax,ax
jne 	.62A
.62B:
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4306       if ((sector > vspt)
.62A:
! 4307        || (cylinder >= vcylinders)
! 4308        || (head >= vheads)) {
! Debug: gt unsigned short vspt = [S+$36-$A] to unsigned short sector = [S+$36-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,-8[bp]
ja  	.62D
.62F:
! Debug: ge unsigned short vcylinders = [S+$36-$C] to unsigned short cylinder = [S+$36-$12] (used reg = )
mov	ax,-$10[bp]
cmp	ax,-$A[bp]
jae 	.62D
.62E:
! Debug: ge unsigned short vheads = [S+$36-8] to unsigned short head = [S+$36-$E] (used reg = )
mov	ax,-$C[bp]
cmp	ax,-6[bp]
jb  	.62C
.62D:
! 4309         goto int13_fail;
add	sp,#..FFE2-..FFE1
br 	.FFE2
!BCC_EOS
! 4310       }
! 4311       if (( AX >> 8 ) == 0x04) goto int13_success;
.62C:
! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
cmp	ax,*4
jne 	.630
.631:
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4312       segm
! 4312 ent = ES+(BX / 16);
.630:
! Debug: div int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
mov	cl,*4
shr	ax,cl
! Debug: add unsigned int = ax+0 to unsigned short ES = [S+$36+4] (used reg = )
! Debug: expression subtree swapping
add	ax,6[bp]
! Debug: eq unsigned int = ax+0 to unsigned short segment = [S+$36-$28] (used reg = )
mov	-$26[bp],ax
!BCC_EOS
! 4313       offset = BX % 16;
! Debug: mod int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
and	al,*$F
! Debug: eq unsigned char = al+0 to unsigned short offset = [S+$36-$2A] (used reg = )
xor	ah,ah
mov	-$28[bp],ax
!BCC_EOS
! 4314       vlba=((((Bit32u)cylinder*(Bit32u)vheads)+(Bit32u)head)*(Bit32u)vspt)+((Bit32u)(sector-1));
! Debug: sub int = const 1 to unsigned short sector = [S+$36-$10] (used reg = )
mov	ax,-$E[bp]
! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
dec	ax
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short vspt = [S+$3A-$A] (used reg = )
mov	ax,-8[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short head = [S+$3E-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short vheads = [S+$42-8] (used reg = )
mov	ax,-6[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$46-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: mul unsigned long (temp) = [S+$46-$46] to unsigned long = bx+0 (used reg = )
lea	di,-$E+..FFE1[bp]
call	lmulul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$42-$42] to unsigned long = bx+0 (used reg = )
lea	di,-$A+..FFE1[bp]
call	laddul
add	sp,*4
! Debug: mul unsigned long (temp) = [S+$3E-$3E] to unsigned long = bx+0 (used reg = )
lea	di,-6+..FFE1[bp]
call	lmulul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$3A-$3A] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFE1[bp]
call	laddul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
mov	-$16[bp],ax
mov	-$14[bp],bx
!BCC_EOS
! 4315       AX = ((AX & 0xff00) | (nbsectors));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or unsigned short nbsectors = [S+$36-$14] to unsigned int = ax+0 (used reg = )
or	ax,-$12[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4316       slba = (Bit32u)vlba/4;
! Debug: div unsigned long = const 4 to unsigned long vlba = [S+$36-$18] (used reg = )
mov	ax,*4
xor	bx,bx
push	bx
push	ax
mov	ax,-$16[bp]
mov	bx,-$14[bp]
lea	di,-2+..FFE1[bp]
call	ldivul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long slba = [S+$36-$20] (used reg = )
mov	-$1E[bp],ax
mov	-$1C[bp],bx
!BCC_EOS
! 4317       before= (Bit16u)vlba%4;
! Debug: mod int = const 4 to unsigned short vlba = [S+$36-$18] (used reg = )
mov	ax,-$16[bp]
and	al,*3
! Debug: eq unsigned char = al+0 to unsigned short before = [S+$36-$26] (used reg = )
xor	ah,ah
mov	-$24[bp],ax
!BCC_EOS
! 4318       elba = (Bit32u)(vlba+nbsectors-1)/4;
! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
mov	ax,-$12[bp]
xor	bx,bx
! Debug: add unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
! Debug: expression subtree swapping
lea	di,-$16[bp]
call	laddul
! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	lsubul
add	sp,*8
! Debug: cast unsigned long = const 0 to unsigned long = bx+0 (used reg = )
! Debug: div unsigned long = const 4 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*4
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	ldivul
add	sp,*8
! Debug: eq unsigned long = bx+0 to unsigned long elba = [S+$36-$24] (used reg = )
mov	-$22[bp],ax
mov	-$20[bp],bx
!BCC_EOS
! 4319       memsetb(get_SS(),atacmd,0,12);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$3A-$36 (used reg = )
lea	bx,-$34[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 4320       atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$36-$36] (used reg = )
mov	al,*$28
mov	-$34[bp],al
!BCC_EOS
! 4321       atacmd[7]=((Bit16u)(elba-slba+1) & 0xff00) >> 8;
! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
mov	ax,-$22[bp]
mov	bx,-$20[bp]
lea	di,-$1E[bp]
call	lsubul
! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	laddul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: and unsigned int = const $FF00 to unsigned short = ax+0 (used reg = )
xor	al,al
! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$36-$2F] (used reg = )
mov	-$2D[bp],al
!BCC_EOS
! 4322       atacmd[8]=((Bit16u)(elba-slba+1) & 0x00ff);
! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
mov	ax,-$22[bp]
mov	bx,-$20[bp]
lea	di,-$1E[bp]
call	lsubul
! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	laddul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: and int = const $FF to unsigned short = ax+0 (used reg = )
! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$36-$2E] (used reg = )
mov	-$2C[bp],al
!BCC_EOS
! 4323       atacmd[2]=(ilba+slba & 0xff000000) >> 24;
! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	laddul
! Debug: and unsigned long = const $FF000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$FF00
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	landul
add	sp,*8
! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$34] (used reg = )
mov	-$32[bp],al
!BCC_EOS
! 4324       atacmd[3]=(ilba+slba & 0x00ff0000) >> 16;
! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	laddul
! Debug: and long = const $FF0000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$FF
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	landul
add	sp,*8
! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$33] (used reg = )
mov	-$31[bp],al
!BCC_EOS
! 4325       atacmd[4]=(ilba+slba & 0x0000ff00) >> 8;
! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	laddul
! Debug: and unsigned long = const $FF00 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$FF00
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	landul
add	sp,*8
! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$32] (used reg = )
mov	-$30[bp],al
!BCC_EOS
! 4326       atacmd[5]=(ilba+slba & 0x000000ff);
! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	laddul
! Debug: and unsigned long = const $FF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$FF
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	landul
add	sp,*8
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$31] (used reg = )
mov	-$2F[bp],al
!BCC_EOS
! 4327       if((status = ata_cmd_packet(device, 12, get_SS(), atacmd, before*512, nbsectors*512L, 0x01, segment,offset)) != 0) {
! Debug: list unsigned short offset = [S+$36-$2A] (used reg = )
push	-$28[bp]
! Debug: list unsigned short segment = [S+$38-$28] (used reg = )
push	-$26[bp]
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$3C-$14] (used reg = )
mov	ax,-$12[bp]
xor	bx,bx
! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$200
xor	bx,bx
push	bx
push	ax
mov	ax,-8+..FFE1[bp]
mov	bx,-6+..FFE1[bp]
lea	di,-$C+..FFE1[bp]
call	lmulul
add	sp,*8
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: mul int = const $200 to unsigned short before = [S+$40-$26] (used reg = )
mov	ax,-$24[bp]
mov	cx,#$200
imul	cx
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * unsigned char atacmd = S+$42-$36 (used reg = )
lea	bx,-$34[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$48-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$36-6] (used reg = )
mov	-4[bp],al
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.632
.633:
! 4328         bios_printf(4, "int13_cdemu: function %02x, error %02x !\n",( AX >> 8 ),status);
! Debug: list unsigned char status = [S+$36-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$38+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .634+0 (used reg = )
mov	bx,#.634
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 4329         AX = ((AX & 0x00ff) | ((0x02) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$200
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4330         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4331         goto int13_fail_noah;
add	sp,#..FFDF-..FFE1
br 	.FFDF
!BCC_EOS
! 4332       }
! 4333       goto int13_success;
.632:
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4334       break;
br 	.617
!BCC_EOS
! 4335     case 0x08:
! 4336       vspt=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
.635:
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4337       vcylinders=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders) - 1;
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short vcylinders = [S+$36-$C] (used reg = )
dec	ax
mov	-$A[bp],ax
!BCC_EOS
! 4338       vheads=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads) - 1;
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short vheads = [S+$36-8] (used reg = )
dec	ax
mov	-6[bp],ax
!BCC_EOS
! 4339       AX = ((AX & 0xff00) | (0x00));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4340       BX = ((BX & 0xff00) | (0x00));
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
! 4341       CX = ((CX & 0x00ff) | ((vcylinders & 0xff) << 8));
! Debug: and int = const $FF to unsigned short vcylinders = [S+$36-$C] (used reg = )
mov	al,-$A[bp]
! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
mov	al,$14[bp]
! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 4342       CX = ((CX & 0xff00) | (((vcylinders >> 2) & 0xc0) | (vspt & 0x3f)));
! Debug: and int = const $3F to unsigned short vspt = [S+$36-$A] (used reg = )
mov	al,-8[bp]
and	al,*$3F
push	ax
! Debug: sr int = const 2 to unsigned short vcylinders = [S+$38-$C] (used reg = )
mov	ax,-$A[bp]
shr	ax,*1
shr	ax,*1
! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
and	al,#$C0
! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
or	al,0+..FFE1[bp]
inc	sp
inc	sp
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$38+$12] (used reg = )
mov	ax,$14[bp]
xor	al,al
! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
or	al,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 4343       DX = ((DX & 0x00ff) | ((vheads) << 8));
! Debug: sl int = const 8 to unsigned short vheads = [S+$36-8] (used reg = )
mov	ax,-6[bp]
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
mov	al,$12[bp]
! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4344       DX = ((DX & 0xff00) | (0x02));
! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$36+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
or	al,*2
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4345       switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
jmp .638
! 4346         case 0x01: BX = ((BX & 0xff00) | (0x02)); break;
.639:
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
or	al,*2
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
jmp .636
!BCC_EOS
! 4347         case 0x02: BX = ((BX & 0xff00) | (0x04)); break;
.63A:
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or int = const 4 to unsigned int = ax+0 (used reg = )
or	al,*4
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
jmp .636
!BCC_EOS
! 4348         case 0x03: BX = ((BX & 0xff00) | (0x06)); break;
.63B:
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or int = const 6 to unsigned int = ax+0 (used reg = )
or	al,*6
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
jmp .636
!BCC_EOS
! 4349     }
! 4350 #asm
jmp .636
.638:
sub	al,*1
je 	.639
sub	al,*1
je 	.63A
sub	al,*1
je 	.63B
.636:
!BCC_EOS
!BCC_ASM
_int13_cdemu.BP	set	$40
.int13_cdemu.BP	set	$C
_int13_cdemu.CS	set	$4E
.int13_cdemu.CS	set	$1A
_int13_cdemu.nbsectors	set	$22
.int13_cdemu.nbsectors	set	-$12
_int13_cdemu.CX	set	$48
.int13_cdemu.CX	set	$14
_int13_cdemu.elba	set	$12
.int13_cdemu.elba	set	-$22
_int13_cdemu.segment	set	$E
.int13_cdemu.segment	set	-$26
_int13_cdemu.DI	set	$3C
.int13_cdemu.DI	set	8
_int13_cdemu.FLAGS	set	$50
.int13_cdemu.FLAGS	set	$1C
_int13_cdemu.vcylinders	set	$2A
.int13_cdemu.vcylinders	set	-$A
_int13_cdemu.sector	set	$26
.int13_cdemu.sector	set	-$E
_int13_cdemu.DS	set	$38
.int13_cdemu.DS	set	4
_int13_cdemu.head	set	$28
.int13_cdemu.head	set	-$C
_int13_cdemu.cylinder	set	$24
.int13_cdemu.cylinder	set	-$10
_int13_cdemu.DX	set	$46
.int13_cdemu.DX	set	$12
_int13_cdemu.device	set	$31
.int13_cdemu.device	set	-3
_int13_cdemu.ES	set	$3A
.int13_cdemu.ES	set	6
_int13_cdemu.vspt	set	$2C
.int13_cdemu.vspt	set	-8
_int13_cdemu.vlba	set	$1E
.int13_cdemu.vlba	set	-$16
_int13_cdemu.ebda_seg	set	$32
.int13_cdemu.ebda_seg	set	-2
_int13_cdemu.SI	set	$3E
.int13_cdemu.SI	set	$A
_int13_cdemu.IP	set	$4C
.int13_cdemu.IP	set	$18
_int13_cdemu.status	set	$30
.int13_cdemu.status	set	-4
_int13_cdemu.atacmd	set	0
.int13_cdemu.atacmd	set	-$34
_int13_cdemu.AX	set	$4A
.int13_cdemu.AX	set	$16
_int13_cdemu.ilba	set	$1A
.int13_cdemu.ilba	set	-$1A
_int13_cdemu.before	set	$10
.int13_cdemu.before	set	-$24
_int13_cdemu.offset	set	$C
.int13_cdemu.offset	set	-$28
_int13_cdemu.slba	set	$16
.int13_cdemu.slba	set	-$1E
_int13_cdemu.SP	set	$42
.int13_cdemu.SP	set	$E
_int13_cdemu.vheads	set	$2E
.int13_cdemu.vheads	set	-6
_int13_cdemu.BX	set	$44
.int13_cdemu.BX	set	$10
      push bp
      mov bp, sp
      mov ax, #diskette_param_table2
      mov _int13_cdemu.DI+2[bp], ax
      mov _int13_cdemu.ES+2[bp], cs
      pop bp
! 4357 endasm
!BCC_ENDASM
!BCC_EOS
! 4358       goto int13_success;
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4359       break;
br 	.617
!BCC_EOS
! 4360     case 0x15:
! 4361       AX = ((AX & 0x00ff) | ((0x
.63C:
! 4361 03) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$300
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4362       goto int13_success_noah;
add	sp,#..FFDD-..FFE1
br 	.FFDD
!BCC_EOS
! 4363       break;
br 	.617
!BCC_EOS
! 4364     case 0x0a:
! 4365     case 0x0b:
.63D:
! 4366     case 0x18:
.63E:
! 4367     case 0x41:
.63F:
! 4368     case 0x42:
.640:
! 4369     case 0x43:
.641:
! 4370     case 0x44:
.642:
! 4371     case 0x45:
.643:
! 4372     case 0x46:
.644:
! 4373     case 0x47:
.645:
! 4374     case 0x48:
.646:
! 4375     case 0x49:
.647:
! 4376     case 0x4e:
.648:
! 4377     case 0x50:
.649:
! 4378     default:
.64A:
! 4379       bios_printf(4, "int13_cdemu function AH=%02x unsupported, returns fail\n", ( AX >> 8 ));
.64B:
! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .64C+0 (used reg = )
mov	bx,#.64C
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 4380       goto int13_fail;
add	sp,#..FFE2-..FFE1
jmp .FFE2
!BCC_EOS
! 4381       break;
jmp .617
!BCC_EOS
! 4382   }
! 4383 int13_fail:
jmp .617
.619:
sub	ax,*0
jl 	.64B
cmp	ax,*$18
ja  	.64D
shl	ax,*1
mov	bx,ax
seg	cs
br	.64E[bx]
.64E:
.word	.61A
.word	.624
.word	.628
.word	.622
.word	.629
.word	.623
.word	.64B
.word	.64B
.word	.635
.word	.61B
.word	.63D
.word	.63E
.word	.61C
.word	.61D
.word	.64B
.word	.64B
.word	.61E
.word	.61F
.word	.64B
.word	.64B
.word	.620
.word	.63C
.word	.621
.word	.64B
.word	.63F
.64D:
sub	ax,*$41
jb 	.64B
cmp	ax,*$F
ja  	.64F
shl	ax,*1
mov	bx,ax
seg	cs
br	.650[bx]
.650:
.word	.640
.word	.641
.word	.642
.word	.643
.word	.644
.word	.645
.word	.646
.word	.647
.word	.648
.word	.64B
.word	.64B
.word	.64B
.word	.64B
.word	.649
.word	.64B
.word	.64A
.64F:
br 	.64B
.617:
..FFE1	=	-$36
.FFE2:
..FFE2	=	-$36
! 4384   AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4385 int13_fail_noah:
.FFDF:
..FFDF	=	-$36
! 4386   write_byte(0x0040, 0x0074, ( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4387 int13_fail_nostatus:
.FFDE:
..FFDE	=	-$36
! 4388   FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$36+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4389   return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4390 int13_success:
.FFE0:
..FFE0	=	-$36
! 4391   AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$36+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4392 int13_success_noah:
.FFDD:
..FFDD	=	-$36
! 4393   write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4394   FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$36+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4395 }
mov	sp,bp
pop	bp
ret
! 4396 void floppy_reset_controller()
! Register BX used in function int13_cdemu
! 4397 {
export	_floppy_reset_controller
_floppy_reset_controller:
! 4398   Bit8u val8;
!BCC_EOS
! 4399   val8 = inb(0x03f2);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4400   outb(0x03f2, val8 & ~0x04);
! Debug: and int = const -5 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$FB
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4401   outb(0x03f2, val8 | 0x04);
! Debug: or int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
or	al,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4402   do {
.653:
! 4403     val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4404   } while ((val8 & 0xc0) != 0x80);
.652:
! Debug: and int = const $C0 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$C0
! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
cmp	al,#$80
jne	.653
.654:
!BCC_EOS
! 4405 }
.651:
mov	sp,bp
pop	bp
ret
! 4406 void floppy_prepare_controller(drive)
! 4407   Bit16u drive;
export	_floppy_prepare_controller
_floppy_prepare_controller:
!BCC_EOS
! 4408 {
! 4409   Bit8u val8, dor, prev_reset;
!BCC_EOS
! 4410   val8 = read_byte(0x0040, 0x003e);
push	bp
mov	bp,sp
add	sp,*-4
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4411   val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
mov	-1[bp],al
!BCC_EOS
! 4412   write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4413   prev_reset = inb(0x03f2) & 0x04;
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 4 to unsigned char = al+0 (used reg = )
and	al,*4
! Debug: eq unsigned char = al+0 to unsigned char prev_reset = [S+6-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 4414   if (drive)
mov	ax,4[bp]
test	ax,ax
je  	.655
.656:
! 4415     dor = 0x20;
! Debug: eq int = const $20 to unsigned char dor = [S+6-4] (used reg = )
mov	al,*$20
mov	-2[bp],al
!BCC_EOS
! 4416   else
! 4417     dor = 0x10;
jmp .657
.655:
! Debug: eq int = const $10 to unsigned char dor = [S+6-4] (used reg = )
mov	al,*$10
mov	-2[bp],al
!BCC_EOS
! 4418   dor |= 0x0c;
.657:
! Debug: orab int = const $C to unsigned char dor = [S+6-4] (used reg = )
mov	al,-2[bp]
or	al,*$C
mov	-2[bp],al
!BCC_EOS
! 4419   dor |= drive;
! Debug: orab unsigned short drive = [S+6+2] to unsigned char dor = [S+6-4] (used reg = )
mov	ax,4[bp]
or	al,-2[bp]
mov	-2[bp],al
!BCC_EOS
! 4420   outb(0x03f2, dor);
! Debug: list unsigned char dor = [S+6-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4421   write_byte(0x40,0x40, 37);
! Debug: list int = const $25 (used reg = )
mov	ax,*$25
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4422   do {
.65A:
! 4423     val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4424   } while ( (val8 & 0xc0) != 0x80 );
.659:
! Debug: and int = const $C0 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,#$C0
! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
cmp	al,#$80
jne	.65A
.65B:
!BCC_EOS
! 4425   if (prev_reset == 0) {
.658:
! Debug: logeq int = const 0 to unsigned char prev_reset = [S+6-5] (used reg = )
mov	al,-3[bp]
test	al,al
jne 	.65C
.65D:
! 4426 #asm
!BCC_EOS
!BCC_ASM
_floppy_prepare_controller.dor	set	2
.floppy_prepare_controller.dor	set	-2
_floppy_prepare_controller.prev_reset	set	1
.floppy_prepare_controller.prev_reset	set	-3
_floppy_prepare_controller.val8	set	3
.floppy_prepare_controller.val8	set	-1
_floppy_prepare_controller.drive	set	8
.floppy_prepare_controller.drive	set	4
    sti
! 4428 endasm
!BCC_ENDASM
!BCC_EOS
! 4429     do {
.660:
! 4430       val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4431     } while ( (val8 & 0x80) == 0 );
.65F:
! Debug: and int = const $80 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,#$80
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je 	.660
.661:
!BCC_EOS
! 4432     val8 &= 0x7f;
.65E:
! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
mov	-1[bp],al
!BCC_EOS
! 4433 #asm
!BCC_EOS
!BCC_ASM
_floppy_prepare_controller.dor	set	2
.floppy_prepare_controller.dor	set	-2
_floppy_prepare_controller.prev_reset	set	1
.floppy_prepare_controller.prev_reset	set	-3
_floppy_prepare_controller.val8	set	3
.floppy_prepare_controller.val8	set	-1
_floppy_prepare_controller.drive	set	8
.floppy_prepare_controller.drive	set	4
    cli
! 4435 endasm
!BCC_ENDASM
!BCC_EOS
! 4436     write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4437   }
! 4438 }
.65C:
mov	sp,bp
pop	bp
ret
! 4439   bx_bool
! 4440 floppy_media_known(drive)
! 4441   Bit16u drive;
export	_floppy_media_known
_floppy_media_known:
!BCC_EOS
! 4442 {
! 4443   Bit8u val8;
!BCC_EOS
! 4444   Bit16u media_state_offset;
!BCC_EOS
! 4445   val8 = read_byte(0x0040, 0x003e);
push	bp
mov	bp,sp
add	sp,*-4
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4446   if (drive)
mov	ax,4[bp]
test	ax,ax
je  	.662
.663:
! 4447     val8 >>= 1;
! Debug: srab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
shr	ax,*1
mov	-1[bp],al
!BCC_EOS
! 4448   val8 &= 0x01;
.662:
! Debug: andab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,*1
mov	-1[bp],al
!BCC_EOS
! 4449   if (val8 == 0)
! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.664
.665:
! 4450     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4451   media_state_offset = 0x0090;
.664:
! Debug: eq int = const $90 to unsigned short media_state_offset = [S+6-6] (used reg = )
mov	ax,#$90
mov	-4[bp],ax
!BCC_EOS
! 4452   if (drive)
mov	ax,4[bp]
test	ax,ax
je  	.666
.667:
! 4453     media_state_offset += 1;
! Debug: addab int = const 1 to unsigned short media_state_offset = [S+6-6] (used reg = )
mov	ax,-4[bp]
inc	ax
mov	-4[bp],ax
!BCC_EOS
! 4454   val8 = read_byte(0x0040, media_state_offset);
.666:
! Debug: list unsigned short media_state_offset = [S+6-6] (used reg = )
push	-4[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4455   val8 = (val8 >> 4) & 0x01;
! Debug: sr int = const 4 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4456   if (val8 == 0)
! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.668
.669:
! 4457     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4458   return(1);
.668:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4459 }
! 4460   bx_bool
! 4461 floppy_media_sense(drive)
! 4462   Bit16u drive;
export	_floppy_media_sense
_floppy_media_sense:
!BCC_EOS
! 4463 {
! 4464   bx_bool retval;
!BCC_EOS
! 4465   Bit16u media_state_offset;
!BCC_EOS
! 4466   Bit8u drive
! 4466 _type, config_data, media_state;
!BCC_EOS
! 4467   if (floppy_drive_recal(drive) == 0) {
push	bp
mov	bp,sp
add	sp,*-8
! Debug: list unsigned short drive = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () unsigned short = floppy_drive_recal+0 (used reg = )
call	_floppy_drive_recal
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.66A
.66B:
! 4468     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4469   }
! 4470   drive_type = inb_cmos(0x10);
.66A:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4471   if (drive == 0)
! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
jne 	.66C
.66D:
! 4472     drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-5[bp],al
!BCC_EOS
! 4473   else
! 4474     drive_type &= 0x0f;
jmp .66E
.66C:
! Debug: andab int = const $F to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
and	al,*$F
mov	-5[bp],al
!BCC_EOS
! 4475   if (drive_type == 1) {
.66E:
! Debug: logeq int = const 1 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*1
jne 	.66F
.670:
! 4476     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4477     media_state = 0x25;
! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$25
mov	-7[bp],al
!BCC_EOS
! 4478     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4479   }
! 4480   else if (drive_type == 2) {
br 	.671
.66F:
! Debug: logeq int = const 2 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*2
jne 	.672
.673:
! 4481     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4482     media_state = 0x25;
! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$25
mov	-7[bp],al
!BCC_EOS
! 4483     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4484   }
! 4485   else if (drive_type == 3) {
br 	.674
.672:
! Debug: logeq int = const 3 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*3
jne 	.675
.676:
! 4486     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4487     media_state = 0x17;
! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$17
mov	-7[bp],al
!BCC_EOS
! 4488     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4489   }
! 4490   else if (drive_type == 4) {
br 	.677
.675:
! Debug: logeq int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*4
jne 	.678
.679:
! 4491     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4492     media_state = 0x17;
! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$17
mov	-7[bp],al
!BCC_EOS
! 4493     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4494   }
! 4495   else if (drive_type == 5) {
br 	.67A
.678:
! Debug: logeq int = const 5 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*5
jne 	.67B
.67C:
! 4496     config_data = 0xCC;
! Debug: eq int = const $CC to unsigned char config_data = [S+$A-8] (used reg = )
mov	al,#$CC
mov	-6[bp],al
!BCC_EOS
! 4497     media_state = 0xD7;
! Debug: eq int = const $D7 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,#$D7
mov	-7[bp],al
!BCC_EOS
! 4498     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4499   }
! 4500   else if (drive_type == 6) {
jmp .67D
.67B:
! Debug: logeq int = const 6 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*6
jne 	.67E
.67F:
! 4501     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4502     media_state = 0x27;
! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$27
mov	-7[bp],al
!BCC_EOS
! 4503     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4504   }
! 4505   else if (drive_type == 7) {
jmp .680
.67E:
! Debug: logeq int = const 7 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*7
jne 	.681
.682:
! 4506     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4507     media_state = 0x27;
! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$27
mov	-7[bp],al
!BCC_EOS
! 4508     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4509   }
! 4510   else if (drive_type == 8) {
jmp .683
.681:
! Debug: logeq int = const 8 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*8
jne 	.684
.685:
! 4511     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4512     media_state = 0x27;
! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$27
mov	-7[bp],al
!BCC_EOS
! 4513     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4514   }
! 4515   else {
jmp .686
.684:
! 4516     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4517     media_state = 0x00;
! Debug: eq int = const 0 to unsigned char media_state = [S+$A-9] (used reg = )
xor	al,al
mov	-7[bp],al
!BCC_EOS
! 4518     retval = 0;
! Debug: eq int = const 0 to unsigned short retval = [S+$A-4] (used reg = )
xor	ax,ax
mov	-2[bp],ax
!BCC_EOS
! 4519   }
! 4520   if (drive == 0)
.686:
.683:
.680:
.67D:
.67A:
.677:
.674:
.671:
! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
jne 	.687
.688:
! 4521     media_state_offset = 0x90;
! Debug: eq int = const $90 to unsigned short media_state_offset = [S+$A-6] (used reg = )
mov	ax,#$90
mov	-4[bp],ax
!BCC_EOS
! 4522   else
! 4523     media_state_offset = 0x91;
jmp .689
.687:
! Debug: eq int = const $91 to unsigned short media_state_offset = [S+$A-6] (used reg = )
mov	ax,#$91
mov	-4[bp],ax
!BCC_EOS
! 4524   write_byte(0x0040, 0x008B, config_data);
.689:
! Debug: list unsigned char config_data = [S+$A-8] (used reg = )
mov	al,-6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $8B (used reg = )
mov	ax,#$8B
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4525   write_byte(0x0040, media_state_offset, media_state);
! Debug: list unsigned char media_state = [S+$A-9] (used reg = )
mov	al,-7[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short media_state_offset = [S+$C-6] (used reg = )
push	-4[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4526   return(retval);
mov	ax,-2[bp]
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4527 }
! 4528   bx_bool
! 4529 floppy_drive_recal(drive)
! 4530   Bit16u drive;
export	_floppy_drive_recal
_floppy_drive_recal:
!BCC_EOS
! 4531 {
! 4532   Bit8u val8;
!BCC_EOS
! 4533   Bit16u curr_cyl_offset;
!BCC_EOS
! 4534   floppy_prepare_controller(drive);
push	bp
mov	bp,sp
add	sp,*-4
! Debug: list unsigned short drive = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = floppy_prepare_controller+0 (used reg = )
call	_floppy_prepare_controller
inc	sp
inc	sp
!BCC_EOS
! 4535   outb(0x03f5, 0x07);
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4536   outb(0x03f5, drive);
! Debug: list unsigned short drive = [S+6+2] (used reg = )
push	4[bp]
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4537 #asm
!BCC_EOS
!BCC_ASM
_floppy_drive_recal.curr_cyl_offset	set	0
.floppy_drive_recal.curr_cyl_offset	set	-4
_floppy_drive_recal.val8	set	3
.floppy_drive_recal.val8	set	-1
_floppy_drive_recal.drive	set	8
.floppy_drive_recal.drive	set	4
  sti
! 4539 endasm
!BCC_ENDASM
!BCC_EOS
! 4540   do {
.68C:
! 4541     val8 = (read_byte(0x0040, 0x003e) & 0x80);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4542   } while ( val8 == 0 );
.68B:
! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
test	al,al
je 	.68C
.68D:
!BCC_EOS
! 4543   val8 = 0;
.68A:
! Debug: eq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
xor	al,al
mov	-1[bp],al
!BCC_EOS
! 4544 #asm
!BCC_EOS
!BCC_ASM
_floppy_drive_recal.curr_cyl_offset	set	0
.floppy_drive_recal.curr_cyl_offset	set	-4
_floppy_drive_recal.val8	set	3
.floppy_drive_recal.val8	set	-1
_floppy_drive_recal.drive	set	8
.floppy_drive_recal.drive	set	4
  cli
! 4546 endasm
!BCC_ENDASM
!BCC_EOS
! 4547   val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4548   val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
mov	-1[bp],al
!BCC_EOS
! 4549   if (drive) {
mov	ax,4[bp]
test	ax,ax
je  	.68E
.68F:
! 4550     val8 |= 0x02;
! Debug: orab int = const 2 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
or	al,*2
mov	-1[bp],al
!BCC_EOS
! 4551     curr_cyl_offset = 0x0095;
! Debug: eq int = const $95 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
mov	ax,#$95
mov	-4[bp],ax
!BCC_EOS
! 4552   } else {
jmp .690
.68E:
! 4553     val8 |= 0x01;
! Debug: orab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
or	al,*1
mov	-1[bp],al
!BCC_EOS
! 4554     curr_cyl_offset = 0x0094;
! Debug: eq int = const $94 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
mov	ax,#$94
mov	-4[bp],ax
!BCC_EOS
! 4555   }
! 4556   write_byte(0x0040, 0x003e, val8);
.690:
! Debug: list unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4557   write_byte(0x0040, curr_cyl_offset, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short curr_cyl_offset = [S+8-6] (used reg = )
push	-4[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4558   return(1);
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4559 }
! 4560   bx_bool
! 4561 floppy_drive_exists(drive)
! 4562   Bit16u drive;
export	_floppy_drive_exists
_floppy_drive_exists:
!BCC_EOS
! 4563 {
! 4564   Bit8u drive_type;
!BCC_EOS
! 4565   drive_type = inb_cmos(0x10);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4566   if (drive == 0)
! Debug: logeq int = const 0 to unsigned short drive = [S+4+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
jne 	.691
.692:
! 4567     drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-1[bp],al
!BCC_EOS
! 4568   else
! 4569     drive_type &= 0x0f;
jmp .693
.691:
! Debug: andab int = const $F to unsigned char drive_type = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$F
mov	-1[bp],al
!BCC_EOS
! 4570   if ( drive_type == 0 )
.693:
! Debug: logeq int = const 0 to unsigned char drive_type = [S+4-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.694
.695:
! 4571     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4572  
! 4572  else
! 4573     return(1);
jmp .696
.694:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4574 }
.696:
mov	sp,bp
pop	bp
ret
! 4575   void
! 4576 int13_diskette_function(DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
! 4577   Bit16u DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_diskette_function
_int13_diskette_function:
!BCC_EOS
! 4578 {
! 4579   Bit8u drive, num_sectors, track, sector, head, status;
!BCC_EOS
! 4580   Bit16u base_address, base_count, base_es;
!BCC_EOS
! 4581   Bit8u page, mode_register, val8, dor;
!BCC_EOS
! 4582   Bit8u return_status[7];
!BCC_EOS
! 4583   Bit8u drive_type, num_floppies, ah;
!BCC_EOS
! 4584   Bit16u es, last_addr;
!BCC_EOS
! 4585   ;
push	bp
mov	bp,sp
add	sp,*-$1E
!BCC_EOS
! 4586   ah = ( AX >> 8 );
! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char ah = [S+$20-$1C] (used reg = )
mov	-$1A[bp],al
!BCC_EOS
! 4587   switch ( ah ) {
mov	al,-$1A[bp]
br 	.699
! 4588     case 0x00:
! 4589 ;
.69A:
!BCC_EOS
! 4590       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4591       if (drive > 1) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
jbe 	.69B
.69C:
! 4592         AX = ((AX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4593         set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4594         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4595         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4596       }
! 4597       drive_type = inb_cmos(0x10);
.69B:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	-$18[bp],al
!BCC_EOS
! 4598       if (drive == 0)
! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.69D
.69E:
! 4599         drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-$18[bp],al
!BCC_EOS
! 4600       else
! 4601         drive_type &= 0x0f;
jmp .69F
.69D:
! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,*$F
mov	-$18[bp],al
!BCC_EOS
! 4602       if (drive_type == 0) {
.69F:
! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
test	al,al
jne 	.6A0
.6A1:
! 4603         AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4604         set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4605         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4606         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4607       }
! 4608       AX = ((AX & 0x00ff) | ((0) << 8));
.6A0:
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4609       set_diskette_ret_status(0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4610       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4611       set_diskette_current_cyl(drive, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4612       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4613     case 0x01:
! 4614       FLAGS &= 0xfffe;
.6A2:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4615       val8 = read_byte(0x0000, 0x0441);
! Debug: list int = const $441 (used reg = )
mov	ax,#$441
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4616       AX = ((AX & 0x00ff) | ((val8) << 8));
! Debug: sl int = const 8 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$22+$14] (used reg = )
mov	al,$16[bp]
! Debug: or unsigned int (temp) = [S+$22-$22] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFDC[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4617       if (val8) {
mov	al,-$F[bp]
test	al,al
je  	.6A3
.6A4:
! 4618         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4619       }
! 4620       return;
.6A3:
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4621     case 0x02:
! 4622     case 0x03:
.6A5:
! 4623     case 0x04:
.6A6:
! 4624       num_sectors = ( AX & 0x00ff );
.6A7:
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	-2[bp],al
!BCC_EOS
! 4625       track = ( CX >> 8 );
! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 4626       sector = ( CX & 0x00ff );
! Debug: and int = const $FF to unsigned short CX = [S+$20+$12] (used reg = )
mov	al,$14[bp]
! Debug: eq unsigned char = al+0 to unsigned char sector = [S+$20-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 4627       head = ( DX >> 8 );
! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4628       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4629       if ((drive > 1) || (head > 1) || (sector == 0) ||
! 4630           (num_sectors == 0) || (num_sectors > 72)) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
ja  	.6A9
.6AD:
! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
cmp	al,*1
ja  	.6A9
.6AC:
! Debug: logeq int = const 0 to unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
test	al,al
je  	.6A9
.6AB:
! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
test	al,al
je  	.6A9
.6AA:
! Debug: gt int = const $48 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
cmp	al,*$48
jbe 	.6A8
.6A9:
! 4631         bios_printf(4, "int13_diskette: read/write/verify: parameter out of range\n");
! Debug: list * char = .6AE+0 (used reg = )
mov	bx,#.6AE
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4632         AX = ((AX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4633         set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4634         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4635         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4636         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4637       }
! 4638       if (floppy_drive_exists(drive) == 0) {
.6A8:
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
call	_floppy_drive_exists
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6AF
.6B0:
! 4639         AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4640         set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4641         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4642         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4643         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4644    
! 4644    }
! 4645       if (floppy_media_known(drive) == 0) {
.6AF:
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
call	_floppy_media_known
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6B1
.6B2:
! 4646         if (floppy_media_sense(drive) == 0) {
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
call	_floppy_media_sense
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6B3
.6B4:
! 4647           AX = ((AX & 0x00ff) | ((0x0C) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4648           set_diskette_ret_status(0x0C);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4649           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4650           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4651           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4652         }
! 4653       }
.6B3:
! 4654       if (ah == 0x02) {
.6B1:
! Debug: logeq int = const 2 to unsigned char ah = [S+$20-$1C] (used reg = )
mov	al,-$1A[bp]
cmp	al,*2
bne 	.6B5
.6B6:
! 4655         page = (ES >> 12);
! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 4656         base_es = (ES << 4);
! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 4657         base_address = base_es + BX;
! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
add	ax,$10[bp]
! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4658         if ( base_address < base_es ) {
! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-$C[bp]
jae 	.6B7
.6B8:
! 4659           page++;
! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
inc	ax
mov	-$D[bp],al
!BCC_EOS
! 4660         }
! 4661         base_count = (num_sectors * 512) - 1;
.6B7:
! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
mov	cx,#$200
imul	cx
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
dec	ax
mov	-$A[bp],ax
!BCC_EOS
! 4662         last_addr = base_address + base_count;
! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
add	ax,-$A[bp]
! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 4663         if (last_addr < base_address) {
! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,-8[bp]
jae 	.6B9
.6BA:
! 4664           AX = ((AX & 0x00ff) | ((0x09) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$900
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4665           set_diskette_ret_status(0x09);
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4666           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4667           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4668           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4669         }
! 4670         ;
.6B9:
!BCC_EOS
! 4671         outb(0x000a, 0x06);
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4672   ;
!BCC_EOS
! 4673         outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4674         outb(0x0004, base_address);
! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
push	-8[bp]
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4675         outb(0x0004, base_address>>8);
! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4676   ;
!BCC_EOS
! 4677         outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4678         outb(0x0005, base_count);
! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
push	-$A[bp]
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4679         outb(0x0005, base_count>>8);
! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
mov	ax,-$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4680         mode_register = 0x46;
! Debug: eq int = const $46 to unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,*$46
mov	-$E[bp],al
!BCC_EOS
! 4681   ;
!BCC_EOS
! 4682         outb(0x000b, mode_register);
! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4683   ;
!BCC_EOS
! 4684         outb(0x0081, page);
! Debug: list unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
push	ax
! Debug: list int = const $81 (used reg = )
mov	ax,#$81
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4685   ;
!BCC_EOS
! 4686         outb(0x000a, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4687         ;
!BCC_EOS
! 4688         outb(0x000a, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4689         floppy_prepare_controller(drive);
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = floppy_prepare_controller+0 (used reg = )
call	_floppy_prepare_controller
inc	sp
inc	sp
!BCC_EOS
! 4690         outb(0x03f5, 0xe6);
! Debug: list int = const $E6 (used reg = )
mov	ax,#$E6
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4691         outb(0x03f5, (head << 2) | drive);
! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
or	al,-1[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4692         outb(0x03f5, track);
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4693         outb(0x03f5, head);
! Debug: list unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4694         outb(0x03f5, sector);
! Debug: list unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4695         outb(0x03f5, 2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4696         outb(0x03f5, sector + num_sectors - 1);
! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
add	al,-2[bp]
adc	ah,*0
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4697         outb(0x03f5, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4698         outb(0x03f5, 0xff);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4699 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
        sti
! 4701 endasm
!BCC_ENDASM
!BCC_EOS
! 4702         do {
.6BD:
! 4703           val8 = read_byte(0x0040, 0x0040);
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4704           if (val8 == 0) {
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
jne 	.6BE
.6BF:
! 4705             floppy_reset_controller();
! Debug: func () void = floppy_reset_controller+0 (used reg = )
call	_floppy_reset_controller
!BCC_EOS
! 4706             AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4707             set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4708             AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4709             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4710             return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4711           }
! 4712           val8 = (read_byte(0x0040, 0x003e) & 0x80);
.6BE:
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4713         } while ( val8 == 0 );
.6BC:
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
je 	.6BD
.6C0:
!BCC_EOS
! 4714         val8 = 0;
.6BB:
! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
xor	al,al
mov	-$F[bp],al
!BCC_EOS
! 4715 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
        cli
! 4717 endasm
!BCC_ENDASM
!BCC_EOS
! 4718         val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4719      
! 4719    val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,*$7F
mov	-$F[bp],al
!BCC_EOS
! 4720         write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4721         val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4722         if ( (val8 & 0xc0) != 0xc0 )
! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,#$C0
! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
cmp	al,#$C0
je  	.6C1
.6C2:
! 4723           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
! Debug: list * char = .6C3+0 (used reg = )
mov	bx,#.6C3
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4724         return_status[0] = inb(0x3f5);
.6C1:
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	-$17[bp],al
!BCC_EOS
! 4725         return_status[1] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	-$16[bp],al
!BCC_EOS
! 4726         return_status[2] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
mov	-$15[bp],al
!BCC_EOS
! 4727         return_status[3] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
mov	-$14[bp],al
!BCC_EOS
! 4728         return_status[4] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
mov	-$13[bp],al
!BCC_EOS
! 4729         return_status[5] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
mov	-$12[bp],al
!BCC_EOS
! 4730         return_status[6] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 4731         write_byte(0x0040, 0x0042, return_status[0]);
! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
xor	ah,ah
push	ax
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4732         write_byte(0x0040, 0x0043, return_status[1]);
! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
xor	ah,ah
push	ax
! Debug: list int = const $43 (used reg = )
mov	ax,*$43
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4733         write_byte(0x0040, 0x0044, return_status[2]);
! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
mov	al,-$15[bp]
xor	ah,ah
push	ax
! Debug: list int = const $44 (used reg = )
mov	ax,*$44
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4734         write_byte(0x0040, 0x0045, return_status[3]);
! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
mov	al,-$14[bp]
xor	ah,ah
push	ax
! Debug: list int = const $45 (used reg = )
mov	ax,*$45
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4735         write_byte(0x0040, 0x0046, return_status[4]);
! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
mov	al,-$13[bp]
xor	ah,ah
push	ax
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4736         write_byte(0x0040, 0x0047, return_status[5]);
! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
push	ax
! Debug: list int = const $47 (used reg = )
mov	ax,*$47
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4737         write_byte(0x0040, 0x0048, return_status[6]);
! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const $48 (used reg = )
mov	ax,*$48
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4738         if ( (return_status[0] & 0xc0) != 0 ) {
! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
and	al,#$C0
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.6C4
.6C5:
! 4739           AX = ((AX & 0x00ff) | ((0x20) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $2000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$2000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4740           set_diskette_ret_status(0x20);
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4741           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4742           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4743           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4744         }
! 4745         set_diskette_current_cyl(drive, track);
.6C4:
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4746         AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4747         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4748         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4749       } else if (ah == 0x03) {
br 	.6C6
.6B5:
! Debug: logeq int = const 3 to unsigned char ah = [S+$20-$1C] (used reg = )
mov	al,-$1A[bp]
cmp	al,*3
bne 	.6C7
.6C8:
! 4750         page = (ES >> 12);
! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 4751         base_es = (ES << 4);
! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 4752         base_address = base_es + BX;
! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
add	ax,$10[bp]
! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4753         if ( base_address < base_es ) {
! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-$C[bp]
jae 	.6C9
.6CA:
! 4754           page++;
! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
inc	ax
mov	-$D[bp],al
!BCC_EOS
! 4755         }
! 4756         base_count = (num_sectors * 512) - 1;
.6C9:
! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
mov	cx,#$200
imul	cx
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
dec	ax
mov	-$A[bp],ax
!BCC_EOS
! 4757         last_addr = base_address + base_count;
! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
add	ax,-$A[bp]
! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 4758         if (last_addr < base_address) {
! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,-8[bp]
jae 	.6CB
.6CC:
! 4759           AX = ((AX & 0x00ff) | ((0x09) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$900
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4760           set_diskette_ret_status(0x09);
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4761           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4762           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4763           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4764         }
! 4765         ;
.6CB:
!BCC_EOS
! 4766         outb(0x000a, 0x06);
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4767         outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4768         outb(0x0004, base_address);
! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
push	-8[bp]
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4769         outb(0x0004, base_address>>8);
! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4770         outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4771         outb(0x0005, base_count);
! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
push	-$A[bp]
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4772         outb(0x0005, base_count>>8);
! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
mov	ax,-$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4773         mode_register = 0x4a;
! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,*$4A
mov	-$E[bp],al
!BCC_EOS
! 4774         outb(0x000b, mode_register);
! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4775         outb(0x0081, pa
! 4775 ge);
! Debug: list unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
push	ax
! Debug: list int = const $81 (used reg = )
mov	ax,#$81
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4776         ;
!BCC_EOS
! 4777         outb(0x000a, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4778         floppy_prepare_controller(drive);
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = floppy_prepare_controller+0 (used reg = )
call	_floppy_prepare_controller
inc	sp
inc	sp
!BCC_EOS
! 4779         outb(0x03f5, 0xc5);
! Debug: list int = const $C5 (used reg = )
mov	ax,#$C5
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4780         outb(0x03f5, (head << 2) | drive);
! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
or	al,-1[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4781         outb(0x03f5, track);
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4782         outb(0x03f5, head);
! Debug: list unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4783         outb(0x03f5, sector);
! Debug: list unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4784         outb(0x03f5, 2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4785         outb(0x03f5, sector + num_sectors - 1);
! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
add	al,-2[bp]
adc	ah,*0
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4786         outb(0x03f5, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4787         outb(0x03f5, 0xff);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4788 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
        sti
! 4790 endasm
!BCC_ENDASM
!BCC_EOS
! 4791         do {
.6CF:
! 4792           val8 = read_byte(0x0040, 0x0040);
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4793           if (val8 == 0) {
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
jne 	.6D0
.6D1:
! 4794             floppy_reset_controller();
! Debug: func () void = floppy_reset_controller+0 (used reg = )
call	_floppy_reset_controller
!BCC_EOS
! 4795             AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4796             set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4797             AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4798             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4799             return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4800           }
! 4801           val8 = (read_byte(0x0040, 0x003e) & 0x80);
.6D0:
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4802         } while ( val8 == 0 );
.6CE:
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
je 	.6CF
.6D2:
!BCC_EOS
! 4803         val8 = 0;
.6CD:
! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
xor	al,al
mov	-$F[bp],al
!BCC_EOS
! 4804 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
        cli
! 4806 endasm
!BCC_ENDASM
!BCC_EOS
! 4807         val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4808         val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,*$7F
mov	-$F[bp],al
!BCC_EOS
! 4809         write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4810         val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4811         if ( (val8 & 0xc0) != 0xc0 )
! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,#$C0
! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
cmp	al,#$C0
je  	.6D3
.6D4:
! 4812           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
! Debug: list * char = .6D5+0 (used reg = )
mov	bx,#.6D5
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4813         return_status[0] = inb(0x3f5);
.6D3:
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	-$17[bp],al
!BCC_EOS
! 4814         return_status[1] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	-$16[bp],al
!BCC_EOS
! 4815         return_status[2] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
mov	-$15[bp],al
!BCC_EOS
! 4816         return_status[3] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
mov	-$14[bp],al
!BCC_EOS
! 4817         return_status[4] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
mov	-$13[bp],al
!BCC_EOS
! 4818         return_status[5] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
mov	-$12[bp],al
!BCC_EOS
! 4819         return_status[6] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 4820         write_byte(0x0040, 0x0042, return_status[0]);
! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
xor	ah,ah
push	ax
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4821         write_byte(0x0040, 0x0043, return_status[1]);
! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
xor	ah,ah
push	ax
! Debug: list int = const $43 (used reg = )
mov	ax,*$43
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4822         write_byte(0x0040, 0x0044, return_status[2]);
! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
mov	al,-$15[bp]
xor	ah,ah
push	ax
! Debug: list int = const $44 (used reg = )
mov	ax,*$44
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4823         write_byte(0x0040, 0x0045, return_status[3]);
! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
mov	al,-$14[bp]
xor	ah,ah
push	ax
! Debug: list int = const $45 (used reg = )
mov	ax,*$45
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4824         write_byte(0x0040, 0x0046, return_status[4]);
! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
mov	al,-$13[bp]
xor	ah,ah
push	ax
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4825         write_byte(0x0040, 0x0047, return_status[5]);
! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
push	ax
! Debug: list int = const $47 (used reg = )
mov	ax,*$47
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4826         write_byte(0x0040, 0x0048, return_status[6]);
! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const $48 (used reg = )
mov	ax,*$48
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4827         if ( (return_status[0] & 0xc0) != 0 ) {
! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
and	al,#$C0
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.6D6
.6D7:
! 4828           if ( (return_status[1] & 0x02) != 0 ) {
! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
and	al,*2
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.6D8
.6D9:
! 4829             AX = 0x0300;
! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,#$300
mov	$16[bp],ax
!BCC_EOS
! 4830             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4831             return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4832           } else {
jmp .6DA
.6D8:
! 4833             bios_printf((2 | 4 | 1), "int13_diskette_function: read error\n");
! Debug: list * char = .6DB+0 (used reg = )
mov	bx,#.6DB
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4834           }
! 4835         }
.6DA:
! 4836         set_diskette_curr
! 4836 ent_cyl(drive, track);
.6D6:
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4837         AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4838         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4839         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4840       } else {
jmp .6DC
.6C7:
! 4841         set_diskette_current_cyl(drive, track);
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4842         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4843         AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4844         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4845       }
! 4846       break;
.6DC:
.6C6:
br 	.697
!BCC_EOS
! 4847     case 0x05:
! 4848 ;
.6DD:
!BCC_EOS
! 4849       num_sectors = ( AX & 0x00ff );
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	-2[bp],al
!BCC_EOS
! 4850       track = ( CX >> 8 );
! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 4851       head = ( DX >> 8 );
! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4852       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4853       if ((drive > 1) || (head > 1) || (track > 79) ||
! 4854           (num_sectors == 0) || (num_sectors > 18)) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
ja  	.6DF
.6E3:
! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
cmp	al,*1
ja  	.6DF
.6E2:
! Debug: gt int = const $4F to unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
cmp	al,*$4F
ja  	.6DF
.6E1:
! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
test	al,al
je  	.6DF
.6E0:
! Debug: gt int = const $12 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
cmp	al,*$12
jbe 	.6DE
.6DF:
! 4855         AX = ((AX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4856         set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4857         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4858       }
! 4859       if (floppy_drive_exists(drive) == 0) {
.6DE:
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
call	_floppy_drive_exists
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6E4
.6E5:
! 4860         AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4861         set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4862         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4863         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4864       }
! 4865       if (floppy_media_known(drive) == 0) {
.6E4:
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
call	_floppy_media_known
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6E6
.6E7:
! 4866         if (floppy_media_sense(drive) == 0) {
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
call	_floppy_media_sense
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6E8
.6E9:
! 4867           AX = ((AX & 0x00ff) | ((0x0C) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4868           set_diskette_ret_status(0x0C);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4869           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4870           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4871           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4872         }
! 4873       }
.6E8:
! 4874       page = (ES >> 12);
.6E6:
! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 4875       base_es = (ES << 4);
! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 4876       base_address = base_es + BX;
! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
add	ax,$10[bp]
! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4877       if ( base_address < base_es ) {
! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-$C[bp]
jae 	.6EA
.6EB:
! 4878         page++;
! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
inc	ax
mov	-$D[bp],al
!BCC_EOS
! 4879       }
! 4880       base_count = (num_sectors * 4) - 1;
.6EA:
! Debug: mul int = const 4 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
dec	ax
mov	-$A[bp],ax
!BCC_EOS
! 4881       last_addr = base_address + base_count;
! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
add	ax,-$A[bp]
! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 4882       if (last_addr < base_address) {
! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,-8[bp]
jae 	.6EC
.6ED:
! 4883         AX = ((AX & 0x00ff) | ((0x09) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$900
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4884         set_diskette_ret_status(0x09);
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4885         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4886         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4887         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4888       }
! 4889       outb(0x000a, 0x06);
.6EC:
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4890       outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4891       outb(0x0004, base_address);
! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
push	-8[bp]
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4892       outb(0x0004, base_address>>8);
! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4893       outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4894       outb(0x0005, base_count);
! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
push	-$A[bp]
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4895       outb(0x0005, base_count>>8);
! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
mov	ax,-$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4896       mode_register = 0x4a;
! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,*$4A
mov	-$E[bp],al
!BCC_EOS
! 4897       outb(0x000b, mode_register);
! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4898       outb(0x0081, page);
! Debug: list unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
push	ax
! Debug: list int = const $81 (used reg = )
mov	ax,#$81
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4899       outb(0x000a, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4900       floppy_prepare_controller(drive);
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = floppy_prepare_controller+0 (used reg = )
call	_floppy_prepare_controller
inc	sp
inc	sp
!BCC_EOS
! 4901       outb(0x03f5, 0x4d);
! Debug: list int = const $4D (used reg = )
mov	ax,*$4D
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4902       outb(0x03f5, (head << 2) | drive);
! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
or	al,-1[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4903       outb(0x03f5, 2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4904       outb(0x03f5, num_sectors);
! Debug: list unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4905       out
! 4905 b(0x03f5, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4906       outb(0x03f5, 0xf6);
! Debug: list int = const $F6 (used reg = )
mov	ax,#$F6
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4907 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
      sti
! 4909 endasm
!BCC_ENDASM
!BCC_EOS
! 4910       do {
.6F0:
! 4911         val8 = read_byte(0x0040, 0x0040);
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4912         if (val8 == 0) {
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
jne 	.6F1
.6F2:
! 4913           floppy_reset_controller();
! Debug: func () void = floppy_reset_controller+0 (used reg = )
call	_floppy_reset_controller
!BCC_EOS
! 4914           AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4915           set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4916           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4917           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4918         }
! 4919         val8 = (read_byte(0x0040, 0x003e) & 0x80);
.6F1:
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4920       } while ( val8 == 0 );
.6EF:
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
je 	.6F0
.6F3:
!BCC_EOS
! 4921       val8 = 0;
.6EE:
! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
xor	al,al
mov	-$F[bp],al
!BCC_EOS
! 4922 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
      cli
! 4924 endasm
!BCC_ENDASM
!BCC_EOS
! 4925       val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4926       val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,*$7F
mov	-$F[bp],al
!BCC_EOS
! 4927       write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4928       val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4929       if ( (val8 & 0xc0) != 0xc0 )
! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,#$C0
! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
cmp	al,#$C0
je  	.6F4
.6F5:
! 4930         bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
! Debug: list * char = .6F6+0 (used reg = )
mov	bx,#.6F6
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4931       return_status[0] = inb(0x3f5);
.6F4:
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	-$17[bp],al
!BCC_EOS
! 4932       return_status[1] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	-$16[bp],al
!BCC_EOS
! 4933       return_status[2] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
mov	-$15[bp],al
!BCC_EOS
! 4934       return_status[3] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
mov	-$14[bp],al
!BCC_EOS
! 4935       return_status[4] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
mov	-$13[bp],al
!BCC_EOS
! 4936       return_status[5] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
mov	-$12[bp],al
!BCC_EOS
! 4937       return_status[6] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 4938       write_byte(0x0040, 0x0042, return_status[0]);
! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
xor	ah,ah
push	ax
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4939       write_byte(0x0040, 0x0043, return_status[1]);
! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
xor	ah,ah
push	ax
! Debug: list int = const $43 (used reg = )
mov	ax,*$43
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4940       write_byte(0x0040, 0x0044, return_status[2]);
! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
mov	al,-$15[bp]
xor	ah,ah
push	ax
! Debug: list int = const $44 (used reg = )
mov	ax,*$44
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4941       write_byte(0x0040, 0x0045, return_status[3]);
! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
mov	al,-$14[bp]
xor	ah,ah
push	ax
! Debug: list int = const $45 (used reg = )
mov	ax,*$45
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4942       write_byte(0x0040, 0x0046, return_status[4]);
! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
mov	al,-$13[bp]
xor	ah,ah
push	ax
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4943       write_byte(0x0040, 0x0047, return_status[5]);
! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
push	ax
! Debug: list int = const $47 (used reg = )
mov	ax,*$47
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4944       write_byte(0x0040, 0x0048, return_status[6]);
! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const $48 (used reg = )
mov	ax,*$48
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4945       if ( (return_status[0] & 0xc0) != 0 ) {
! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
and	al,#$C0
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.6F7
.6F8:
! 4946         if ( (return_status[1] & 0x02) != 0 ) {
! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
and	al,*2
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.6F9
.6FA:
! 4947           AX = 0x0300;
! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,#$300
mov	$16[bp],ax
!BCC_EOS
! 4948           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4949           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4950         } else {
jmp .6FB
.6F9:
! 4951           bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
! Debug: list * char = .6FC+0 (used reg = )
mov	bx,#.6FC
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4952         }
! 4953       }
.6FB:
! 4954       AX = ((AX & 0x00ff) | ((0) << 8));
.6F7:
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4955       set_diskette_ret_status(0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4956       set_diskette_current_cyl(drive, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4957       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4958       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4959     case 0x08:
! 4960 ;
.6FD:
!BCC_EOS
! 4961       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4962       if (drive > 1) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
jbe 	.6FE
.6FF:
! 4963         AX = 0;
! Debug: eq int = const 0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ax,ax
mov	$16[bp],ax
!BCC_EOS
! 4964         BX = 0;
! Debug: eq int = const 0 to unsigned short BX = [S+$20+$E] (used reg = )
xor	ax,ax
mov	$10[bp],ax
!BCC_EOS
! 4965         CX = 0;
! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
xor	ax,ax
mov	$14[bp],ax
!BCC_EOS
! 4966         DX = 0;
! Debug: eq int = const 0 to unsigned short DX = [S+$20+$10] (used reg = )
xor	ax,ax
mov	$12[bp],ax
!BCC_EOS
! 4967         ES = 0;
! Debug: eq int = const 0 to unsigned short ES = [S+$20+4] (used reg = )
xor	ax,ax
mov	6[bp],ax
!BCC_EOS
! 4968         DI = 0;
! Debug: eq int = const 0 to unsigned short DI = [S+$20+6] (used reg = )
xor	ax,ax
mov	8[bp],ax
!BCC_EOS
! 4969         DX = ((DX & 0xff00) | (num_floppies));
! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
or	al,-$19[bp]
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4970         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4971         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4972       }
! 4973       drive_type = inb_cmos(0x10);
.6FE:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	-$18[bp],al
!BCC_EOS
! 4974       num_floppies = 0;
! Debug: eq int = const 0 to unsigned char num_floppies = [S+$20-$1B] (used reg = )
xor	al,al
mov	-$19[bp],al
!BCC_EOS
! 4975  
! 4975      if (drive_type & 0xf0)
! Debug: and int = const $F0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,#$F0
test	al,al
je  	.700
.701:
! 4976         num_floppies++;
! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
mov	al,-$19[bp]
inc	ax
mov	-$19[bp],al
!BCC_EOS
! 4977       if (drive_type & 0x0f)
.700:
! Debug: and int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,*$F
test	al,al
je  	.702
.703:
! 4978         num_floppies++;
! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
mov	al,-$19[bp]
inc	ax
mov	-$19[bp],al
!BCC_EOS
! 4979       if (drive == 0)
.702:
! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.704
.705:
! 4980         drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-$18[bp],al
!BCC_EOS
! 4981       else
! 4982         drive_type &= 0x0f;
jmp .706
.704:
! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,*$F
mov	-$18[bp],al
!BCC_EOS
! 4983       BX = ((BX & 0x00ff) | ((0) << 8));
.706:
! Debug: and int = const $FF to unsigned short BX = [S+$20+$E] (used reg = )
mov	al,$10[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short BX = [S+$20+$E] (used reg = )
xor	ah,ah
mov	$10[bp],ax
!BCC_EOS
! 4984       BX = ((BX & 0xff00) | (drive_type));
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$20+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or unsigned char drive_type = [S+$20-$1A] to unsigned int = ax+0 (used reg = )
or	al,-$18[bp]
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$20+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
! 4985       AX = ((AX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4986       AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4987       DX = ((DX & 0xff00) | (num_floppies));
! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
or	al,-$19[bp]
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4988       switch (drive_type) {
mov	al,-$18[bp]
br 	.709
! 4989         case 0:
! 4990           CX = 0;
.70A:
! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
xor	ax,ax
mov	$14[bp],ax
!BCC_EOS
! 4991           DX = ((DX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
xor	ah,ah
mov	$12[bp],ax
!BCC_EOS
! 4992           break;
br 	.707
!BCC_EOS
! 4993         case 1:
! 4994           CX = 0x2709;
.70B:
! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$2709
mov	$14[bp],ax
!BCC_EOS
! 4995           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4996           break;
br 	.707
!BCC_EOS
! 4997         case 2:
! 4998           CX = 0x4f0f;
.70C:
! Debug: eq int = const $4F0F to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$4F0F
mov	$14[bp],ax
!BCC_EOS
! 4999           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 5000           break;
br 	.707
!BCC_EOS
! 5001         case 3:
! 5002           CX = 0x4f09;
.70D:
! Debug: eq int = const $4F09 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$4F09
mov	$14[bp],ax
!BCC_EOS
! 5003           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 5004           break;
br 	.707
!BCC_EOS
! 5005         case 4:
! 5006           CX = 0x4f12;
.70E:
! Debug: eq int = const $4F12 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$4F12
mov	$14[bp],ax
!BCC_EOS
! 5007           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 5008           break;
br 	.707
!BCC_EOS
! 5009         case 5:
! 5010           CX = 0x4f24;
.70F:
! Debug: eq int = const $4F24 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$4F24
mov	$14[bp],ax
!BCC_EOS
! 5011           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 5012           break;
jmp .707
!BCC_EOS
! 5013         case 6:
! 5014           CX = 0x2708;
.710:
! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$2708
mov	$14[bp],ax
!BCC_EOS
! 5015           DX = ((DX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
xor	ah,ah
mov	$12[bp],ax
!BCC_EOS
! 5016           break;
jmp .707
!BCC_EOS
! 5017         case 7:
! 5018           CX = 0x2709;
.711:
! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$2709
mov	$14[bp],ax
!BCC_EOS
! 5019           DX = ((DX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
xor	ah,ah
mov	$12[bp],ax
!BCC_EOS
! 5020           break;
jmp .707
!BCC_EOS
! 5021         case 8:
! 5022           CX = 0x2708;
.712:
! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$2708
mov	$14[bp],ax
!BCC_EOS
! 5023           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 5024           break;
jmp .707
!BCC_EOS
! 5025         default:
! 5026           bios_printf((2 | 4 | 1), "floppy: int13: bad floppy type\n");
.713:
! Debug: list * char = .714+0 (used reg = )
mov	bx,#.714
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 5027         }
! 5028 #asm
jmp .707
.709:
sub	al,*0
jb 	.713
cmp	al,*8
ja  	.715
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.716[bx]
.716:
.word	.70A
.word	.70B
.word	.70C
.word	.70D
.word	.70E
.word	.70F
.word	.710
.word	.711
.word	.712
.715:
jmp	.713
.707:
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
      push bp
      mov bp, sp
      mov ax, #diskette_param_table2
      mov _int13_diskette_function.DI+2[bp], ax
      mov _int13_diskette_function.ES+2[bp], cs
      pop bp
! 5035 endasm
!BCC_ENDASM
!BCC_EOS
! 5036       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 5037       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5038     case 0x15:
! 5039 ;
.717:
!BCC_EOS
! 5040       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5041       if (drive > 1) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
jbe 	.718
.719:
! 5042         AX = ((AX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 5043         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5044         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5045       }
! 5046       drive_type = inb_cmos(0x10);
.718:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	-$18[bp],al
!BCC_EOS
! 5047       if (drive == 0)
! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.71A
.71B:
! 5048         drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-$18[bp],al
!BCC_EOS
! 5049       else
! 5050         drive_type &= 0x0f;
jmp .71C
.71A:
! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,*$F
mov	-$18[bp],al
!BCC_EOS
! 5051       FLAGS &= 0xfffe;
.71C:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 5052       if (drive_type==0) {
! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
test	al,al
jne 	.71D
.71E:
! 5053         AX = ((AX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 5054       }
! 5055       
! 5055 else {
jmp .71F
.71D:
! 5056         AX = ((AX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5057       }
! 5058       return;
.71F:
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5059     case 0x16:
! 5060 ;
.720:
!BCC_EOS
! 5061       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5062       if (drive > 1) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
jbe 	.721
.722:
! 5063         AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5064         set_diskette_ret_status(0x01);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5065         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5066         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5067       }
! 5068       AX = ((AX & 0x00ff) | ((0x06) << 8));
.721:
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$600
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5069       set_diskette_ret_status(0x06);
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5070       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5071       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5072     case 0x17:
! 5073 ;
.723:
!BCC_EOS
! 5074       AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5075       set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5076       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5077       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5078     case 0x18:
! 5079 ;
.724:
!BCC_EOS
! 5080       AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5081       set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5082       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5083       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5084     default:
! 5085         bios_printf(4, "int13_diskette: unsupported AH=%02x\n", ( AX >> 8 ));
.725:
! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .726+0 (used reg = )
mov	bx,#.726
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 5086         AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5087         set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5088         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5089         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5090     }
! 5091 }
jmp .697
.699:
sub	al,*0
jb 	.725
cmp	al,*8
ja  	.727
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.728[bx]
.728:
.word	.69A
.word	.6A2
.word	.6A5
.word	.6A6
.word	.6A7
.word	.6DD
.word	.725
.word	.725
.word	.6FD
.727:
sub	al,*$15
beq 	.717
sub	al,*1
beq 	.720
sub	al,*1
beq 	.723
sub	al,*1
beq 	.724
jmp	.725
.697:
..FFDC	=	-$20
mov	sp,bp
pop	bp
ret
! 5092  void
! Register BX used in function int13_diskette_function
! 5093 set_diskette_ret_status(value)
! 5094   Bit8u value;
export	_set_diskette_ret_status
_set_diskette_ret_status:
!BCC_EOS
! 5095 {
! 5096   write_byte(0x0040, 0x0041, value);
push	bp
mov	bp,sp
! Debug: list unsigned char value = [S+2+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
mov	sp,bp
!BCC_EOS
! 5097 }
pop	bp
ret
! 5098   void
! 5099 set_diskette_current_cyl(drive, cyl)
! 5100   Bit8u drive;
export	_set_diskette_current_cyl
_set_diskette_current_cyl:
!BCC_EOS
! 5101   Bit8u cyl;
!BCC_EOS
! 5102 {
! 5103   if (drive > 1)
push	bp
mov	bp,sp
! Debug: gt int = const 1 to unsigned char drive = [S+2+2] (used reg = )
mov	al,4[bp]
cmp	al,*1
jbe 	.729
.72A:
! 5104     bios_printf((2 | 4 | 1), "set_diskette_current_cyl(): drive > 1\n");
! Debug: list * char = .72B+0 (used reg = )
mov	bx,#.72B
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 5105   write_byte(0x0040, 0x0094+drive, cyl);
.729:
! Debug: list unsigned char cyl = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: add unsigned char drive = [S+4+2] to int = const $94 (used reg = )
! Debug: expression subtree swapping
mov	al,4[bp]
xor	ah,ah
! Debug: list unsigned int = ax+$94 (used reg = )
add	ax,#$94
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
mov	sp,bp
!BCC_EOS
! 5106 }
pop	bp
ret
! 5107   void
! Register BX used in function set_diskette_current_cyl
! 5108 determine_floppy_media(drive)
! 5109   Bit16u drive;
export	_determine_floppy_media
_determine_floppy_media:
!BCC_EOS
! 5110 {
! 5111 }
ret
! 5112   void
! 5113 int17_function(regs, ds, iret_addr)
! 5114   pusha_regs_t regs;
export	_int17_function
_int17_function:
!BCC_EOS
! 5115   Bit16u ds;
!BCC_EOS
! 5116   iret_addr_t iret_addr;
!BCC_EOS
! 5117 {
! 5118   Bit16u addr,timeout;
!BCC_EOS
! 5119   Bit8u val8;
!BCC_EOS
! 5120 #asm
push	bp
mov	bp,sp
add	sp,*-6
!BCC_EOS
!BCC_ASM
_int17_function.ds	set	$1A
.int17_function.ds	set	$14
_int17_function.timeout	set	2
.int17_function.timeout	set	-4
_int17_function.val8	set	1
.int17_function.val8	set	-5
_int17_function.iret_addr	set	$1C
.int17_function.iret_addr	set	$16
_int17_function.addr	set	4
.int17_function.addr	set	-2
_int17_function.regs	set	$A
.int17_function.regs	set	4
  sti
! 5122 endasm
!BCC_ENDASM
!BCC_EOS
! 5123   addr = read_word(0x0040, (regs.u.r16.dx << 1) + 8);
! Debug: sl int = const 1 to unsigned short regs = [S+8+$C] (used reg = )
mov	ax,$E[bp]
shl	ax,*1
! Debug: add int = const 8 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+8-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 5124   if ((regs.u.r8.ah < 3) && (regs.u.r16.dx < 3) && (addr > 0)) {
! Debug: lt int = const 3 to unsigned char regs = [S+8+$11] (used reg = )
mov	al,$13[bp]
cmp	al,*3
bhis	.72C
.72F:
! Debug: lt int = const 3 to unsigned short regs = [S+8+$C] (used reg = )
mov	ax,$E[bp]
cmp	ax,*3
bhis	.72C
.72E:
! Debug: gt int = const 0 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
beq 	.72C
.72D:
! 5125     timeout = read_byte(0x0040, 0x0078 + regs.u.r16.dx) << 8;
! Debug: add unsigned short regs = [S+8+$C] to int = const $78 (used reg = )
! Debug: expression subtree swapping
mov	ax,$E[bp]
! Debug: list unsigned int = ax+$78 (used reg = )
add	ax,*$78
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: eq unsigned int = ax+0 to unsigned short timeout = [S+8-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 5126     if (regs.u.r8.ah == 0) {
! Debug: logeq int = const 0 to unsigned char regs = [S+8+$11] (used reg = )
mov	al,$13[bp]
test	al,al
jne 	.730
.731:
! 5127       outb(addr, regs.u.r8.al);
! Debug: list unsigned char regs = [S+8+$10] (used reg = )
mov	al,$12[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short addr = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5128       val8 = inb(addr+2);
! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5129       outb(addr+2, val8 | 0x01);
! Debug: or int = const 1 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
or	al,*1
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5130 #asm
!BCC_EOS
!BCC_ASM
_int17_function.ds	set	$1A
.int17_function.ds	set	$14
_int17_function.timeout	set	2
.int17_function.timeout	set	-4
_int17_function.val8	set	1
.int17_function.val8	set	-5
_int17_function.iret_addr	set	$1C
.int17_function.iret_addr	set	$16
_int17_function.addr	set	4
.int17_function.addr	set	-2
_int17_function.regs	set	$A
.int17_function.regs	set	4
      nop
! 5132 endasm
!BCC_ENDASM
!BCC_EOS
! 5133       outb(addr+2, val8 & ~0x01);
! Debug: and int = const -2 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FE
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5134       while (((inb(addr+1) & 0x40) == 0x40) && (timeout)) {
jmp .733
.734:
! 5135         timeout--;
! Debug: postdec unsigned short timeout = [S+8-6] (used reg = )
mov	ax,-4[bp]
dec	ax
mov	-4[bp],ax
!BCC_EOS
! 5136       }
! 5137     }
.733:
! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const $40 to unsigned char = al+0 (used reg = )
and	al,*$40
! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
jne 	.735
.736:
mov	ax,-4[bp]
test	ax,ax
jne	.734
.735:
.732:
! 5138     if (regs.u.r8.ah == 1) {
.730:
! Debug: logeq int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
mov	al,$13[bp]
cmp	al,*1
jne 	.737
.738:
! 5139       val8 = inb(addr+2);
! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5140       outb(addr+2, val8 & ~0x04);
! Debug: and int = const -5 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FB
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5141 #asm
!BCC_EOS
!BCC_ASM
_int17_function.ds	set	$1A
.int17_function.ds	set	$14
_int17_function.timeout	set	2
.int17_function.timeout	set	-4
_int17_function.val8	set	1
.int17_function.val8	set	-5
_int17_function.iret_addr	set	$1C
.int17_function.iret_addr	set	$16
_int17_function.addr	set	4
.int17_function.addr	set	-2
_int17_function.regs	set	$A
.int17_function.regs	set	4
      nop
! 5143 endasm
!BCC_ENDASM
!BCC_EOS
! 5144       outb(addr+2, val8 | 0x04);
! Debug: or int = const 4 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
or	al,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5145     }
! 5146     val8 = inb(addr+1);
.737:
! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5147     regs.u.r8.ah = (va
! 5147 l8 ^ 0x48);
! Debug: eor int = const $48 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	al,*$48
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+8+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 5148     if (!timeout) regs.u.r8.ah |= 0x01;
mov	ax,-4[bp]
test	ax,ax
jne 	.739
.73A:
! Debug: orab int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
mov	al,$13[bp]
or	al,*1
mov	$13[bp],al
!BCC_EOS
! 5149     iret_addr.flags.u.r8.flagsl &= 0xfe;
.739:
! Debug: andab int = const $FE to unsigned char iret_addr = [S+8+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5150   } else {
jmp .73B
.72C:
! 5151     iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+8+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5152   }
! 5153 }
.73B:
mov	sp,bp
pop	bp
ret
! 5154 void
! 5155 int19_function(seq_nr)
! 5156 Bit16u seq_nr;
export	_int19_function
_int19_function:
!BCC_EOS
! 5157 {
! 5158   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 5159   Bit16u bootdev;
!BCC_EOS
! 5160   Bit8u bootdrv;
!BCC_EOS
! 5161   Bit8u bootchk;
!BCC_EOS
! 5162   Bit16u bootseg;
!BCC_EOS
! 5163   Bit16u bootip;
!BCC_EOS
! 5164   Bit16u status;
!BCC_EOS
! 5165   Bit16u bootfirst;
!BCC_EOS
! 5166   ipl_entry_t e;
!BCC_EOS
! 5167   bootdev = inb_cmos(0x3d);
add	sp,*-$1C
! Debug: list int = const $3D (used reg = )
mov	ax,*$3D
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned short bootdev = [S+$20-6] (used reg = )
xor	ah,ah
mov	-4[bp],ax
!BCC_EOS
! 5168   bootdev |= ((inb_cmos(0x38) & 0xf0) << 4);
! Debug: list int = const $38 (used reg = )
mov	ax,*$38
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const $F0 to unsigned char = al+0 (used reg = )
and	al,#$F0
! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cl,*4
shl	ax,cl
! Debug: orab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
or	ax,-4[bp]
mov	-4[bp],ax
!BCC_EOS
! 5169   bootdev >>= 4 * seq_nr;
! Debug: mul unsigned short seq_nr = [S+$20+2] to int = const 4 (used reg = )
! Debug: expression subtree swapping
mov	ax,4[bp]
shl	ax,*1
shl	ax,*1
! Debug: srab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
mov	bx,ax
mov	ax,-4[bp]
mov	cx,bx
shr	ax,cl
mov	-4[bp],ax
!BCC_EOS
! 5170   bootdev &= 0xf;
! Debug: andab int = const $F to unsigned short bootdev = [S+$20-6] (used reg = )
mov	al,-4[bp]
and	al,*$F
xor	ah,ah
mov	-4[bp],ax
!BCC_EOS
! 5171   bootfirst = read_word(0x9ff0, 0x0084);
! Debug: list int = const $84 (used reg = )
mov	ax,#$84
push	ax
! Debug: list unsigned int = const $9FF0 (used reg = )
mov	ax,#$9FF0
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short bootfirst = [S+$20-$10] (used reg = )
mov	-$E[bp],ax
!BCC_EOS
! 5172   if (bootfirst != 0xFFFF) {
! Debug: ne unsigned int = const $FFFF to unsigned short bootfirst = [S+$20-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,#$FFFF
je  	.73C
.73D:
! 5173     bootdev = bootfirst;
! Debug: eq unsigned short bootfirst = [S+$20-$10] to unsigned short bootdev = [S+$20-6] (used reg = )
mov	ax,-$E[bp]
mov	-4[bp],ax
!BCC_EOS
! 5174     write_word(0x9ff0, 0x0084, 0xFFFF);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: list int = const $84 (used reg = )
mov	ax,#$84
push	ax
! Debug: list unsigned int = const $9FF0 (used reg = )
mov	ax,#$9FF0
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 5175     write_word(0x9ff0, 0x0082, 0xFFFF);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: list int = const $82 (used reg = )
mov	ax,#$82
push	ax
! Debug: list unsigned int = const $9FF0 (used reg = )
mov	ax,#$9FF0
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 5176   } else if (bootdev == 0) bios_printf((2 | 4 | 1), "No bootable device.\n");
jmp .73E
.73C:
! Debug: logeq int = const 0 to unsigned short bootdev = [S+$20-6] (used reg = )
mov	ax,-4[bp]
test	ax,ax
jne 	.73F
.740:
! Debug: list * char = .741+0 (used reg = )
mov	bx,#.741
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 5177   bootdev -= 1;
.73F:
.73E:
! Debug: subab int = const 1 to unsigned short bootdev = [S+$20-6] (used reg = )
mov	ax,-4[bp]
dec	ax
mov	-4[bp],ax
!BCC_EOS
! 5178   if (get_boot_vector(bootdev, &e) == 0) {
! Debug: list * struct  e = S+$20-$20 (used reg = )
lea	bx,-$1E[bp]
push	bx
! Debug: list unsigned short bootdev = [S+$22-6] (used reg = )
push	-4[bp]
! Debug: func () unsigned char = get_boot_vector+0 (used reg = )
call	_get_boot_vector
add	sp,*4
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.742
.743:
! 5179     bios_printf(4, "Invalid boot device (0x%x)\n", bootdev);
! Debug: list unsigned short bootdev = [S+$20-6] (used reg = )
push	-4[bp]
! Debug: list * char = .744+0 (used reg = )
mov	bx,#.744
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 5180     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5181   }
! 5182   print_boot_device(&e);
.742:
! Debug: list * struct  e = S+$20-$20 (used reg = )
lea	bx,-$1E[bp]
push	bx
! Debug: func () void = print_boot_device+0 (used reg = )
call	_print_boot_device
inc	sp
inc	sp
!BCC_EOS
! 5183   switch(e.type) {
mov	ax,-$1E[bp]
br 	.747
! 5184   case 0x01:
! 5185   case 0x02:
.748:
! 5186     bootdrv = (e.type == 0x02) ? 0x80 : 0x00;
.749:
! Debug: logeq int = const 2 to unsigned short e = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,*2
jne 	.74A
.74B:
mov	al,#$80
jmp .74C
.74A:
xor	al,al
.74C:
! Debug: eq char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5187     bootseg = 0x07c0;
! Debug: eq int = const $7C0 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,#$7C0
mov	-8[bp],ax
!BCC_EOS
! 5188     status = 0;
! Debug: eq int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
xor	ax,ax
mov	-$C[bp],ax
!BCC_EOS
! 5189 #asm
!BCC_EOS
!BCC_ASM
_int19_function.bootip	set	$14
.int19_function.bootip	set	-$A
_int19_function.seq_nr	set	$22
.int19_function.seq_nr	set	4
_int19_function.bootchk	set	$18
.int19_function.bootchk	set	-6
_int19_function.bootseg	set	$16
.int19_function.bootseg	set	-8
_int19_function.ebda_seg	set	$1C
.int19_function.ebda_seg	set	-2
_int19_function.status	set	$12
.int19_function.status	set	-$C
_int19_function.bootfirst	set	$10
.int19_function.bootfirst	set	-$E
_int19_function.bootdrv	set	$19
.int19_function.bootdrv	set	-5
_int19_function.bootdev	set	$1A
.int19_function.bootdev	set	-4
_int19_function.e	set	0
.int19_function.e	set	-$1E
    push bp
    mov bp, sp
    push ax
    push bx
    push cx
    push dx
    mov dl, _int19_function.bootdrv + 2[bp]
    mov ax, _int19_function.bootseg + 2[bp]
    mov es, ax ;; segment
    xor bx, bx ;; offset
    mov ah, #0x02 ;; function 2, read diskette sector
    mov al, #0x01 ;; read 1 sector
    mov ch, #0x00 ;; track 0
    mov cl, #0x01 ;; sector 1
    mov dh, #0x00 ;; head 0
    int #0x13 ;; read sector
    jnc int19_load_done
    mov ax, #0x0001
    mov _int19_function.status + 2[bp], ax
int19_load_done:
    pop dx
    pop cx
    pop bx
    pop ax
    pop bp
! 5215 endasm
!BCC_ENDASM
!BCC_EOS
! 5216     if (status != 0) {
! Debug: ne int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
test	ax,ax
je  	.74D
.74E:
! 5217       print_boot_failure(e.type, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list unsigned short e = [S+$22-$20] (used reg = )
push	-$1E[bp]
! Debug: func () void = print_boot_failure+0 (used reg = )
call	_print_boot_failure
add	sp,*4
!BCC_EOS
! 5218       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5219     }
! 5220     if ((e.type != 0x01) || !((inb_cmos(0x38) & 0x01))) {
.74D:
! Debug: ne int = const 1 to unsigned short e = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,*1
jne 	.750
.751:
! Debug: list int = const $38 (used reg = )
mov	ax,*$38
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
test	al,al
jne 	.74F
.750:
! 5221       if (read_word(bootseg,0x1fe) != 0xaa55) {
! Debug: list int = const $1FE (used reg = )
mov	ax,#$1FE
push	ax
! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
push	-8[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: ne unsigned int = const $AA55 to unsigned short = ax+0 (used reg = )
cmp	ax,#$AA55
je  	.752
.753:
! 5222         print_boot_failure(e.type, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short e = [S+$22-$20] (used reg = )
push	-$1E[bp]
! Debug: func () void = print_boot_failure+0 (used reg = )
call	_print_boot_failure
add	sp,*4
!BCC_EOS
! 5223         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5224       }
! 5225     }
.752:
! 5226     bootip = (bootseg & 0x0fff) << 4;
.74F:
! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
and	ax,#$FFF
! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 5227     bootseg &= 0xf000;
! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
and	ax,#$F000
mov	-8[bp],ax
!BCC_EOS
! 5228   break;
br 	.745
!BCC_EOS
! 5229   case 0x03:
! 5230     status = cdrom_boot();
.754:
! Debug: func () unsigned short = cdrom_boot+0 (used reg = )
call	_cdrom_boot
! Debug: eq unsigned short = ax+0 to unsigned short status = [S+$20-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 5231     if ( (status & 0x00ff) !=0 ) {
! Debug: and int = const $FF to unsigned short status = [S+$20-$E] (used reg = )
mov	al,-$C[bp]
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.755
.756:
! 5232       print_cdro
! 5232 mboot_failure(status);
! Debug: list unsigned short status = [S+$20-$E] (used reg = )
push	-$C[bp]
! Debug: func () void = print_cdromboot_failure+0 (used reg = )
call	_print_cdromboot_failure
inc	sp
inc	sp
!BCC_EOS
! 5233       print_boot_failure(e.type, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list unsigned short e = [S+$22-$20] (used reg = )
push	-$1E[bp]
! Debug: func () void = print_boot_failure+0 (used reg = )
call	_print_boot_failure
add	sp,*4
!BCC_EOS
! 5234       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5235     }
! 5236     bootdrv = (Bit8u)(status>>8);
.755:
! Debug: sr int = const 8 to unsigned short status = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
mov	al,ah
xor	ah,ah
! Debug: cast unsigned char = const 0 to unsigned int = ax+0 (used reg = )
! Debug: eq unsigned char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5237     bootseg = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment);
! Debug: list * unsigned short = const $266 (used reg = )
mov	ax,#$266
push	ax
! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 5238     bootip = 0;
! Debug: eq int = const 0 to unsigned short bootip = [S+$20-$C] (used reg = )
xor	ax,ax
mov	-$A[bp],ax
!BCC_EOS
! 5239     break;
jmp .745
!BCC_EOS
! 5240   case 0x80:
! 5241     bootseg = e.vector >> 16;
.757:
! Debug: sr int = const $10 to unsigned long e = [S+$20-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 5242     bootip = e.vector & 0xffff;
! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$20-$1C] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FFFF
xor	bx,bx
lea	di,-$1A[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned short bootip = [S+$20-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 5243     break;
jmp .745
!BCC_EOS
! 5244   default: return;
.758:
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5245   }
! 5246   bios_printf(4, "Booting from %x:%x\n", bootseg, bootip);
jmp .745
.747:
sub	ax,*1
beq 	.748
sub	ax,*1
beq 	.749
sub	ax,*1
beq 	.754
sub	ax,*$7D
je 	.757
jmp	.758
.745:
..FFDB	=	-$20
! Debug: list unsigned short bootip = [S+$20-$C] (used reg = )
push	-$A[bp]
! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
push	-8[bp]
! Debug: list * char = .759+0 (used reg = )
mov	bx,#.759
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 5247 #asm
!BCC_EOS
!BCC_ASM
_int19_function.bootip	set	$14
.int19_function.bootip	set	-$A
_int19_function.seq_nr	set	$22
.int19_function.seq_nr	set	4
_int19_function.bootchk	set	$18
.int19_function.bootchk	set	-6
_int19_function.bootseg	set	$16
.int19_function.bootseg	set	-8
_int19_function.ebda_seg	set	$1C
.int19_function.ebda_seg	set	-2
_int19_function.status	set	$12
.int19_function.status	set	-$C
_int19_function.bootfirst	set	$10
.int19_function.bootfirst	set	-$E
_int19_function.bootdrv	set	$19
.int19_function.bootdrv	set	-5
_int19_function.bootdev	set	$1A
.int19_function.bootdev	set	-4
_int19_function.e	set	0
.int19_function.e	set	-$1E
    mov bp, sp
    push cs
    push #int18_handler
    ;; Build an iret stack frame that will take us to the boot vector.
    ;; iret pops ip, then cs, then flags, so push them in the opposite order.
    pushf
    mov ax, _int19_function.bootseg + 0[bp]
    push ax
    mov ax, _int19_function.bootip + 0[bp]
    push ax
    ;; Set the magic number in ax and the boot drive in dl.
    mov ax, #0xaa55
    mov dl, _int19_function.bootdrv + 0[bp]
    ;; Zero some of the other registers.
    xor bx, bx
    mov ds, bx
    mov es, bx
    mov bp, bx
    ;; Go!
    iret
! 5268 endasm
!BCC_ENDASM
!BCC_EOS
! 5269 }
mov	sp,bp
pop	bp
ret
! 5270   void
! Register BX used in function int19_function
! 5271 int1a_function(regs, ds, iret_addr)
! 5272   pusha_regs_t regs;
export	_int1a_function
_int1a_function:
!BCC_EOS
! 5273   Bit16u ds;
!BCC_EOS
! 5274   iret_addr_t iret_addr;
!BCC_EOS
! 5275 {
! 5276   Bit8u val8;
!BCC_EOS
! 5277   ;
push	bp
mov	bp,sp
dec	sp
dec	sp
!BCC_EOS
! 5278 #asm
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
  sti
! 5280 endasm
!BCC_ENDASM
!BCC_EOS
! 5281   switch (regs.u.r8.ah) {
mov	al,$13[bp]
br 	.75C
! 5282     case 0:
! 5283 #asm
.75D:
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
      cli
! 5285 endasm
!BCC_ENDASM
!BCC_EOS
! 5286       regs.u.r16.cx = ((bios_data_t *) 0)->ticks_high;
! Debug: eq unsigned short = [+$46E] to unsigned short regs = [S+4+$E] (used reg = )
mov	ax,[$46E]
mov	$10[bp],ax
!BCC_EOS
! 5287       regs.u.r16.dx = ((bios_data_t *) 0)->ticks_low;
! Debug: eq unsigned short = [+$46C] to unsigned short regs = [S+4+$C] (used reg = )
mov	ax,[$46C]
mov	$E[bp],ax
!BCC_EOS
! 5288       regs.u.r8.al = ((bios_data_t *) 0)->midnight_flag;
! Debug: eq unsigned char = [+$470] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,[$470]
mov	$12[bp],al
!BCC_EOS
! 5289       ((bios_data_t *) 0)->midnight_flag = 0;
! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
xor	al,al
mov	[$470],al
!BCC_EOS
! 5290 #asm
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
      sti
! 5292 endasm
!BCC_ENDASM
!BCC_EOS
! 5293       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5294       break;
br 	.75A
!BCC_EOS
! 5295     case 1:
! 5296 #asm
.75E:
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
      cli
! 5298 endasm
!BCC_ENDASM
!BCC_EOS
! 5299       ((bios_data_t *) 0)->ticks_high = regs.u.r16.cx;
! Debug: eq unsigned short regs = [S+4+$E] to unsigned short = [+$46E] (used reg = )
mov	ax,$10[bp]
mov	[$46E],ax
!BCC_EOS
! 5300       ((bios_data_t *) 0)->ticks_low = regs.u.r16.dx;
! Debug: eq unsigned short regs = [S+4+$C] to unsigned short = [+$46C] (used reg = )
mov	ax,$E[bp]
mov	[$46C],ax
!BCC_EOS
! 5301       ((bios_data_t *) 0)->midnight_flag = 0;
! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
xor	al,al
mov	[$470],al
!BCC_EOS
! 5302 #asm
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
      sti
! 5304 endasm
!BCC_ENDASM
!BCC_EOS
! 5305       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5306       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5307       break;
br 	.75A
!BCC_EOS
! 5308     case 2:
! 5309       if (rtc_updating()) {
.75F:
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.760
.761:
! 5310         iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5311         break;
br 	.75A
!BCC_EOS
! 5312       }
! 5313       regs.u.r8.dh = inb_cmos(0x00);
.760:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
mov	$F[bp],al
!BCC_EOS
! 5314       regs.u.r8.cl = inb_cmos(0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
mov	$10[bp],al
!BCC_EOS
! 5315       regs.u.r8.ch = inb_cmos(0x04);
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
mov	$11[bp],al
!BCC_EOS
! 5316       regs.u.r8.dl = inb_cmos(0x0b) & 0x01;
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
mov	$E[bp],al
!BCC_EOS
! 5317       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5318       reg
! 5318 s.u.r8.al = regs.u.r8.ch;
! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,$11[bp]
mov	$12[bp],al
!BCC_EOS
! 5319       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5320       break;
br 	.75A
!BCC_EOS
! 5321     case 3:
! 5322       if (rtc_updating()) {
.762:
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.763
.764:
! 5323         init_rtc();
! Debug: func () void = init_rtc+0 (used reg = )
call	_init_rtc
!BCC_EOS
! 5324       }
! 5325       outb_cmos(0x00, regs.u.r8.dh);
.763:
! Debug: list unsigned char regs = [S+4+$D] (used reg = )
mov	al,$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5326       outb_cmos(0x02, regs.u.r8.cl);
! Debug: list unsigned char regs = [S+4+$E] (used reg = )
mov	al,$10[bp]
xor	ah,ah
push	ax
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5327       outb_cmos(0x04, regs.u.r8.ch);
! Debug: list unsigned char regs = [S+4+$F] (used reg = )
mov	al,$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5328       val8 = (inb_cmos(0x0b) & 0x60) | 0x02 | (regs.u.r8.dl & 0x01);
! Debug: expression subtree swapping
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
and	al,*$60
! Debug: or int = const 2 to unsigned char = al+0 (used reg = )
or	al,*2
push	ax
! Debug: and int = const 1 to unsigned char regs = [S+6+$C] (used reg = )
mov	al,$E[bp]
and	al,*1
! Debug: or unsigned char (temp) = [S+6-6] to unsigned char = al+0 (used reg = )
or	al,0+..FFDA[bp]
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5329       outb_cmos(0x0b, val8);
! Debug: list unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5330       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5331       regs.u.r8.al = val8;
! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,-1[bp]
mov	$12[bp],al
!BCC_EOS
! 5332       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5333       break;
br 	.75A
!BCC_EOS
! 5334     case 4:
! 5335       regs.u.r8.ah = 0;
.765:
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5336       if (rtc_updating()) {
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.766
.767:
! 5337         iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5338         break;
br 	.75A
!BCC_EOS
! 5339       }
! 5340       regs.u.r8.cl = inb_cmos(0x09);
.766:
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
mov	$10[bp],al
!BCC_EOS
! 5341       regs.u.r8.dh = inb_cmos(0x08);
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
mov	$F[bp],al
!BCC_EOS
! 5342       regs.u.r8.dl = inb_cmos(0x07);
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
mov	$E[bp],al
!BCC_EOS
! 5343       regs.u.r8.ch = inb_cmos(0x32);
! Debug: list int = const $32 (used reg = )
mov	ax,*$32
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
mov	$11[bp],al
!BCC_EOS
! 5344       regs.u.r8.al = regs.u.r8.ch;
! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,$11[bp]
mov	$12[bp],al
!BCC_EOS
! 5345       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5346       break;
br 	.75A
!BCC_EOS
! 5347     case 5:
! 5348       if (rtc_updating()) {
.768:
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.769
.76A:
! 5349         init_rtc();
! Debug: func () void = init_rtc+0 (used reg = )
call	_init_rtc
!BCC_EOS
! 5350         iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5351         break;
br 	.75A
!BCC_EOS
! 5352         }
! 5353       outb_cmos(0x09, regs.u.r8.cl);
.769:
! Debug: list unsigned char regs = [S+4+$E] (used reg = )
mov	al,$10[bp]
xor	ah,ah
push	ax
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5354       outb_cmos(0x08, regs.u.r8.dh);
! Debug: list unsigned char regs = [S+4+$D] (used reg = )
mov	al,$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5355       outb_cmos(0x07, regs.u.r8.dl);
! Debug: list unsigned char regs = [S+4+$C] (used reg = )
mov	al,$E[bp]
xor	ah,ah
push	ax
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5356       outb_cmos(0x32, regs.u.r8.ch);
! Debug: list unsigned char regs = [S+4+$F] (used reg = )
mov	al,$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const $32 (used reg = )
mov	ax,*$32
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5357       val8 = inb_cmos(0x0b) & 0x7f;
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const $7F to unsigned char = al+0 (used reg = )
and	al,*$7F
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5358       outb_cmos(0x0b, val8);
! Debug: list unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5359       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5360       regs.u.r8.al = val8;
! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,-1[bp]
mov	$12[bp],al
!BCC_EOS
! 5361       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5362       break;
br 	.75A
!BCC_EOS
! 5363     case 6:
! 5364       val8 = inb_cmos(0x0b);
.76B:
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5365       regs.u.r16.ax = 0;
! Debug: eq int = const 0 to unsigned short regs = [S+4+$10] (used reg = )
xor	ax,ax
mov	$12[bp],ax
!BCC_EOS
! 5366       if (val8 & 0x20) {
! Debug: and int = const $20 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$20
test	al,al
je  	.76C
.76D:
! 5367         iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5368         break;
br 	.75A
!BCC_EOS
! 5369       }
! 5370       if (rtc_updating()) {
.76C:
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.76E
.76F:
! 5371         init_rtc();
! Debug: func () void = init_rtc+0 (used reg = )
call	_init_rtc
!BCC_EOS
! 5372       }
! 5373       outb_cmos(0x01, regs.u.r8.dh);
.76E:
! Debug: list unsigned char regs = [S+4+$D] (used reg = )
mov	al,$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5374       outb_cmos(0x03, regs.u.r8.cl);
! Debug: list unsigned char regs = [S+4+$E] (used reg = )
mov	al,$10[bp]
xor	ah,ah
push	ax
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5375       outb_cmos(0x05, regs.u.r8.ch);
! Debug: list unsigned char regs = [S+4+$F] (used reg = )
mov	al,$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5376       outb(0xa1, inb(0xa1) & 0xfe);
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const $FE to unsigned char = al+0 (used reg = )
and	al,#$FE
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5377       outb_cmos(0x0b, (val8 & 0x7f) | 0x20);
! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
! Debug: or int = const $20 to unsigned char = al+0 (used reg = )
or	al,*$20
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5378       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5379       break;
br 	.75A
!BCC_EOS
! 5380     case 7:
! 5381       val8 = inb_cmos(0x0b);
.770:
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5382       outb_cmos(0x0b, val8 & 0x57);
! Debug: and int = const $57 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$57
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5383       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5384       regs.u.r8.al = val8;
! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,-1[bp]
mov	$12[bp],al
!BCC_EOS
! 5385       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5386       break;
br 	.75A
!BCC_EOS
! 5387     case 0xb1:
! 5388       if (regs.u.r8.bl == 0xff) {
.771:
! Debug: logeq int = const $FF to unsigned char regs = [S+4+$A] (used reg = )
mov	al,$C[bp]
cmp	al,#$FF
jne 	.772
.773:
! 5389         bios_printf(4, "PCI BIOS: PCI not present\n");
! Debug: list * char = .774+0 (used reg = )
mov	bx,#.774
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 5390       } el
! 5390 se if (regs.u.r8.bl == 0x81) {
br 	.775
.772:
! Debug: logeq int = const $81 to unsigned char regs = [S+4+$A] (used reg = )
mov	al,$C[bp]
cmp	al,#$81
jne 	.776
.777:
! 5391         bios_printf(4, "unsupported PCI BIOS function 0x%02x\n", regs.u.r8.al);
! Debug: list unsigned char regs = [S+4+$10] (used reg = )
mov	al,$12[bp]
xor	ah,ah
push	ax
! Debug: list * char = .778+0 (used reg = )
mov	bx,#.778
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 5392       } else if (regs.u.r8.bl == 0x83) {
jmp .779
.776:
! Debug: logeq int = const $83 to unsigned char regs = [S+4+$A] (used reg = )
mov	al,$C[bp]
cmp	al,#$83
jne 	.77A
.77B:
! 5393         bios_printf(4, "bad PCI vendor ID %04x\n", regs.u.r16.dx);
! Debug: list unsigned short regs = [S+4+$C] (used reg = )
push	$E[bp]
! Debug: list * char = .77C+0 (used reg = )
mov	bx,#.77C
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 5394       } else if (regs.u.r8.bl == 0x86) {
jmp .77D
.77A:
! Debug: logeq int = const $86 to unsigned char regs = [S+4+$A] (used reg = )
mov	al,$C[bp]
cmp	al,#$86
jne 	.77E
.77F:
! 5395         if (regs.u.r8.al == 0x02) {
! Debug: logeq int = const 2 to unsigned char regs = [S+4+$10] (used reg = )
mov	al,$12[bp]
cmp	al,*2
jne 	.780
.781:
! 5396           bios_printf(4, "PCI device %04x:%04x not found at index %d\n", regs.u.r16.dx, regs.u.r16.cx, regs.u.r16.si);
! Debug: list unsigned short regs = [S+4+4] (used reg = )
push	6[bp]
! Debug: list unsigned short regs = [S+6+$E] (used reg = )
push	$10[bp]
! Debug: list unsigned short regs = [S+8+$C] (used reg = )
push	$E[bp]
! Debug: list * char = .782+0 (used reg = )
mov	bx,#.782
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*$A
!BCC_EOS
! 5397         } else {
jmp .783
.780:
! 5398           bios_printf(4, "no PCI device with class code 0x%02x%04x found at index %d\n", regs.u.r8.cl, regs.u.r16.dx, regs.u.r16.si);
! Debug: list unsigned short regs = [S+4+4] (used reg = )
push	6[bp]
! Debug: list unsigned short regs = [S+6+$C] (used reg = )
push	$E[bp]
! Debug: list unsigned char regs = [S+8+$E] (used reg = )
mov	al,$10[bp]
xor	ah,ah
push	ax
! Debug: list * char = .784+0 (used reg = )
mov	bx,#.784
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*$A
!BCC_EOS
! 5399         }
! 5400       }
.783:
! 5401       regs.u.r8.ah = regs.u.r8.bl;
.77E:
.77D:
.779:
.775:
! Debug: eq unsigned char regs = [S+4+$A] to unsigned char regs = [S+4+$11] (used reg = )
mov	al,$C[bp]
mov	$13[bp],al
!BCC_EOS
! 5402       iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5403       break;
jmp .75A
!BCC_EOS
! 5404     default:
! 5405       iret_addr.flags.u.r8.flagsl |= 0x01;
.785:
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5406   }
! 5407 }
jmp .75A
.75C:
sub	al,*0
jb 	.785
cmp	al,*7
ja  	.786
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.787[bx]
.787:
.word	.75D
.word	.75E
.word	.75F
.word	.762
.word	.765
.word	.768
.word	.76B
.word	.770
.786:
sub	al,#$B1
beq 	.771
jmp	.785
.75A:
..FFDA	=	-4
mov	sp,bp
pop	bp
ret
! 5408   void
! Register BX used in function int1a_function
! 5409 int70_function(regs, ds, iret_addr)
! 5410   pusha_regs_t regs;
export	_int70_function
_int70_function:
!BCC_EOS
! 5411   Bit16u ds;
!BCC_EOS
! 5412   iret_addr_t iret_addr;
!BCC_EOS
! 5413 {
! 5414   Bit8u registerB = 0, registerC = 0;
push	bp
mov	bp,sp
dec	sp
! Debug: eq int = const 0 to unsigned char registerB = [S+3-3] (used reg = )
xor	al,al
mov	-1[bp],al
dec	sp
! Debug: eq int = const 0 to unsigned char registerC = [S+4-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 5415   registerB = inb_cmos( 0xB );
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char registerB = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5416   registerC = inb_cmos( 0xC );
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char registerC = [S+4-4] (used reg = )
mov	-2[bp],al
!BCC_EOS
! 5417   if( ( registerB & 0x60 ) != 0 ) {
! Debug: and int = const $60 to unsigned char registerB = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$60
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
beq 	.788
.789:
! 5418     if( ( registerC & 0x20 ) != 0 ) {
! Debug: and int = const $20 to unsigned char registerC = [S+4-4] (used reg = )
mov	al,-2[bp]
and	al,*$20
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.78A
.78B:
! 5419 #asm
!BCC_EOS
!BCC_ASM
_int70_function.registerC	set	0
.int70_function.registerC	set	-2
_int70_function.ds	set	$16
.int70_function.ds	set	$14
_int70_function.registerB	set	1
.int70_function.registerB	set	-1
_int70_function.iret_addr	set	$18
.int70_function.iret_addr	set	$16
_int70_function.regs	set	6
.int70_function.regs	set	4
      sti
      int #0x4a
      cli
! 5423 endasm
!BCC_ENDASM
!BCC_EOS
! 5424     }
! 5425     if( ( registerC & 0x40 ) != 0 ) {
.78A:
! Debug: and int = const $40 to unsigned char registerC = [S+4-4] (used reg = )
mov	al,-2[bp]
and	al,*$40
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
beq 	.78C
.78D:
! 5426       if( read_byte( 0x40, 0xA0 ) != 0 ) {
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
beq 	.78E
.78F:
! 5427         Bit32u time, toggle;
!BCC_EOS
! 5428         time = read_dword( 0x40, 0x9C );
add	sp,*-8
! Debug: list int = const $9C (used reg = )
mov	ax,#$9C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long time = [S+$C-8] (used reg = )
mov	-6[bp],ax
mov	-4[bp],bx
!BCC_EOS
! 5429         if( time < 0x3D1 ) {
! Debug: lt unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
mov	ax,#$3D1
xor	bx,bx
lea	di,-6[bp]
call	lcmpul
jbe 	.790
.791:
! 5430           Bit16u segment, offset;
!BCC_EOS
! 5431           segment = read_word( 0x40, 0x98 );
add	sp,*-4
! Debug: list int = const $98 (used reg = )
mov	ax,#$98
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$10-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 5432           offset = read_word( 0x40, 0x9A );
! Debug: list int = const $9A (used reg = )
mov	ax,#$9A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$10-$10] (used reg = )
mov	-$E[bp],ax
!BCC_EOS
! 5433           write_byte( 0x40, 0xA0, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 5434           outb_cmos( 0xB, registerB & 0x37 );
! Debug: and int = const $37 to unsigned char registerB = [S+$10-3] (used reg = )
mov	al,-1[bp]
and	al,*$37
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5435           write_byte(segment, offset, read_byte(segment, offset) | 0x80 );
! Debug: list unsigned short offset = [S+$10-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short segment = [S+$12-$E] (used reg = )
push	-$C[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
or	al,#$80
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list unsigned short offset = [S+$12-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short segment = [S+$14-$E] (used reg = )
push	-$C[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 5436         } else {
add	sp,*4
jmp .792
.790:
! 5437           time -= 0x3D1;
! Debug: subab unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
mov	ax,#$3D1
xor	bx,bx
push	bx
push	ax
mov	ax,-6[bp]
mov	bx,-4[bp]
lea	di,-$E[bp]
call	lsubul
mov	-6[bp],ax
mov	-4[bp],bx
add	sp,*4
!BCC_EOS
! 5438           write_dword( 0x40, 0x9C, time );
! Debug: list unsigned long time = [S+$C-8] (used reg = )
push	-4[bp]
push	-6[bp]
! Debug: list int = const $9C (used reg = )
mov	ax,#$9C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 5439         }
! 5440       }
.792:
add	sp,*8
! 5441     }
.78E:
! 5442   }
.78C:
! 5443 #asm
.788:
!BCC_EOS
!BCC_ASM
_int70_function.registerC	set	0
.int70_function.registerC	set	-2
_int70_function.ds	set	$16
.int70_function.ds	set	$14
_int70_function.registerB	set	1
.int70_function.registerB	set	-1
_int70_function.iret_addr	set	$18
.int70_function.iret_addr	set	$16
_int70_function.regs	set	6
.int70_function.regs	set	4
  call eoi_both_pics
! 5445 endasm
!BCC_ENDASM
!BCC_EOS
! 5446 }
mov	sp,bp
pop	bp
ret
! 5447 #asm
!BCC_ASM
_int70_function.ds	set	$12
_int70_function.iret_addr	set	$14
_int70_function.regs	set	2
;------------------------------------------
;- INT74h : PS/2 mouse hardware interrupt -
;------------------------------------------
int74_handler:
  sti
  pusha
  push ds ;; save DS
  push #0x00 ;; placeholder for status
  push #0x00 ;; placeholder for X
  push #0x00 ;; placeholder for Y
  push #0x00 ;; placeholder for Z
  push #0x00 ;; placeholder for make_far_call boolean
  call _int74_function
  pop cx ;; remove make_far_call from stack
  jcxz int74_done
  ;; make far call to EBDA:0022
  push #0x00
  pop ds
  push 0x040E ;; push 0000:040E (opcodes 0xff, 0x36, 0x0E, 0x04)
  pop ds
  call far ptr[0x22]
int74_done:
  cli
  call eoi_both_pics
  add sp, #8 ;; pop status, x, y, z
  pop ds ;; restore DS
  popa
  iret
;; This will perform an IRET, but will retain value of current CF
;; by altering flags on stack. Better than RETF #02.
iret_modify_cf:
  jc carry_set
  push bp
  mov bp, sp
  and BYTE [bp + 0x06], #0xfe
  pop bp
  iret
carry_set:
  push bp
  mov bp, sp
  or BYTE [bp + 0x06], #0x01
  pop bp
  iret
;----------------------
;- INT13h (relocated) -
;----------------------
;
; int13_relocated is a little bit messed up since I played with it
; I have to rewrite it:
; - call a function that detect which function to call
; - make all called C function get the same parameters list
;
int13_relocated:
  ;; check for an eltorito function
  cmp ah,#0x4a
  jb int13_not_eltorito
  cmp ah,#0x4d
  ja int13_not_eltorito
  pusha
  push es
  push ds
  push ss
  pop ds
  push #int13_out
  jmp _int13_eltorito ;; ELDX not used
int13_not_eltorito:
  push ax
  push bx
  push cx
  push dx
  ;; check if emulation active
  call _cdemu_isactive
  cmp al,#0x00
  je int13_cdemu_inactive
  ;; check if access to the emulated drive
  call _cdemu_emulated_drive
  pop dx
  push dx
  cmp al,dl ;; int13 on emulated drive
  jne int13_nocdemu
  pop dx
  pop cx
  pop bx
  pop ax
  pusha
  push es
  push ds
  push ss
  pop ds
  push #int13_out
  jmp _int13_cdemu ;; ELDX not used
int13_nocdemu:
  and dl,#0xE0 ;; mask to get device class, including cdroms
  cmp al,dl ;; al is 0x00 or 0x80
  jne int13_cdemu_inactive ;; inactive for device class
  pop dx
  pop cx
  pop bx
  pop ax
  push ax
  push cx
  push dx
  push bx
  dec dl ;; real drive is dl - 1
  jmp int13_legacy
int13_cdemu_inactive:
  pop dx
  pop cx
  pop bx
  pop ax
int13_noeltorito:
  push ax
  push cx
  push dx
  push bx
int13_legacy:
  push dx ;; push eltorito value of dx instead of sp
  push bp
  push si
  push di
  push es
  push ds
  push ss
  pop ds
  ;; now the 16-bit registers can be restored with:
  ;; pop ds; pop es; popa; iret
  ;; arguments passed to functions should be
  ;; DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS
  test dl, #0x80
  jnz int13_notfloppy
  push #int13_out
  jmp _int13_diskette_function
int13_notfloppy:
  cmp dl, #0xE0
  jb int13_notcdrom
  shr ebx, #16
  push bx
  call _int13_cdrom
  pop bx
  shl ebx, #16
  jmp int13_out
int13_notcdrom:
int13_disk:
  ;; int13_harddisk modifies high word of EAX
  shr eax, #16
  push ax
  call _int13_harddisk
  pop ax
  shl eax, #16
int13_out:
  pop ds
  pop es
  popa
  iret
;----------
;- INT18h -
;----------
int18_handler: ;; Boot Failure recovery: try the next device.
  ;; Reset SP and SS
  mov ax, #0xfffe
  mov sp, ax
  xor ax, ax
  mov ss, ax
  ;; Get the boot sequence number out of the IPL memory
  mov bx, #0x9ff0
  mov ds, bx ;; Set segment
  mov bx, 0x0082 ;; BX is now the sequence number
  inc bx ;; ++
  mov 0x0082, bx ;; Write it back
  mov ds, ax ;; and reset the segment to zero.
  ;; Carry on in the INT 19h handler, using the new sequence number
  push bx
  jmp int19_next_boot
;----------
;- INT19h -
;----------
int19_relocated: ;; Boot function, relocated
  ;; int19 was beginning to be really complex, so now it
  ;; just calls a C function that does the work
  push bp
  mov bp, sp
  ;; Reset SS and SP
  mov ax, #0xfffe
  mov sp, ax
  xor ax, ax
  mov ss, ax
  ;; Start from the first boot device (0, in AX)
  mov bx, #0x9ff0
  mov ds, bx ;; Set segment to write to the IPL memory
  mov 0x0082, ax ;; Save the sequence number
  mov ds, ax ;; and reset the segment.
  push ax
int19_next_boot:
  ;; Call the C code for the next boot device
  call _int19_function
  ;; Boot failed: invoke the boot recovery function
  int #0x18
;----------
;- INT1Ch -
;----------
int1c_handler: ;; User Timer Tick
  iret
;----------------------
;- POST: Floppy Drive -
;----------------------
floppy_drive_post:
  xor ax, ax
  mov ds, ax
  mov al, #0x00
  mov 0x043e, al ;; drive 0 & 1 uncalibrated, no interrupt has occurred
  mov 0x043f, al ;; diskette motor status: read op, drive0, motors off
  mov 0x0440, al ;; diskette motor timeout counter: not active
  mov 0x0441, al ;; diskette controller status return code
  mov 0x0442, al ;; disk & diskette controller status register 0
  mov 0x0443, al ;; diskette controller status register 1
  mov 0x0444, al ;; diskette controller status register 2
  mov 0x0445, al ;; diskette controller cylinder number
  mov 0x0446, al ;; diskette controller head number
  mov 0x0447, al ;; diskette controller sector number
  mov 0x0448, al ;; diskette controller bytes written
  mov 0x048b, al ;; diskette configuration data
  ;; -----------------------------------------------------------------
  ;; (048F) diskette controller information
  ;;
  mov al, #0x10 ;; get CMOS diskette drive type
  out 0x70, AL
  in AL, 0x71
  mov ah, al ;; save byte to AH
look_drive0:
  shr al, #4 ;; look at top 4 bits for drive 0
  jz f0_missing ;; jump if no drive0
  mov bl, #0x07 ;; drive0 determined, multi-rate, has changed line
  jmp look_drive1
f0_missing:
  mov bl, #0x00 ;; no drive0
look_drive1:
  mov al, ah ;; restore from AH
  and al, #0x0f ;; look at bottom 4 bits for drive 1
  jz f1_missing ;; jump if no drive1
  or bl, #0x70 ;; drive1 determined, multi-rate, has changed line
f1_missing:
                   ;; leave high bits in BL zerod
  mov 0x048f, bl ;; put new val in BDA (diskette controller information)
  ;; -----------------------------------------------------------------
  mov al, #0x00
  mov 0x0490, al ;; diskette 0 media state
  mov 0x0491, al ;; diskette 1 media state
                   ;; diskette 0,1 operational starting state
                   ;; drive type has not been determined,
                   ;; has no changed detection line
  mov 0x0492, al
  mov 0x0493, al
  mov 0x0494, al ;; diskette 0 current cylinder
  mov 0x0495, al ;; diskette 1 current cylinder
  mov al, #0x02
  out #0x0a, al ;; clear DMA-1 channel 2 mask bit
  SET_INT_VECTOR(0x1E, #0xF000, #diskette_param_table2)
  SET_INT_VECTOR(0x40, #0xF000, #int13_diskette)
  SET_INT_VECTOR(0x0E, #0xF000, #int0e_handler) ;; IRQ 6
  ret
;--------------------
;- POST: HARD DRIVE -
;--------------------
; relocated here because the primary POST area isnt big enough.
hard_drive_post:
  mov al, #0x0a ; 0000 1010 = reserved, disable IRQ 14
  mov dx, #0x03f6
  out dx, al
  xor ax, ax
  mov ds, ax
  mov 0x0474, al
  mov 0x0477, al
  mov 0x048c, al
  mov 0x048d, al
  mov 0x048e, al
  mov al, #0x01
  mov 0x0475, al
  mov al, #0xc0
  mov 0x0476, al
  SET_INT_VECTOR(0x13, #0xF000, #int13_handler)
  SET_INT_VECTOR(0x76, #0xF000, #int76_handler)
  ;; INT 41h: hard disk 0 configuration pointer
  ;; INT 46h: hard disk 1 configuration pointer
  SET_INT_VECTOR(0x41, #0x9FC0, #0x003D)
  SET_INT_VECTOR(0x46, #0x9FC0, #0x004D)
  ;; move disk geometry data from CMOS to EBDA disk parameter table(s)
  mov al, #0x12
  out #0x70, al
  in al, #0x71
  and al, #0xf0
  cmp al, #0xf0
  je post_d0_extended
  jmp check_for_hd1
post_d0_extended:
  mov al, #0x19
  out #0x70, al
  in al, #0x71
  cmp al, #47 ;; decimal 47 - user definable
  je post_d0_type47
  HALT(8886)
post_d0_type47:
  ;; CMOS purpose param table offset
  ;; 1b cylinders low 0
  ;; 1c cylinders high 1
  ;; 1d heads 2
  ;; 1e write pre-comp low 5
  ;; 1f write pre-comp high 6
  ;; 20 retries/bad map/heads>8 8
  ;; 21 landing zone low C
  ;; 22 landing zone high D
  ;; 23 sectors/track E
  mov ax, #0x9FC0
  mov ds, ax
  ;;; Filling EBDA table for hard disk 0.
  mov al, #0x1f
  out #0x70, al
  in al, #0x71
  mov ah, al
  mov al, #0x1e
  out #0x70, al
  in al, #0x71
  mov (0x003d + 0x05), ax ;; write precomp word
  mov al, #0x20
  out #0x70, al
  in al, #0x71
  mov (0x003d + 0x08), al ;; drive control byte
  mov al, #0x22
  out #0x70, al
  in al, #0x71
  mov ah, al
  mov al, #0x21
  out #0x70, al
  in al, #0x71
  mov (0x003d + 0x0C), ax ;; landing zone word
  mov al, #0x1c ;; get cylinders word in AX
  out #0x70, al
  in al, #0x71 ;; high byte
  mov ah, al
  mov al, #0x1b
  out #0x70, al
  in al, #0x71 ;; low byte
  mov bx, ax ;; BX = cylinders
  mov al, #0x1d
  out #0x70, al
  in al, #0x71
  mov cl, al ;; CL = heads
  mov al, #0x23
  out #0x70, al
  in al, #0x71
  mov dl, al ;; DL = sectors
  cmp bx, #1024
  jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
hd0_post_physical_chs:
  ;; no logical CHS mapping used, just physical CHS
  ;; use Standard Fixed Disk Parameter Table (FDPT)
  mov (0x003d + 0x00), bx ;; number of physical cylinders
  mov (0x003d + 0x02), cl ;; number of physical heads
  mov (0x003d + 0x0E), dl ;; number of physical sectors
  jmp check_for_hd1
hd0_post_logical_chs:
  ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
  mov (0x003d + 0x09), bx ;; number of physical cylinders
  mov (0x003d + 0x0b), cl ;; number of physical heads
  mov (0x003d + 0x04), dl ;; number of physical sectors
  mov (0x003d + 0x0e), dl ;; number of logical sectors (same)
  mov al, #0xa0
  mov (0x003d + 0x03), al ;; A0h signature, indicates translated table
  cmp bx, #2048
  jnbe hd0_post_above_2048
  ;; 1024 < c <= 2048 cylinders
  shr bx, #0x01
  shl cl, #0x01
  jmp hd0_post_store_logical
hd0_post_above_2048:
  cmp bx, #4096
  jnbe hd0_post_above_4096
  ;; 2048 < c <= 4096 cylinders
  shr bx, #0x02
  shl cl, #0x02
  jmp hd0_post_store_logical
hd0_post_above_4096:
  cmp bx, #8192
  jnbe hd0_post_above_8192
  ;; 4096 < c <= 8192 cylinders
  shr bx, #0x03
  shl cl, #0x03
  jmp hd0_post_store_logical
hd0_post_above_8192:
  ;; 8192 < c <= 16384 cylinders
  shr bx, #0x04
  shl cl, #0x04
hd0_post_store_logical:
  mov (0x003d + 0x00), bx ;; number of physical cylinders
  mov (0x003d + 0x02), cl ;; number of physical heads
  ;; checksum
  mov cl, #0x0f ;; repeat count
  mov si, #0x003d ;; offset to disk0 FDPT
  mov al, #0x00 ;; sum
hd0_post_checksum_loop:
  add al, [si]
  inc si
  dec cl
  jnz hd0_post_checksum_loop
  not al ;; now take 2s complement
  inc al
  mov [si], al
;;; Done filling EBDA table for hard disk 0.
check_for_hd1:
  ;; is there really a second hard disk? if not, return now
  mov al, #0x12
  out #0x70, al
  in al, #0x71
  and al, #0x0f
  jnz post_d1_exists
  ret
post_d1_exists:
  ;; check that the hd type is really 0x0f.
  cmp al, #0x0f
  jz post_d1_extended
  HALT(9023)
post_d1_extended:
  ;; check that the extended type is 47 - user definable
  mov al, #0x1a
  out #0x70, al
  in al, #0x71
  cmp al, #47 ;; decimal 47 - user definable
  je post_d1_type47
  HALT(9031)
post_d1_type47:
  ;; Table for disk1.
  ;; CMOS purpose param table offset
  ;; 0x24 cylinders low 0
  ;; 0x25 cylinders high 1
  ;; 0x26 heads 2
  ;; 0x27 write pre-comp low 5
  ;; 0x28 write pre-comp high 6
  ;; 0x29 heads>8 8
  ;; 0x2a landing zone low C
  ;; 0x2b landing zone high D
  ;; 0x2c sectors/track E
;;; Fill EBDA table for hard disk 1.
  mov ax, #0x9FC0
  mov ds, ax
  mov al, #0x28
  out #0x70, al
  in al, #0x71
  mov ah, al
  mov al, #0x27
  out #0x70, al
  in al, #0x71
  mov (0x004d + 0x05), ax ;; write precomp word
  mov al, #0x29
  out #0x70, al
  in al, #0x71
  mov (0x004d + 0x08), al ;; drive control byte
  mov al, #0x2b
  out #0x70, al
  in al, #0x71
  mov ah, al
  mov al, #0x2a
  out #0x70, al
  in al, #0x71
  mov (0x004d + 0x0C), ax ;; landing zone word
  mov al, #0x25 ;; get cylinders word in AX
  out #0x70, al
  in al, #0x71 ;; high byte
  mov ah, al
  mov al, #0x24
  out #0x70, al
  in al, #0x71 ;; low byte
  mov bx, ax ;; BX = cylinders
  mov al, #0x26
  out #0x70, al
  in al, #0x71
  mov cl, al ;; CL = heads
  mov al, #0x2c
  out #0x70, al
  in al, #0x71
  mov dl, al ;; DL = sectors
  cmp bx, #1024
  jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
hd1_post_physical_chs:
  ;; no logical CHS mapping used, just physical CHS
  ;; use Standard Fixed Disk Parameter Table (FDPT)
  mov (0x004d + 0x00), bx ;; number of physical cylinders
  mov (0x004d + 0x02), cl ;; number of physical heads
  mov (0x004d + 0x0E), dl ;; number of physical sectors
  ret
hd1_post_logical_chs:
  ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
  mov (0x004d + 0x09), bx ;; number of physical cylinders
  mov (0x004d + 0x0b), cl ;; number of physical heads
  mov (0x004d + 0x04), dl ;; number of physical sectors
  mov (0x004d + 0x0e), dl ;; number of logical sectors (same)
  mov al, #0xa0
  mov (0x004d + 0x03), al ;; A0h signature, indicates translated table
  cmp bx, #2048
  jnbe hd1_post_above_2048
  ;; 1024 < c <= 2048 cylinders
  shr bx, #0x01
  shl cl, #0x01
  jmp hd1_post_store_logical
hd1_post_above_2048:
  cmp bx, #4096
  jnbe hd1_post_above_4096
  ;; 2048 < c <= 4096 cylinders
  shr bx, #0x02
  shl cl, #0x02
  jmp hd1_post_store_logical
hd1_post_above_4096:
  cmp bx, #8192
  jnbe hd1_post_above_8192
  ;; 4096 < c <= 8192 cylinders
  shr bx, #0x03
  shl cl, #0x03
  jmp hd1_post_store_logical
hd1_post_above_8192:
  ;; 8192 < c <= 16384 cylinders
  shr bx, #0x04
  shl cl, #0x04
hd1_post_store_logical:
  mov (0x004d + 0x00), bx ;; number of physical cylinders
  mov (0x004d + 0x02), cl ;; number of physical heads
  ;; checksum
  mov cl, #0x0f ;; repeat count
  mov si, #0x004d ;; offset to disk0 FDPT
  mov al, #0x00 ;; sum
hd1_post_checksum_loop:
  add al, [si]
  inc si
  dec cl
  jnz hd1_post_checksum_loop
  not al ;; now take 2s complement
  inc al
  mov [si], al
;;; Done filling EBDA table for hard disk 1.
  ret
;--------------------
;- POST: EBDA segment
;--------------------
; relocated here because the primary POST area isnt big enough.
ebda_post:
  mov ax, #0x9FC0
  mov ds, ax
  mov byte ptr [0x0], #1
  xor ax, ax ; mov EBDA seg into 40E
  mov ds, ax
  mov word ptr [0x40E], #0x9FC0
  ret;;
;--------------------
;- POST: EOI + jmp via [0x40:67)
;--------------------
; relocated here because the primary POST area isnt big enough.
eoi_jmp_post:
  mov al, #0x20
  out #0xA0, al ;; slave PIC EOI
  mov al, #0x20
  out #0x20, al ;; master PIC EOI
jmp_post_0x467:
  xor ax, ax
  mov ds, ax
  jmp far ptr [0x467]
iret_post_0x467:
  xor ax, ax
  mov ds, ax
  mov sp, [0x467]
  mov ss, [0x469]
  iret
retf_post_0x467:
  xor ax, ax
  mov ds, ax
  mov sp, [0x467]
  mov ss, [0x469]
  retf
s3_post:
  mov sp, #0xffe
  call _s3_resume
  mov bl, #0x00
  and ax, ax
  jz normal_post
  call _s3_resume_panic
;--------------------
eoi_both_pics:
  mov al, #0x20
  out #0xA0, al ;; slave PIC EOI
eoi_master_pic:
  mov al, #0x20
  out #0x20, al ;; master PIC EOI
  ret
;--------------------
BcdToBin:
  ;; in: AL in BCD format
  ;; out: AL in binary format, AH will always be 0
  ;; trashes BX
  mov bl, al
  and bl, #0x0f ;; bl has low digit
  shr al, #4 ;; al has high digit
  mov bh, #10
  mul al, bh ;; multiply high digit by 10 (result in AX)
  add al, bl ;; then add low digit
  ret
;--------------------
timer_tick_post:
  ;; Setup the Timer Ticks Count (0x46C:dword) and
  ;; Timer Ticks Roller Flag (0x470:byte)
  ;; The Timer Ticks Count needs to be set according to
  ;; the current CMOS time, as if ticks have been occurring
  ;; at 18.2hz since midnight up to this point. Calculating
  ;; this is a little complicated. Here are the factors I gather
  ;; regarding this. 14,318,180 hz was the original clock speed,
  ;; chosen so it could be divided by either 3 to drive the 5Mhz CPU
  ;; at the time, or 4 to drive the CGA video adapter. The div3
  ;; source was divided again by 4 to feed a 1.193Mhz signal to
  ;; the timer. With a maximum 16bit timer count, this is again
  ;; divided down by 65536 to 18.2hz.
  ;;
  ;; 14,318,180 Hz clock
  ;; /3 = 4,772,726 Hz fed to orginal 5Mhz CPU
  ;; /4 = 1,193,181 Hz fed to timer
  ;; /65536 (maximum timer count) = 18.20650736 ticks/second
  ;; 1 second = 18.20650736 ticks
  ;; 1 minute = 1092.390442 ticks
  ;; 1 hour = 65543.42651 ticks
  ;;
  ;; Given the values in the CMOS clock, one could calculate
  ;; the number of ticks by the following:
  ;; ticks = (BcdToBin(seconds) * 18.206507) +
  ;; (BcdToBin(minutes) * 1092.3904)
  ;; (BcdToBin(hours) * 65543.427)
  ;; To get a little more accuracy, since Im using integer
  ;; arithmatic, I use:
  ;; ticks = (BcdToBin(seconds) * 18206507) / 1000000 +
  ;; (BcdToBin(minutes) * 10923904) / 10000 +
  ;; (BcdToBin(hours) * 65543427) / 1000
  ;; assuming DS=0000
  ;; get CMOS seconds
  xor eax, eax ;; clear EAX
  mov al, #0x00
  out #0x70, al
  in al, #0x71 ;; AL has CMOS seconds in BCD
  call BcdToBin ;; EAX now has seconds in binary
  mov edx, #18206507
  mul eax, edx
  mov ebx, #1000000
  xor edx, edx
  div eax, ebx
  mov ecx, eax ;; ECX will accumulate total ticks
  ;; get CMOS minutes
  xor eax, eax ;; clear EAX
  mov al, #0x02
  out #0x70, al
  in al, #0x71 ;; AL has CMOS minutes in BCD
  call BcdToBin ;; EAX now has minutes in binary
  mov edx, #10923904
  mul eax, edx
  mov ebx, #10000
  xor edx, edx
  div eax, ebx
  add ecx, eax ;; add to total ticks
  ;; get CMOS hours
  xor eax, eax ;; clear EAX
  mov al, #0x04
  out #0x70, al
  in al, #0x71 ;; AL has CMOS hours in BCD
  call BcdToBin ;; EAX now has hours in binary
  mov edx, #65543427
  mul eax, edx
  mov ebx, #1000
  xor edx, edx
  div eax, ebx
  add ecx, eax ;; add to total ticks
  mov 0x46C, ecx ;; Timer Ticks Count
  xor al, al
  mov 0x470, al ;; Timer Ticks Rollover Flag
  ret
;--------------------
int76_handler:
  ;; record completion in BIOS task complete flag
  push ax
  push ds
  mov ax, #0x0040
  mov ds, ax
  mov 0x008E, #0xff
  call eoi_both_pics
  pop ds
  pop ax
  iret
;--------------------
use32 386
apm32_out_str:
  push eax
  push ebx
  mov ebx, eax
apm32_out_str1:
  SEG CS
  mov al, byte ptr [bx]
  cmp al, #0
  je apm32_out_str2
  outb dx, al
  inc ebx
  jmp apm32_out_str1
apm32_out_str2:
  pop ebx
  pop eax
  ret
apm32_07_poweroff_str:
  .ascii "Shutdown"
  db 0
apm32_07_suspend_str:
  .ascii "Suspend"
  db 0
apm32_07_standby_str:
  .ascii "Standby"
  db 0
_apm32_entry:
  pushf
;-----------------
; APM interface disconnect
apm32_04:
  cmp al, #0x04
  jne apm32_05
  jmp apm32_ok
;-----------------
; APM cpu idle
apm32_05:
  cmp al, #0x05
  jne apm32_07
  sti
  hlt
  jmp apm32_ok
;-----------------
; APM Set Power State
apm32_07:
  cmp al, #0x07
  jne apm32_08
  cmp bx, #1
  jne apm32_ok
  cmp cx, #3
  je apm32_07_poweroff
  cmp cx, #2
  je apm32_07_suspend
  cmp cx, #1
  je apm32_07_standby
  jne apm32_ok
apm32_07_poweroff:
  cli
  mov dx, #0x8900
  mov ax, #apm32_07_poweroff_str
  call apm32_out_str
apm32_07_1:
  hlt
  jmp apm32_07_1
apm32_07_suspend:
  push edx
  mov dx, #0x8900
  mov ax, #apm32_07_suspend_str
  call apm32_out_str
  pop edx
  jmp apm32_ok
apm32_07_standby:
  push edx
  mov dx, #0x8900
  mov ax, #apm32_07_standby_str
  call apm32_out_str
  pop edx
  jmp apm32_ok
;-----------------
; APM Enable / Disable
apm32_08:
  cmp al, #0x08
  jne apm32_0a
  jmp apm32_ok
;-----------------
; Get Power Status
apm32_0a:
  cmp al, #0x0a
  jne apm32_0b
  mov bh, #0x01
  mov bl, #0xff
  mov ch, #0x80
  mov cl, #0xff
  mov dx, #0xffff
  mov si, #0
  jmp apm32_ok
;-----------------
; Get PM Event
apm32_0b:
  cmp al, #0x0b
  jne apm32_0e
  mov ah, #0x80
  jmp apm32_error
;-----------------
; APM Driver Version
apm32_0e:
  cmp al, #0x0e
  jne apm32_0f
  mov ah, #1
  mov al, #2
  jmp apm32_ok
;-----------------
; APM Engage / Disengage
apm32_0f:
  cmp al, #0x0f
  jne apm32_10
  jmp apm32_ok
;-----------------
; APM Get Capabilities
apm32_10:
  cmp al, #0x10
  jne apm32_unimplemented
  mov bl, #0
  mov cx, #0
  jmp apm32_ok
;-----------------
apm32_ok:
  popf
  clc
  retf
apm32_unimplemented:
apm32_error:
  popf
  stc
  retf
use16 386
apm16_out_str:
  push eax
  push ebx
  mov ebx, eax
apm16_out_str1:
  SEG CS
  mov al, byte ptr [bx]
  cmp al, #0
  je apm16_out_str2
  outb dx, al
  inc ebx
  jmp apm16_out_str1
apm16_out_str2:
  pop ebx
  pop eax
  ret
apm16_07_poweroff_str:
  .ascii "Shutdown"
  db 0
apm16_07_suspend_str:
  .ascii "Suspend"
  db 0
apm16_07_standby_str:
  .ascii "Standby"
  db 0
_apm16_entry:
  pushf
;-----------------
; APM interface disconnect
apm16_04:
  cmp al, #0x04
  jne apm16_05
  jmp apm16_ok
;-----------------
; APM cpu idle
apm16_05:
  cmp al, #0x05
  jne apm16_07
  sti
  hlt
  jmp apm16_ok
;-----------------
; APM Set Power State
apm16_07:
  cmp al, #0x07
  jne apm16_08
  cmp bx, #1
  jne apm16_ok
  cmp cx, #3
  je apm16_07_poweroff
  cmp cx, #2
  je apm16_07_suspend
  cmp cx, #1
  je apm16_07_standby
  jne apm16_ok
apm16_07_poweroff:
  cli
  mov dx, #0x8900
  mov ax, #apm16_07_poweroff_str
  call apm16_out_str
apm16_07_1:
  hlt
  jmp apm16_07_1
apm16_07_suspend:
  push edx
  mov dx, #0x8900
  mov ax, #apm16_07_suspend_str
  call apm16_out_str
  pop edx
  jmp apm16_ok
apm16_07_standby:
  push edx
  mov dx, #0x8900
  mov ax, #apm16_07_standby_str
  call apm16_out_str
  pop edx
  jmp apm16_ok
;-----------------
; APM Enable / Disable
apm16_08:
  cmp al, #0x08
  jne apm16_0a
  jmp apm16_ok
;-----------------
; Get Power Status
apm16_0a:
  cmp al, #0x0a
  jne apm16_0b
  mov bh, #0x01
  mov bl, #0xff
  mov ch, #0x80
  mov cl, #0xff
  mov dx, #0xffff
  mov si, #0
  jmp apm16_ok
;-----------------
; Get PM Event
apm16_0b:
  cmp al, #0x0b
  jne apm16_0e
  mov ah, #0x80
  jmp apm16_error
;-----------------
; APM Driver Version
apm16_0e:
  cmp al, #0x0e
  jne apm16_0f
  mov ah, #1
  mov al, #2
  jmp apm16_ok
;-----------------
; APM Engage / Disengage
apm16_0f:
  cmp al, #0x0f
  jne apm16_10
  jmp apm16_ok
;-----------------
; APM Get Capabilities
apm16_10:
  cmp al, #0x10
  jne apm16_unimplemented
  mov bl, #0
  mov cx, #0
  jmp apm16_ok
;-----------------
apm16_ok:
  popf
  clc
  retf
apm16_unimplemented:
apm16_error:
  popf
  stc
  retf
apmreal_out_str:
  push eax
  push ebx
  mov ebx, eax
apmreal_out_str1:
  SEG CS
  mov al, byte ptr [bx]
  cmp al, #0
  je apmreal_out_str2
  outb dx, al
  inc ebx
  jmp apmreal_out_str1
apmreal_out_str2:
  pop ebx
  pop eax
  ret
apmreal_07_poweroff_str:
  .ascii "Shutdown"
  db 0
apmreal_07_suspend_str:
  .ascii "Suspend"
  db 0
apmreal_07_standby_str:
  .ascii "Standby"
  db 0
  pushf
_apmreal_entry:
;-----------------
; APM installation check
apmreal_00:
  cmp al, #0x00
  jne apmreal_01
  mov ah, #1
  mov al, #2
  mov bh, #0x50
  mov bl, #0x4d
  mov cx, #0x3
  jmp apmreal_ok
;-----------------
; APM real mode interface connect
apmreal_01:
  cmp al, #0x01
  jne apmreal_02
  jmp apmreal_ok
;-----------------
; APM 16 bit protected mode interface connect
apmreal_02:
  cmp al, #0x02
  jne apmreal_03
  mov bx, #_apm16_entry
  mov ax, #0xf000
  mov si, #0xfff0
  mov cx, #0xf000
  mov di, #0xfff0
  jmp apmreal_ok
;-----------------
; APM 32 bit protected mode interface connect
apmreal_03:
  cmp al, #0x03
  jne apmreal_04
  mov ax, #0xf000
  mov ebx, #_apm32_entry
  mov cx, #0xf000
  mov esi, #0xfff0fff0
  mov dx, #0xf000
  mov di, #0xfff0
  jmp apmreal_ok
;-----------------
; APM interface disconnect
apmreal_04:
  cmp al, #0x04
  jne apmreal_05
  jmp apmreal_ok
;-----------------
; APM cpu idle
apmreal_05:
  cmp al, #0x05
  jne apmreal_07
  sti
  hlt
  jmp apmreal_ok
;-----------------
; APM Set Power State
apmreal_07:
  cmp al, #0x07
  jne apmreal_08
  cmp bx, #1
  jne apmreal_ok
  cmp cx, #3
  je apmreal_07_poweroff
  cmp cx, #2
  je apmreal_07_suspend
  cmp cx, #1
  je apmreal_07_standby
  jne apmreal_ok
apmreal_07_poweroff:
  cli
  mov dx, #0x8900
  mov ax, #apmreal_07_poweroff_str
  call apmreal_out_str
apmreal_07_1:
  hlt
  jmp apmreal_07_1
apmreal_07_suspend:
  push edx
  mov dx, #0x8900
  mov ax, #apmreal_07_suspend_str
  call apmreal_out_str
  pop edx
  jmp apmreal_ok
apmreal_07_standby:
  push edx
  mov dx, #0x8900
  mov ax, #apmreal_07_standby_str
  call apmreal_out_str
  pop edx
  jmp apmreal_ok
;-----------------
; APM Enable / Disable
apmreal_08:
  cmp al, #0x08
  jne apmreal_0a
  jmp apmreal_ok
;-----------------
; Get Power Status
apmreal_0a:
  cmp al, #0x0a
  jne apmreal_0b
  mov bh, #0x01
  mov bl, #0xff
  mov ch, #0x80
  mov cl, #0xff
  mov dx, #0xffff
  mov si, #0
  jmp apmreal_ok
;-----------------
; Get PM Event
apmreal_0b:
  cmp al, #0x0b
  jne apmreal_0e
  mov ah, #0x80
  jmp apmreal_error
;-----------------
; APM Driver Version
apmreal_0e:
  cmp al, #0x0e
  jne apmreal_0f
  mov ah, #1
  mov al, #2
  jmp apmreal_ok
;-----------------
; APM Engage / Disengage
apmreal_0f:
  cmp al, #0x0f
  jne apmreal_10
  jmp apmreal_ok
;-----------------
; APM Get Capabilities
apmreal_10:
  cmp al, #0x10
  jne apmreal_unimplemented
  mov bl, #0
  mov cx, #0
  jmp apmreal_ok
;-----------------
apmreal_ok:
  popf
  clc
  jmp iret_modify_cf
apmreal_unimplemented:
apmreal_error:
  popf
  stc
  jmp iret_modify_cf
;--------------------
use32 386
.align 16
bios32_structure:
  db 0x5f, 0x33, 0x32, 0x5f ;; "_32_" signature
  dw bios32_entry_point, 0xf ;; 32 bit physical address
  db 0 ;; revision level
  ;; length in paragraphs and checksum stored in a word to prevent errors
  dw (~(((bios32_entry_point >> 8) + (bios32_entry_point & 0xff) + 0x32) & 0xff) << 8) + 0x01
  db 0,0,0,0,0 ;; reserved
.align 16
bios32_entry_point:
  pushfd
  cmp eax, #0x49435024 ;; "$PCI"
  jne unknown_service
  mov eax, #0x80000000
  mov dx, #0x0cf8
  out dx, eax
  mov dx, #0x0cfc
  in eax, dx
  cmp eax, #0x12378086 ;; i440FX PCI bridge
  jne unknown_service
  mov ebx, #0x000f0000
  mov ecx, #0
  mov edx, #pcibios_protected
  xor al, al
  jmp bios32_end
unknown_service:
  mov al, #0x80
bios32_end:
  popfd
  retf
.align 16
pcibios_protected:
  pushfd
  cli
  push esi
  push edi
  cmp al, #0x01 ;; installation check
  jne pci_pro_f02
  mov bx, #0x0210
  mov cx, #0
  mov edx, #0x20494350 ;; "PCI "
  mov al, #0x01
  jmp pci_pro_ok
pci_pro_f02: ;; find pci device
  cmp al, #0x02
  jne pci_pro_f03
  shl ecx, #16
  mov cx, dx
  xor bx, bx
  mov di, #0x00
pci_pro_devloop:
  call pci_pro_select_reg
  mov dx, #0x0cfc
  in eax, dx
  cmp eax, ecx
  jne pci_pro_nextdev
  cmp si, #0
  je pci_pro_ok
  dec si
pci_pro_nextdev:
  inc bx
  cmp bx, #0x0100
  jne pci_pro_devloop
  mov ah, #0x86
  jmp pci_pro_fail
pci_pro_f03: ;; find class code
  cmp al, #0x03
  jne pci_pro_f08
  xor bx, bx
  mov di, #0x08
pci_pro_devloop2:
  call pci_pro_select_reg
  mov dx, #0x0cfc
  in eax, dx
  shr eax, #8
  cmp eax, ecx
  jne pci_pro_nextdev2
  cmp si, #0
  je pci_pro_ok
  dec si
pci_pro_nextdev2:
  inc bx
  cmp bx, #0x0100
  jne pci_pro_devloop2
  mov ah, #0x86
  jmp pci_pro_fail
pci_pro_f08: ;; read configuration byte
  cmp al, #0x08
  jne pci_pro_f09
  call pci_pro_select_reg
  push edx
  mov dx, di
  and dx, #0x03
  add dx, #0x0cfc
  in al, dx
  pop edx
  mov cl, al
  jmp pci_pro_ok
pci_pro_f09: ;; read configuration word
  cmp al, #0x09
  jne pci_pro_f0a
  call pci_pro_select_reg
  push edx
  mov dx, di
  and dx, #0x02
  add dx, #0x0cfc
  in ax, dx
  pop edx
  mov cx, ax
  jmp pci_pro_ok
pci_pro_f0a: ;; read configuration dword
  cmp al, #0x0a
  jne pci_pro_f0b
  call pci_pro_select_reg
  push edx
  mov dx, #0x0cfc
  in eax, dx
  pop edx
  mov ecx, eax
  jmp pci_pro_ok
pci_pro_f0b: ;; write configuration byte
  cmp al, #0x0b
  jne pci_pro_f0c
  call pci_pro_select_reg
  push edx
  mov dx, di
  and dx, #0x03
  add dx, #0x0cfc
  mov al, cl
  out dx, al
  pop edx
  jmp pci_pro_ok
pci_pro_f0c: ;; write configuration word
  cmp al, #0x0c
  jne pci_pro_f0d
  call pci_pro_select_reg
  push edx
  mov dx, di
  and dx, #0x02
  add dx, #0x0cfc
  mov ax, cx
  out dx, ax
  pop edx
  jmp pci_pro_ok
pci_pro_f0d: ;; write configuration dword
  cmp al, #0x0d
  jne pci_pro_unknown
  call pci_pro_select_reg
  push edx
  mov dx, #0x0cfc
  mov eax, ecx
  out dx, eax
  pop edx
  jmp pci_pro_ok
pci_pro_unknown:
  mov ah, #0x81
pci_pro_fail:
  pop edi
  pop esi
  popfd
  stc
  retf
pci_pro_ok:
  xor ah, ah
  pop edi
  pop esi
  popfd
  clc
  retf
pci_pro_select_reg:
  push edx
  mov eax, #0x800000
  mov ax, bx
  shl eax, #8
  and di, #0xff
  or ax, di
  and al, #0xfc
  mov dx, #0x0cf8
  out dx, eax
  pop edx
  ret
use16 386
pcibios_real:
  push eax
  push dx
  mov eax, #0x80000000
  mov dx, #0x0cf8
  out dx, eax
  mov dx, #0x0cfc
  in eax, dx
  cmp eax, #0x12378086 ;; i440FX PCI bridge
  je pci_present
  pop dx
  pop eax
  mov ah, #0xff
  stc
  ret
pci_present:
  pop dx
  pop eax
  cmp al, #0x01 ;; installation check
  jne pci_real_f02
  mov ax, #0x0001
  mov bx, #0x0210
  mov cx, #0
  mov edx, #0x20494350 ;; "PCI "
  mov edi, #0xf0000
  mov di, #pcibios_protected
  clc
  ret
pci_real_f02: ;; find pci device
  push esi
  push edi
  cmp al, #0x02
  jne pci_real_f03
  shl ecx, #16
  mov cx, dx
  xor bx, bx
  mov di, #0x00
pci_real_devloop:
  call pci_real_select_reg
  mov dx, #0x0cfc
  in eax, dx
  cmp eax, ecx
  jne pci_real_nextdev
  cmp si, #0
  je pci_real_ok
  dec si
pci_real_nextdev:
  inc bx
  cmp bx, #0x0100
  jne pci_real_devloop
  mov dx, cx
  shr ecx, #16
  mov ax, #0x8602
  jmp pci_real_fail
pci_real_f03: ;; find class code
  cmp al, #0x03
  jne pci_real_f08
  xor bx, bx
  mov di, #0x08
pci_real_devloop2:
  call pci_real_select_reg
  mov dx, #0x0cfc
  in eax, dx
  shr eax, #8
  cmp eax, ecx
  jne pci_real_nextdev2
  cmp si, #0
  je pci_real_ok
  dec si
pci_real_nextdev2:
  inc bx
  cmp bx, #0x0100
  jne pci_real_devloop2
  mov dx, cx
  shr ecx, #16
  mov ax, #0x8603
  jmp pci_real_fail
pci_real_f08: ;; read configuration byte
  cmp al, #0x08
  jne pci_real_f09
  call pci_real_select_reg
  push dx
  mov dx, di
  and dx, #0x03
  add dx, #0x0cfc
  in al, dx
  pop dx
  mov cl, al
  jmp pci_real_ok
pci_real_f09: ;; read configuration word
  cmp al, #0x09
  jne pci_real_f0a
  call pci_real_select_reg
  push dx
  mov dx, di
  and dx, #0x02
  add dx, #0x0cfc
  in ax, dx
  pop dx
  mov cx, ax
  jmp pci_real_ok
pci_real_f0a: ;; read configuration dword
  cmp al, #0x0a
  jne pci_real_f0b
  call pci_real_select_reg
  push dx
  mov dx, #0x0cfc
  in eax, dx
  pop dx
  mov ecx, eax
  jmp pci_real_ok
pci_real_f0b: ;; write configuration byte
  cmp al, #0x0b
  jne pci_real_f0c
  call pci_real_select_reg
  push dx
  mov dx, di
  and dx, #0x03
  add dx, #0x0cfc
  mov al, cl
  out dx, al
  pop dx
  jmp pci_real_ok
pci_real_f0c: ;; write configuration word
  cmp al, #0x0c
  jne pci_real_f0d
  call pci_real_select_reg
  push dx
  mov dx, di
  and dx, #0x02
  add dx, #0x0cfc
  mov ax, cx
  out dx, ax
  pop dx
  jmp pci_real_ok
pci_real_f0d: ;; write configuration dword
  cmp al, #0x0d
  jne pci_real_f0e
  call pci_real_select_reg
  push dx
  mov dx, #0x0cfc
  mov eax, ecx
  out dx, eax
  pop dx
  jmp pci_real_ok
pci_real_f0e: ;; get irq routing options
  cmp al, #0x0e
  jne pci_real_unknown
  SEG ES
  cmp word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
  jb pci_real_too_small
  SEG ES
  mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
  pushf
  push ds
  push es
  push cx
  push si
  push di
  cld
  mov si, #pci_routing_table_structure_start
  push cs
  pop ds
  SEG ES
  mov cx, [di+2]
  SEG ES
  mov es, [di+4]
  mov di, cx
  mov cx, #pci_routing_table_structure_end - pci_routing_table_structure_start
  rep
      movsb
  pop di
  pop si
  pop cx
  pop es
  pop ds
  popf
  mov bx, #(1 << 9) | (1 << 11) ;; irq 9 and 11 are used
  jmp pci_real_ok
pci_real_too_small:
  SEG ES
  mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
  mov ah, #0x89
  jmp pci_real_fail
pci_real_unknown:
  mov ah, #0x81
pci_real_fail:
  pop edi
  pop esi
  stc
  ret
pci_real_ok:
  xor ah, ah
  pop edi
  pop esi
  clc
  ret
pci_real_select_reg:
  push dx
  mov eax, #0x800000
  mov ax, bx
  shl eax, #8
  and di, #0xff
  or ax, di
  and al, #0xfc
  mov dx, #0x0cf8
  out dx, eax
  pop dx
  ret
.align 16
pci_routing_table_structure:
  db 0x24, 0x50, 0x49, 0x52 ;; "$PIR" signature
  db 0, 1 ;; version
  dw 32 + (6 * 16) ;; table size
  db 0 ;; PCI interrupt router bus
  db 0x08 ;; PCI interrupt router DevFunc
  dw 0x0000 ;; PCI exclusive IRQs
  dw 0x8086 ;; compatible PCI interrupt router vendor ID
  dw 0x122e ;; compatible PCI interrupt router device ID
  dw 0,0 ;; Miniport data
  db 0,0,0,0,0,0,0,0,0,0,0 ;; reserved
  db 0x37 ;; checksum
pci_routing_table_structure_start:
  ;; first slot entry PCI-to-ISA (embedded)
  db 0 ;; pci bus number
  db 0x08 ;; pci device number (bit 7-3)
  db 0x60 ;; link value INTA#: pointer into PCI2ISA config space
  dw 0xdef8 ;; IRQ bitmap INTA#
  db 0x61 ;; link value INTB#
  dw 0xdef8 ;; IRQ bitmap INTB#
  db 0x62 ;; link value INTC#
  dw 0xdef8 ;; IRQ bitmap INTC#
  db 0x63 ;; link value INTD#
  dw 0xdef8 ;; IRQ bitmap INTD#
  db 0 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; second slot entry: 1st PCI slot
  db 0 ;; pci bus number
  db 0x10 ;; pci device number (bit 7-3)
  db 0x61 ;; link value INTA#
  dw 0xdef8 ;; IRQ bitmap INTA#
  db 0x62 ;; link value INTB#
  dw 0xdef8 ;; IRQ bitmap INTB#
  db 0x63 ;; link value INTC#
  dw 0xdef8 ;; IRQ bitmap INTC#
  db 0x60 ;; link value INTD#
  dw 0xdef8 ;; IRQ bitmap INTD#
  db 1 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; third slot entry: 2nd PCI slot
  db 0 ;; pci bus number
  db 0x18 ;; pci device number (bit 7-3)
  db 0x62 ;; link value INTA#
  dw 0xdef8 ;; IRQ bitmap INTA#
  db 0x63 ;; link value INTB#
  dw 0xdef8 ;; IRQ bitmap INTB#
  db 0x60 ;; link value INTC#
  dw 0xdef8 ;; IRQ bitmap INTC#
  db 0x61 ;; link value INTD#
  dw 0xdef8 ;; IRQ bitmap INTD#
  db 2 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; 4th slot entry: 3rd PCI slot
  db 0 ;; pci bus number
  db 0x20 ;; pci device number (bit 7-3)
  db 0x63 ;; link value INTA#
  dw 0xdef8 ;; IRQ bitmap INTA#
  db 0x60 ;; link value INTB#
  dw 0xdef8 ;; IRQ bitmap INTB#
  db 0x61 ;; link value INTC#
  dw 0xdef8 ;; IRQ bitmap INTC#
  db 0x62 ;; link value INTD#
  dw 0xdef8 ;; IRQ bitmap INTD#
  db 3 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; 5th slot entry: 4rd PCI slot
  db 0 ;; pci bus number
  db 0x28 ;; pci device number (bit 7-3)
  db 0x60 ;; link value INTA#
  dw 0xdef8 ;; IRQ bitmap INTA#
  db 0x61 ;; link value INTB#
  dw 0xdef8 ;; IRQ bitmap INTB#
  db 0x62 ;; link value INTC#
  dw 0xdef8 ;; IRQ bitmap INTC#
  db 0x63 ;; link value INTD#
  dw 0xdef8 ;; IRQ bitmap INTD#
  db 4 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; 6th slot entry: 5rd PCI slot
  db 0 ;; pci bus number
  db 0x30 ;; pci device number (bit 7-3)
  db 0x61 ;; link value INTA#
  dw 0xdef8 ;; IRQ bitmap INTA#
  db 0x62 ;; link value INTB#
  dw 0xdef8 ;; IRQ bitmap INTB#
  db 0x63 ;; link value INTC#
  dw 0xdef8 ;; IRQ bitmap INTC#
  db 0x60 ;; link value INTD#
  dw 0xdef8 ;; IRQ bitmap INTD#
  db 5 ;; physical slot (0 = embedded)
  db 0 ;; reserved
pci_routing_table_structure_end:
pci_irq_list:
  db 11, 10, 9, 5;
pcibios_init_sel_reg:
  push eax
  mov eax, #0x800000
  mov ax, bx
  shl eax, #8
  and dl, #0xfc
  or al, dl
  mov dx, #0x0cf8
  out dx, eax
  pop eax
  ret
pcibios_init_iomem_bases:
  push bp
  mov bp, sp
  mov eax, #0xc0000000 ;; base for memory init
  push eax
  mov ax, #0xc000 ;; base for i/o init
  push ax
  mov ax, #0x0010 ;; start at base address #0
  push ax
  mov bx, #0x0008
pci_init_io_loop1:
  mov dl, #0x00
  call pcibios_init_sel_reg
  mov dx, #0x0cfc
  in ax, dx
  cmp ax, #0xffff
  jz next_pci_dev
  mov dl, #0x04 ;; disable i/o and memory space access
  call pcibios_init_sel_reg
  mov dx, #0x0cfc
  in al, dx
  and al, #0xfc
  out dx, al
pci_init_io_loop2:
  mov dl, [bp-8]
  call pcibios_init_sel_reg
  mov dx, #0x0cfc
  in eax, dx
  test al, #0x01
  jnz init_io_base
  mov ecx, eax
  mov eax, #0xffffffff
  out dx, eax
  in eax, dx
  cmp eax, ecx
  je next_pci_base
  xor eax, #0xffffffff
  mov ecx, eax
  mov eax, [bp-4]
  out dx, eax
  add eax, ecx ;; calculate next free mem base
  add eax, #0x01000000
  and eax, #0xff000000
  mov [bp-4], eax
  jmp next_pci_base
init_io_base:
  mov cx, ax
  mov ax, #0xffff
  out dx, ax
  in ax, dx
  cmp ax, cx
  je next_pci_base
  xor ax, #0xfffe
  mov cx, ax
  mov ax, [bp-6]
  out dx, ax
  add ax, cx ;; calculate next free i/o base
  add ax, #0x0100
  and ax, #0xff00
  mov [bp-6], ax
next_pci_base:
  mov al, [bp-8]
  add al, #0x04
  cmp al, #0x28
  je enable_iomem_space
  mov byte ptr[bp-8], al
  jmp pci_init_io_loop2
enable_iomem_space:
  mov dl, #0x04 ;; enable i/o and memory space access if available
  call pcibios_init_sel_reg
  mov dx, #0x0cfc
  in al, dx
  or al, #0x07
  out dx, al
next_pci_dev:
  mov byte ptr[bp-8], #0x10
  inc bx
  cmp bx, #0x0100
  jne pci_init_io_loop1
  mov sp, bp
  pop bp
  ret
pcibios_init_set_elcr:
  push ax
  push cx
  mov dx, #0x04d0
  test al, #0x08
  jz is_master_pic
  inc dx
  and al, #0x07
is_master_pic:
  mov cl, al
  mov bl, #0x01
  shl bl, cl
  in al, dx
  or al, bl
  out dx, al
  pop cx
  pop ax
  ret
pcibios_init_irqs:
  push ds
  push bp
  mov ax, #0xf000
  mov ds, ax
  mov dx, #0x04d0 ;; reset ELCR1 + ELCR2
  mov al, #0x00
  out dx, al
  inc dx
  out dx, al
  mov si, #pci_routing_table_structure
  mov bh, [si+8]
  mov bl, [si+9]
  mov dl, #0x00
  call pcibios_init_sel_reg
  mov dx, #0x0cfc
  in ax, dx
  cmp ax, [si+12] ;; check irq router
  jne pci_init_end
  mov dl, [si+34]
  call pcibios_init_sel_reg
  push bx ;; save irq router bus + devfunc
  mov dx, #0x0cfc
  mov ax, #0x8080
  out dx, ax ;; reset PIRQ route control
  add dx, #2
  out dx, ax
  mov ax, [si+6]
  sub ax, #0x20
  shr ax, #4
  mov cx, ax
  add si, #0x20 ;; set pointer to 1st entry
  mov bp, sp
  mov ax, #pci_irq_list
  push ax
  xor ax, ax
  push ax
pci_init_irq_loop1:
  mov bh, [si]
  mov bl, [si+1]
pci_init_irq_loop2:
  mov dl, #0x00
  call pcibios_init_sel_reg
  mov dx, #0x0cfc
  in ax, dx
  cmp ax, #0xffff
  jnz pci_test_int_pin
  test bl, #0x07
  jz next_pir_entry
  jmp next_pci_func
pci_test_int_pin:
  mov dl, #0x3c
  call pcibios_init_sel_reg
  mov dx, #0x0cfd
  in al, dx
  and al, #0x07
  jz next_pci_func
  dec al ;; determine pirq reg
  mov dl, #0x03
  mul al, dl
  add al, #0x02
  xor ah, ah
  mov bx, ax
  mov al, [si+bx]
  mov dl, al
  mov bx, [bp]
  call pcibios_init_sel_reg
  mov dx, #0x0cfc
  and al, #0x03
  add dl, al
  in al, dx
  cmp al, #0x80
  jb pirq_found
  mov bx, [bp-2] ;; pci irq list pointer
  mov al, [bx]
  out dx, al
  inc bx
  mov [bp-2], bx
  call pcibios_init_set_elcr
pirq_found:
  mov bh, [si]
  mov bl, [si+1]
  add bl, [bp-3] ;; pci function number
  mov dl, #0x3c
  call pcibios_init_sel_reg
  mov dx, #0x0cfc
  out dx, al
next_pci_func:
  inc byte ptr[bp-3]
  inc bl
  test bl, #0x07
  jnz pci_init_irq_loop2
next_pir_entry:
  add si, #0x10
  mov byte ptr[bp-3], #0x00
  loop pci_init_irq_loop1
  mov sp, bp
  pop bx
pci_init_end:
  pop bp
  pop ds
  ret
; parallel port detection: base address in DX, index in BX, timeout in CL
detect_parport:
  push dx
  add dx, #2
  in al, dx
  and al, #0xdf ; clear input mode
  out dx, al
  pop dx
  mov al, #0xaa
  out dx, al
  in al, dx
  cmp al, #0xaa
  jne no_parport
  push bx
  shl bx, #1
  mov [bx+0x408], dx ; Parallel I/O address
  pop bx
  mov [bx+0x478], cl ; Parallel printer timeout
  inc bx
no_parport:
  ret
; serial port detection: base address in DX, index in BX, timeout in CL
detect_serial:
  push dx
  inc dx
  mov al, #0x02
  out dx, al
  in al, dx
  cmp al, #0x02
  jne no_serial
  inc dx
  in al, dx
  cmp al, #0x02
  jne no_serial
  dec dx
  xor al, al
  out dx, al
  pop dx
  push bx
  shl bx, #1
  mov [bx+0x400], dx ; Serial I/O address
  pop bx
  mov [bx+0x47c], cl ; Serial timeout
  inc bx
  ret
no_serial:
  pop dx
  ret
rom_checksum:
  pusha
  push ds
  xor ax, ax
  xor bx, bx
  xor cx, cx
  xor dx, dx
  mov ch, [2]
  shl cx, #1
  jnc checksum_loop
  xchg dx, cx
  dec cx
checksum_loop:
  add al, [bx]
  inc bx
  loop checksum_loop
  test dx, dx
  je checksum_out
  add al, [bx]
  mov cx, dx
  mov dx, ds
  add dh, #0x10
  mov ds, dx
  xor dx, dx
  xor bx, bx
  jmp checksum_loop
checksum_out:
  and al, #0xff
  pop ds
  popa
  ret
;; We need a copy of this string, but we are not actually a PnP BIOS,
;; so make sure it is *not* aligned, so OSes will not see it if they scan.
.align 16
  db 0
pnp_string:
  .ascii "$PnP"
rom_scan:
  ;; Scan for existence of valid expansion ROMS.
  ;; Video ROM: from 0xC0000..0xC7FFF in 2k increments
  ;; General ROM: from 0xC8000..0xDFFFF in 2k increments
  ;; System ROM: only 0xE0000
  ;;
  ;; Header:
  ;; Offset Value
  ;; 0 0x55
  ;; 1 0xAA
  ;; 2 ROM length in 512-byte blocks
  ;; 3 ROM initialization entry point (FAR CALL)
rom_scan_loop:
  push ax ;; Save AX
  mov ds, cx
  mov ax, #0x0004 ;; start with increment of 4 (512-byte) blocks = 2k
  cmp [0], #0xAA55 ;; look for signature
  jne rom_scan_increment
  call rom_checksum
  jnz rom_scan_increment
  mov al, [2] ;; change increment to ROM length in 512-byte blocks
  ;; We want our increment in 512-byte quantities, rounded to
  ;; the nearest 2k quantity, since we only scan at 2k intervals.
  test al, #0x03
  jz block_count_rounded
  and al, #0xfc ;; needs rounding up
  add al, #0x04
block_count_rounded:
  xor bx, bx ;; Restore DS back to 0000:
  mov ds, bx
  push ax ;; Save AX
  push di ;; Save DI
  ;; Push addr of ROM entry point
  push cx ;; Push seg
  push #0x0003 ;; Push offset
  ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
  ;; That should stop it grabbing INT 19h; we will use its BEV instead.
  mov ax, #0xf000
  mov es, ax
  lea di, pnp_string
  mov bp, sp ;; Call ROM init routine using seg:off on stack
  db 0xff ;; call_far ss:[bp+0]
  db 0x5e
  db 0
  cli ;; In case expansion ROM BIOS turns IF on
  add sp, #2 ;; Pop offset value
  pop cx ;; Pop seg value (restore CX)
  ;; Look at the ROM's PnP Expansion header.  Properly, we're supposed
  ;; to init all the ROMs and then go back and build an IPL table of
  ;; all the bootable devices, but we can get away with one pass.
  mov ds, cx ;; ROM base
  mov bx, 0x001a ;; 0x1A is the offset into ROM header that contains...
  mov ax, [bx] ;; the offset of PnP expansion header, where...
  cmp ax, #0x5024 ;; we look for signature "$PnP"
  jne no_bev
  mov ax, 2[bx]
  cmp ax, #0x506e
  jne no_bev
  mov ax, 0x16[bx] ;; 0x16 is the offset of Boot Connection Vector
  cmp ax, #0x0000
  je no_bcv
  ;; Option ROM has BCV. Run it now.
  push cx ;; Push seg
  push ax ;; Push offset
  ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
  mov bx, #0xf000
  mov es, bx
  lea di, pnp_string
  mov bp, sp ;; Call ROM BCV routine using seg:off on stack
  db 0xff ;; call_far ss:[bp+0]
  db 0x5e
  db 0
  cli ;; In case expansion ROM BIOS turns IF on
  add sp, #2 ;; Pop offset value
  pop cx ;; Pop seg value (restore CX)
  jmp no_bev
no_bcv:
  mov ax, 0x1a[bx] ;; 0x1A is also the offset into the expansion header of...
  cmp ax, #0x0000 ;; the Bootstrap Entry Vector, or zero if there is 0 .
  je no_bev
  ;; Found a device that thinks it can boot the system. Record its BEV and product name string.
  mov di, 0x10[bx] ;; Pointer to the product name string or zero if 0
  mov bx, #0x9ff0 ;; Go to the segment where the IPL table lives
  mov ds, bx
  mov bx, 0x0080 ;; Read the number of entries so far
  cmp bx, #8
  je no_bev ;; Get out if the table is full
  shl bx, #0x4 ;; Turn count into offset (entries are 16 bytes)
  mov 0[bx], #0x80 ;; This entry is a BEV device
  mov 6[bx], cx ;; Build a far pointer from the segment...
  mov 4[bx], ax ;; and the offset
  cmp di, #0x0000
  je no_prod_str
  mov 0xA[bx], cx ;; Build a far pointer from the segment...
  mov 8[bx], di ;; and the offset
no_prod_str:
  shr bx, #0x4 ;; Turn the offset back into a count
  inc bx ;; We have one more entry now
  mov 0x0080, bx ;; Remember that.
no_bev:
  pop di ;; Restore DI
  pop ax ;; Restore AX
rom_scan_increment:
  shl ax, #5 ;; convert 512-bytes blocks to 16-byte increments
                ;; because the segment selector is shifted left 4 bits.
  add cx, ax
  pop ax ;; Restore AX
  cmp cx, ax
  jbe rom_scan_loop
  xor ax, ax ;; Restore DS back to 0000:
  mov ds, ax
  ret
post_init_pic:
  mov al, #0x11 ; send initialisation commands
  out 0x20, al
  out 0xa0, al
  mov al, #0x08
  out 0x21, al
  mov al, #0x70
  out 0xa1, al
  mov al, #0x04
  out 0x21, al
  mov al, #0x02
  out 0xa1, al
  mov al, #0x01
  out 0x21, al
  out 0xa1, al
  mov al, #0xb8
  out 0x21, AL ;master pic: unmask IRQ 0, 1, 2, 6
  mov al, #0x8f
  out 0xa1, AL ;slave pic: unmask IRQ 12, 13, 14
  ret
;; the following area can be used to write dynamically generated tables
  .align 16
bios_table_area_start:
  dd 0xaafb4442
  dd bios_table_area_end - bios_table_area_start - 8;
;--------
;- POST -
;--------
.org 0xe05b ; POST Entry Point
post:
  xor ax, ax
  ;; first reset the DMA controllers
  out 0x0d,al
  out 0xda,al
  ;; then initialize the DMA controllers
  mov al, #0xC0
  out 0xD6, al ; cascade mode of channel 4 enabled
  mov al, #0x00
  out 0xD4, al ; unmask channel 4
  ;; Examine CMOS shutdown status.
  mov AL, #0x0f
  out 0x70, AL
  in AL, 0x71
  ;; backup status
  mov bl, al
  ;; Reset CMOS shutdown status.
  mov AL, #0x0f
  out 0x70, AL ; select CMOS register Fh
  mov AL, #0x00
  out 0x71, AL ; set shutdown action to normal
  ;; Examine CMOS shutdown status.
  mov al, bl
  ;; 0x00, 0x09, 0x0D+ = normal startup
  cmp AL, #0x00
  jz normal_post
  cmp AL, #0x0d
  jae normal_post
  ;; 0x05 = eoi + jmp via [0x40:0x67] jump
  cmp al, #0x05
  je eoi_jmp_post
  ;; 0x0A = jmp via [0x40:0x67] jump
  cmp al, #0x0a
  je jmp_post_0x467
  ;; 0x0B = iret via [0x40:0x67]
  cmp al, #0x0b
  je iret_post_0x467
  ;; 0x0C = retf via [0x40:0x67]
  cmp al, #0x0c
  je retf_post_0x467
  ;; Examine CMOS shutdown status.
  ;; 0x01,0x02,0x03,0x04,0x06,0x07,0x08,0x09 = Unimplemented shutdown status.
  push bx
  call _shutdown_status_panic
normal_post:
  ; case 0: normal startup
  cli
  mov ax, #0xfffe
  mov sp, ax
  xor ax, ax
  mov ds, ax
  mov ss, ax
  ;; Save shutdown status
  mov 0x04b0, bl
  cmp bl, #0xfe
  jz s3_post
  ;; zero out BIOS data area (40:00..40:ff)
  mov es, ax
  mov cx, #0x0080 ;; 128 words
  mov di, #0x0400
  cld
  rep
    stosw
  call _log_bios_start
  ;; set all interrupts to default handler
  xor bx, bx ;; offset index
  mov cx, #0x0100 ;; counter (256 interrupts)
  mov ax, #dummy_iret_handler
  mov dx, #0xF000
post_default_ints:
  mov [bx], ax
  add bx, #2
  mov [bx], dx
  add bx, #2
  loop post_default_ints
  ;; set vector 0x79 to zero
  ;; this is used by 'gardian angel' protection system
  SET_INT_VECTOR(0x79, #0, #0)
  ;; base memory in K 40:13 (word)
  mov ax, #(640 - 1)
  mov 0x0413, ax
  ;; Manufacturing Test 40:12
  ;; zerod out above
  ;; Warm Boot Flag 0040:0072
  ;; value of 1234h = skip memory checks
  ;; zerod out above
  ;; Printer Services vector
  SET_INT_VECTOR(0x17, #0xF000, #int17_handler)
  ;; Bootstrap failure vector
  SET_INT_VECTOR(0x18, #0xF000, #int18_handler)
  ;; Bootstrap Loader vector
  SET_INT_VECTOR(0x19, #0xF000, #int19_handler)
  ;; User Timer Tick vector
  SET_INT_VECTOR(0x1c, #0xF000, #int1c_handler)
  ;; Memory Size Check vector
  SET_INT_VECTOR(0x12, #0xF000, #int12_handler)
  ;; Equipment Configuration Check vector
  SET_INT_VECTOR(0x11, #0xF000, #int11_handler)
  ;; System Services
  SET_INT_VECTOR(0x15, #0xF000, #int15_handler)
  ;; EBDA setup
  call ebda_post
  ;; PIT setup
  SET_INT_VECTOR(0x08, #0xF000, #int08_handler)
  ;; int 1C already points at dummy_iret_handler (above)
  mov al, #0x34 ; timer0: binary count, 16bit count, mode 2
  out 0x43, al
  mov al, #0x00 ; maximum count of 0000H = 18.2Hz
  out 0x40, al
  out 0x40, al
  ;; Keyboard
  SET_INT_VECTOR(0x09, #0xF000, #int09_handler)
  SET_INT_VECTOR(0x16, #0xF000, #int16_handler)
  xor ax, ax
  mov ds, ax
  mov 0x0417, al
  mov 0x0418, al
  mov 0x0419, al
  mov 0x0471, al
  mov 0x0497, al
  mov al, #0x10
  mov 0x0496, al
  mov bx, #0x001E
  mov 0x041A, bx
  mov 0x041C, bx
  mov bx, #0x001E
  mov 0x0480, bx
  mov bx, #0x003E
  mov 0x0482, bx
  call _keyboard_init
  ;; mov CMOS Equipment Byte to BDA Equipment Word
  mov ax, 0x0410
  mov al, #0x14
  out 0x70, al
  in al, 0x71
  mov 0x0410, ax
  ;; Parallel setup
  SET_INT_VECTOR(0x0F, #0xF000, #dummy_iret_handler)
  xor ax, ax
  mov ds, ax
  xor bx, bx
  mov cl, #0x14 ; timeout value
  mov dx, #0x378 ; Parallel I/O address, port 1
  call detect_parport
  mov dx, #0x278 ; Parallel I/O address, port 2
  call detect_parport
  shl bx, #0x0e
  mov ax, 0x410 ; Equipment word bits 14..15 determing # parallel ports
  and ax, #0x3fff
  or ax, bx ; set number of parallel ports
  mov 0x410, ax
  ;; Serial setup
  SET_INT_VECTOR(0x0C, #0xF000, #dummy_iret_handler)
  SET_INT_VECTOR(0x14, #0xF000, #int14_handler)
  xor bx, bx
  mov cl, #0x0a ; timeout value
  mov dx, #0x03f8 ; Serial I/O address, port 1
  call detect_serial
  mov dx, #0x02f8 ; Serial I/O address, port 2
  call detect_serial
  mov dx, #0x03e8 ; Serial I/O address, port 3
  call detect_serial
  mov dx, #0x02e8 ; Serial I/O address, port 4
  call detect_serial
  shl bx, #0x09
  mov ax, 0x410 ; Equipment word bits 9..11 determing # serial ports
  and ax, #0xf1ff
  or ax, bx ; set number of serial port
  mov 0x410, ax
  ;; CMOS RTC
  SET_INT_VECTOR(0x1A, #0xF000, #int1a_handler)
  SET_INT_VECTOR(0x4A, #0xF000, #dummy_iret_handler)
  SET_INT_VECTOR(0x70, #0xF000, #int70_handler)
  ;; BIOS DATA AREA 0x4CE ???
  call timer_tick_post
  ;; PS/2 mouse setup
  SET_INT_VECTOR(0x74, #0xF000, #int74_handler)
  ;; IRQ13 (FPU exception) setup
  SET_INT_VECTOR(0x75, #0xF000, #int75_handler)
  ;; Video setup
  SET_INT_VECTOR(0x10, #0xF000, #int10_handler)
  ;; PIC
  call post_init_pic
  mov cx, #0xc000 ;; init vga bios
  mov ax, #0xc780
  call rom_scan
  call _print_bios_banner
  call pcibios_init_iomem_bases
  call pcibios_init_irqs
  ;;
  ;; Floppy setup
  ;;
  call floppy_drive_post
  ;;
  ;; Hard Drive setup
  ;;
  call hard_drive_post
  ;;
  ;; ATA/ATAPI driver setup
  ;;
  call _ata_init
  call _ata_detect
  ;;
  ;;
  ;; eltorito floppy/harddisk emulation from cd
  ;;
  call _cdemu_init
  ;;
  call _init_boot_vectors
  mov cx, #0xc800 ;; init option roms
  mov ax, #0xe000
  call rom_scan
  call _interactive_bootkey
  sti ;; enable interrupts
  int #0x19
.org 0xe2c3 ; NMI Handler Entry Point
nmi:
  ;; FIXME the NMI handler should not panic
  ;; but iret when called from int75 (fpu exception)
  call _nmi_handler_msg
  iret
int75_handler:
  out 0xf0, al
  call eoi_both_pics
  int 2
  iret
;-------------------------------------------
;- INT 13h Fixed Disk Services Entry Point -
;-------------------------------------------
.org 0xe3fe ; INT 13h Fixed Disk Services Entry Point
int13_handler:
  jmp int13_relocated
.org 0xe401 ; Fixed Disk Parameter Table
;----------
;- INT19h -
;----------
.org 0xe6f2 ; INT 19h Boot Load Service Entry Point
int19_handler:
  jmp int19_relocated
;-------------------------------------------
;- System BIOS Configuration Data Table
;-------------------------------------------
.org 0xe6f5
db 0x08 ; Table size (bytes) -Lo
db 0x00 ; Table size (bytes) -Hi
db 0xFC
db 0x00
db 1
; Feature byte 1
; b7: 1=DMA channel 3 used by hard disk
; b6: 1=2 interrupt controllers present
; b5: 1=RTC present
; b4: 1=BIOS calls int 15h/4Fh every key
; b3: 1=wait for extern event supported (Int 15h/41h)
; b2: 1=extended BIOS data area used
; b1: 0=AT or ESDI bus, 1=MicroChannel
; b0: 1=Dual bus (MicroChannel + ISA)
db (0 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (0 << 3) | (1 << 2) | (0 << 1) | (0 << 0)
; Feature byte 2
; b7: 1=32-bit DMA supported
; b6: 1=int16h, function 9 supported
; b5: 1=int15h/C6h (get POS data) supported
; b4: 1=int15h/C7h (get mem map info) supported
; b3: 1=int15h/C8h (en/dis CPU) supported
; b2: 1=non-8042 kb controller
; b1: 1=data streaming supported
; b0: reserved
db (0 << 7) | (1 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2) | (0 << 1) | (0 << 0)
; Feature byte 3
; b7: not used
; b6: reserved
; b5: reserved
; b4: POST supports ROM-to-RAM enable/disable
; b3: SCSI on system board
; b2: info panel installed
; b1: Initial Machine Load (IML) system - BIOS on disk
; b0: SCSI supported in IML
db 0x00
; Feature byte 4
; b7: IBM private
; b6: EEPROM present
; b5-3: ABIOS presence (011 = not supported)
; b2: private
; b1: memory split above 16Mb supported
; b0: POSTEXT directly supported by POST
db 0x00
; Feature byte 5 (IBM)
; b1: enhanced mouse
; b0: flash EPROM
db 0x00
.org 0xe729 ; Baud Rate Generator Table
;----------
;- INT14h -
;----------
.org 0xe739 ; INT 14h Serial Communications Service Entry Point
int14_handler:
  push ds
  pusha
  xor ax, ax
  mov ds, ax
  call _int14_function
  popa
  pop ds
  iret
;----------------------------------------
;- INT 16h Keyboard Service Entry Point -
;----------------------------------------
.org 0xe82e
int16_handler:
  sti
  push ds
  pushf
  pusha
  cmp ah, #0x00
  je int16_F00
  cmp ah, #0x10
  je int16_F00
  mov bx, #0xf000
  mov ds, bx
  call _int16_function
  popa
  popf
  pop ds
  jz int16_zero_set
int16_zero_clear:
  push bp
  mov bp, sp
  and BYTE [bp + 0x06], #0xbf
  pop bp
  iret
int16_zero_set:
  push bp
  mov bp, sp
  or BYTE [bp + 0x06], #0x40
  pop bp
  iret
int16_F00:
  mov bx, #0x0040
  mov ds, bx
int16_wait_for_key:
  cli
  mov bx, 0x001a
  cmp bx, 0x001c
  jne int16_key_found
  sti
  nop
  jmp int16_wait_for_key
int16_key_found:
  mov bx, #0xf000
  mov ds, bx
  call _int16_function
  popa
  popf
  pop ds
  iret
;-------------------------------------------------
;- INT09h : Keyboard Hardware Service Entry Point -
;-------------------------------------------------
.org 0xe987
int09_handler:
  cli
  push ax
  mov al, #0xAD ;;disable keyboard
  out #0x64, al
  mov al, #0x0B
  out #0x20, al
  in al, #0x20
  and al, #0x02
  jz int09_finish
  in al, #0x60 ;;read key from keyboard controller
  sti
  push ds
  pusha
  mov ah, #0x4f ;; allow for keyboard intercept
  stc
  int #0x15
  jnc int09_done
  ;; check for extended key
  cmp al, #0xe0
  jne int09_check_pause
  xor ax, ax
  mov ds, ax
  mov al, BYTE [0x496] ;; mf2_state |= 0x02
  or al, #0x02
  mov BYTE [0x496], al
  jmp int09_done
int09_check_pause: ;; check for pause key
  cmp al, #0xe1
  jne int09_process_key
  xor ax, ax
  mov ds, ax
  mov al, BYTE [0x496] ;; mf2_state |= 0x01
  or al, #0x01
  mov BYTE [0x496], al
  jmp int09_done
int09_process_key:
  mov bx, #0xf000
  mov ds, bx
  call _int09_function
int09_done:
  popa
  pop ds
  cli
  call eoi_master_pic
int09_finish:
  mov al, #0xAE ;;enable keyboard
  out #0x64, al
  pop ax
  iret
;----------------------------------------
;- INT 13h Diskette Service Entry Point -
;----------------------------------------
.org 0xec59
int13_diskette:
  jmp int13_noeltorito
;---------------------------------------------
;- INT 0Eh Diskette Hardware ISR Entry Point -
;---------------------------------------------
.org 0xef57 ; INT 0Eh Diskette Hardware ISR Entry Point
int0e_handler:
  push ax
  push dx
  mov dx, #0x03f4
  in al, dx
  and al, #0xc0
  cmp al, #0xc0
  je int0e_normal
  mov dx, #0x03f5
  mov al, #0x08 ; sense interrupt status
  out dx, al
int0e_loop1:
  mov dx, #0x03f4
  in al, dx
  and al, #0xc0
  cmp al, #0xc0
  jne int0e_loop1
int0e_loop2:
  mov dx, #0x03f5
  in al, dx
  mov dx, #0x03f4
  in al, dx
  and al, #0xc0
  cmp al, #0xc0
  je int0e_loop2
int0e_normal:
  push ds
  xor ax, ax ;; segment 0000
  mov ds, ax
  call eoi_master_pic
  mov al, 0x043e
  or al, #0x80 ;; diskette interrupt has occurred
  mov 0x043e, al
  pop ds
  pop dx
  pop ax
  iret
.org 0xefc7 ; Diskette Controller Parameter Table
diskette_param_table:
;; Since no provisions are made for multiple drive types, most
;; values in this table are ignored. I set parameters for 1.44M
;; floppy here
db 0xAF
db 0x02 ;; head load time 0000001, DMA used
db 0x25
db 0x02
db 18
db 0x1B
db 0xFF
db 0x6C
db 0xF6
db 0x0F
db 0x08
;----------------------------------------
;- INT17h : Printer Service Entry Point -
;----------------------------------------
.org 0xefd2
int17_handler:
  push ds
  pusha
  xor ax, ax
  mov ds, ax
  call _int17_function
  popa
  pop ds
  iret
diskette_param_table2:
;; New diskette parameter table adding 3 parameters from IBM
;; Since no provisions are made for multiple drive types, most
;; values in this table are ignored. I set parameters for 1.44M
;; floppy here
db 0xAF
db 0x02 ;; head load time 0000001, DMA used
db 0x25
db 0x02
db 18
db 0x1B
db 0xFF
db 0x6C
db 0xF6
db 0x0F
db 0x08
db 79 ;; maximum track
db 0 ;; data transfer rate
db 4 ;; drive type in cmos
.org 0xf045 ; INT 10 Functions 0-Fh Entry Point
  HALT(11136)
  iret
;----------
;- INT10h -
;----------
.org 0xf065 ; INT 10h Video Support Service Entry Point
int10_handler:
  ;; dont do anything, since the VGA BIOS handles int10h requests
  iret
.org 0xf0a4 ; MDA/CGA Video Parameter Table (INT 1Dh)
;----------
;- INT12h -
;----------
.org 0xf841 ; INT 12h Memory Size Service Entry Point
; ??? different for Pentium (machine check)?
int12_handler:
  push ds
  mov ax, #0x0040
  mov ds, ax
  mov ax, 0x0013
  pop ds
  iret
;----------
;- INT11h -
;----------
.org 0xf84d ; INT 11h Equipment List Service Entry Point
int11_handler:
  push ds
  mov ax, #0x0040
  mov ds, ax
  mov ax, 0x0010
  pop ds
  iret
;----------
;- INT15h -
;----------
.org 0xf859 ; INT 15h System Services Entry Point
int15_handler:
  pushf
  cmp ah, #0x53
  je apm_call
  push ds
  push es
  cmp ah, #0x86
  je int15_handler32
  cmp ah, #0xE8
  je int15_handler32
  pusha
  cmp ah, #0xC2
  je int15_handler_mouse
  call _int15_function
int15_handler_mouse_ret:
  popa
int15_handler32_ret:
  pop es
  pop ds
  popf
  jmp iret_modify_cf
apm_call:
  jmp _apmreal_entry
int15_handler_mouse:
  call _int15_function_mouse
  jmp int15_handler_mouse_ret
int15_handler32:
  pushad
  call _int15_function32
  popad
  jmp int15_handler32_ret
;; Protected mode IDT descriptor
;;
;; I just make the limit 0, so the machine will shutdown
;; if an exception occurs during protected mode memory
;; transfers.
;;
;; Set base to f0000 to correspond to beginning of BIOS,
;; in case I actually define an IDT later
;; Set limit to 0
pmode_IDT_info:
dw 0x0000 ;; limit 15:00
dw 0x0000 ;; base 15:00
db 0x0f ;; base 23:16
;; Real mode IDT descriptor
;;
;; Set to typical real-mode values.
;; base = 000000
;; limit = 03ff
rmode_IDT_info:
dw 0x03ff ;; limit 15:00
dw 0x0000 ;; base 15:00
db 0x00 ;; base 23:16
;----------
;- INT1Ah -
;----------
.org 0xfe6e ; INT 1Ah Time-of-day Service Entry Point
int1a_handler:
  cmp ah, #0xb1
  jne int1a_normal
  call pcibios_real
  jc pcibios_error
  retf 2
pcibios_error:
  mov bl, ah
  mov ah, #0xb1
  push ds
  pusha
  mov ax, ss ; set readable descriptor to ds, for calling pcibios
  mov ds, ax ; on 16bit protected mode.
  jmp int1a_callfunction
int1a_normal:
  push ds
  pusha
  xor ax, ax
  mov ds, ax
int1a_callfunction:
  call _int1a_function
  popa
  pop ds
  iret
;;
;; int70h: IRQ8 - CMOS RTC
;;
int70_handler:
  push ds
  pushad
  xor ax, ax
  mov ds, ax
  call _int70_function
  popad
  pop ds
  iret
;---------
;- INT08 -
;---------
.org 0xfea5 ; INT 08h System Timer ISR Entry Point
int08_handler:
  sti
  push eax
  push ds
  xor ax, ax
  mov ds, ax
  ;; time to turn off drive(s)?
  mov al,0x0440
  or al,al
  jz int08_floppy_off
  dec al
  mov 0x0440,al
  jnz int08_floppy_off
  ;; turn motor(s) off
  push dx
  mov dx,#0x03f2
  in al,dx
  and al,#0xcf
  out dx,al
  pop dx
int08_floppy_off:
  mov eax, 0x046c ;; get ticks dword
  inc eax
  ;; compare eax to one days worth of timer ticks at 18.2 hz
  cmp eax, #0x001800B0
  jb int08_store_ticks
  ;; there has been a midnight rollover at this point
  xor eax, eax ;; zero out counter
  inc BYTE 0x0470 ;; increment rollover flag
int08_store_ticks:
  mov 0x046c, eax ;; store new ticks dword
  ;; chain to user timer tick INT #0x1c
  int #0x1c
  cli
  call eoi_master_pic
  pop ds
  pop eax
  iret
.org 0xfef3 ; Initial Interrupt Vector Offsets Loaded by POST
.org 0xff00
.ascii "(c) 2002 MandrakeSoft S.A. Written by Kevin Lawton & the Bochs team."
;------------------------------------------------
;- IRET Instruction for Dummy Interrupt Handler -
;------------------------------------------------
.org 0xff53 ; IRET Instruction for Dummy Interrupt Handler
dummy_iret_handler:
  iret
.org 0xff54 ; INT 05h Print Screen Service Entry Point
  HALT(11355)
  iret
.org 0xfff0 ; Power-up Entry Point
  jmp 0xf000:post
.org 0xfff5 ; ASCII Date ROM was built - 8 characters in MM/DD/YY
.ascii "10/11/09"
.org 0xfffe ; System Model ID
db 0xFC
db 0x00 ; filler
.org 0xfa6e ;; Character Font for 320x200 & 640x200 Graphics (lower 128 characters)
! 8204 endasm
!BCC_ENDASM
! 8205 static Bit8u vgafont8[128*8]=
! Register BX used in function int70_function
! 8206 {
.data
_vgafont8:
! 8207  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8208  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
.byte	$7E
.byte	$81
.byte	$A5
.byte	$81
.byte	$BD
.byte	$99
.byte	$81
.byte	$7E
! 8209  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
.byte	$7E
.byte	$FF
.byte	$DB
.byte	$FF
.byte	$C3
.byte	$E7
.byte	$FF
.byte	$7E
! 8210  0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
.byte	$6C
.byte	$FE
.byte	$FE
.byte	$FE
.byte	$7C
.byte	$38
.byte	$10
.byte	0
! 8211  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
.byte	$10
.byte	$38
.byte	$7C
.byte	$FE
.byte	$7C
.byte	$38
.byte	$10
.byte	0
! 8212  0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
.byte	$38
.byte	$7C
.byte	$38
.byte	$FE
.byte	$FE
.byte	$7C
.byte	$38
.byte	$7C
! 8213  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
.byte	$10
.byte	$10
.byte	$38
.byte	$7C
.byte	$FE
.byte	$7C
.byte	$38
.byte	$7C
! 8214  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
.byte	0
.byte	0
.byte	$18
.byte	$3C
.byte	$3C
.byte	$18
.byte	0
.byte	0
! 8215  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
.byte	$FF
.byte	$FF
.byte	$E7
.byte	$C3
.byte	$C3
.byte	$E7
.byte	$FF
.byte	$FF
! 8216  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
.byte	0
.byte	$3C
.byte	$66
.byte	$42
.byte	$42
.byte	$66
.byte	$3C
.byte	0
! 8217  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
.byte	$FF
.byte	$C3
.byte	$99
.byte	$BD
.byte	$BD
.byte	$99
.byte	$C3
.byte	$FF
! 8218  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
.byte	$F
.byte	7
.byte	$F
.byte	$7D
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
! 8219  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
.byte	$3C
.byte	$66
.byte	$66
.byte	$66
.byte	$3C
.byte	$18
.byte	$7E
.byte	$18
! 8220  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
.byte	$3F
.byte	$33
.byte	$3F
.byte	$30
.byte	$30
.byte	$70
.byte	$F0
.byte	$E0
! 8221  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
.byte	$7F
.byte	$63
.byte	$7F
.byte	$63
.byte	$63
.byte	$67
.byte	$E6
! 8221 
.byte	$C0
! 8222  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
.byte	$99
.byte	$5A
.byte	$3C
.byte	$E7
.byte	$E7
.byte	$3C
.byte	$5A
.byte	$99
! 8223  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
.byte	$80
.byte	$E0
.byte	$F8
.byte	$FE
.byte	$F8
.byte	$E0
.byte	$80
.byte	0
! 8224  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
.byte	2
.byte	$E
.byte	$3E
.byte	$FE
.byte	$3E
.byte	$E
.byte	2
.byte	0
! 8225  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
.byte	$18
.byte	$3C
.byte	$7E
.byte	$18
.byte	$18
.byte	$7E
.byte	$3C
.byte	$18
! 8226  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
.byte	$66
.byte	$66
.byte	$66
.byte	$66
.byte	$66
.byte	0
.byte	$66
.byte	0
! 8227  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
.byte	$7F
.byte	$DB
.byte	$DB
.byte	$7B
.byte	$1B
.byte	$1B
.byte	$1B
.byte	0
! 8228  0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
.byte	$3E
.byte	$63
.byte	$38
.byte	$6C
.byte	$6C
.byte	$38
.byte	$CC
.byte	$78
! 8229  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	$7E
.byte	$7E
.byte	$7E
.byte	0
! 8230  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
.byte	$18
.byte	$3C
.byte	$7E
.byte	$18
.byte	$7E
.byte	$3C
.byte	$18
.byte	$FF
! 8231  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
.byte	$18
.byte	$3C
.byte	$7E
.byte	$18
.byte	$18
.byte	$18
.byte	$18
.byte	0
! 8232  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
.byte	$18
.byte	$18
.byte	$18
.byte	$18
.byte	$7E
.byte	$3C
.byte	$18
.byte	0
! 8233  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
.byte	0
.byte	$18
.byte	$C
.byte	$FE
.byte	$C
.byte	$18
.byte	0
.byte	0
! 8234  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
.byte	0
.byte	$30
.byte	$60
.byte	$FE
.byte	$60
.byte	$30
.byte	0
.byte	0
! 8235  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
.byte	0
.byte	0
.byte	$C0
.byte	$C0
.byte	$C0
.byte	$FE
.byte	0
.byte	0
! 8236  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
.byte	0
.byte	$24
.byte	$66
.byte	$FF
.byte	$66
.byte	$24
.byte	0
.byte	0
! 8237  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
.byte	0
.byte	$18
.byte	$3C
.byte	$7E
.byte	$FF
.byte	$FF
.byte	0
.byte	0
! 8238  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
.byte	0
.byte	$FF
.byte	$FF
.byte	$7E
.byte	$3C
.byte	$18
.byte	0
.byte	0
! 8239  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8240  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
.byte	$30
.byte	$78
.byte	$78
.byte	$30
.byte	$30
.byte	0
.byte	$30
.byte	0
! 8241  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	$6C
.byte	$6C
.byte	$6C
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8242  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
.byte	$6C
.byte	$6C
.byte	$FE
.byte	$6C
.byte	$FE
.byte	$6C
.byte	$6C
.byte	0
! 8243  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
.byte	$30
.byte	$7C
.byte	$C0
.byte	$78
.byte	$C
.byte	$F8
.byte	$30
.byte	0
! 8244  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
.byte	0
.byte	$C6
.byte	$CC
.byte	$18
.byte	$30
.byte	$66
.byte	$C6
.byte	0
! 8245  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
.byte	$38
.byte	$6C
.byte	$38
.byte	$76
.byte	$DC
.byte	$CC
.byte	$76
.byte	0
! 8246  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	$60
.byte	$60
.byte	$C0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8247  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
.byte	$18
.byte	$30
.byte	$60
.byte	$60
.byte	$60
.byte	$30
.byte	$18
.byte	0
! 8248  0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
.byte	$60
.byte	$30
.byte	$18
.byte	$18
.byte	$18
.byte	$30
.byte	$60
.byte	0
! 8249  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
.byte	0
.byte	$66
.byte	$3C
.byte	$FF
.byte	$3C
.byte	$66
.byte	0
.byte	0
! 8250  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
.byte	0
.byte	$30
.byte	$30
.byte	$FC
.byte	$30
.byte	$30
.byte	0
.byte	0
! 8251  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	$30
.byte	$30
.byte	$60
! 8252  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
.byte	0
.byte	0
.byte	0
.byte	$FC
.byte	0
.byte	0
.byte	0
.byte	0
! 8253  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	$30
.byte	$30
.byte	0
! 8254  0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
.byte	6
.byte	$C
.byte	$18
.byte	$30
.byte	$60
.byte	$C0
.byte	$80
.byte	0
! 8255  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
.byte	$7C
.byte	$C6
.byte	$CE
.byte	$DE
.byte	$F6
.byte	$E6
.byte	$7C
.byte	0
! 8256  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
.byte	$30
.byte	$70
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$FC
.byte	0
! 8257  0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
.byte	$78
.byte	$CC
.byte	$C
.byte	$38
.byte	$60
.byte	$CC
.byte	$FC
.byte	0
! 8258  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
.byte	$78
.byte	$CC
.byte	$C
.byte	$38
.byte	$C
.byte	$CC
.byte	$78
.byte	0
! 8259  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
.byte	$1C
.byte	$3C
.byte	$6C
.byte	$CC
.byte	$FE
.byte	$C
.byte	$1E
.byte	0
! 8260  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
.byte	$FC
.byte	$C0
.byte	$F8
.byte	$C
.byte	$C
.byte	$CC
.byte	$78
.byte	0
! 8261  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
.byte	$38
.byte	$60
.byte	$C0
.byte	$F8
.byte	$CC
.byte	$CC
.byte	$78
.byte	0
! 8262  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
.byte	$FC
.byte	$CC
.byte	$C
.byte	$18
.byte	$30
.byte	$30
.byte	$30
.byte	0
! 8263  0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0
.byte	$78
.byte	$CC
.byte	$CC
.byte	$78
.byte	$CC
.byte	$CC
! 8263 x78, 0x00,
.byte	$78
.byte	0
! 8264  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
.byte	$78
.byte	$CC
.byte	$CC
.byte	$7C
.byte	$C
.byte	$18
.byte	$70
.byte	0
! 8265  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
.byte	0
.byte	$30
.byte	$30
.byte	0
.byte	0
.byte	$30
.byte	$30
.byte	0
! 8266  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
.byte	0
.byte	$30
.byte	$30
.byte	0
.byte	0
.byte	$30
.byte	$30
.byte	$60
! 8267  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
.byte	$18
.byte	$30
.byte	$60
.byte	$C0
.byte	$60
.byte	$30
.byte	$18
.byte	0
! 8268  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
.byte	0
.byte	0
.byte	$FC
.byte	0
.byte	0
.byte	$FC
.byte	0
.byte	0
! 8269  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
.byte	$60
.byte	$30
.byte	$18
.byte	$C
.byte	$18
.byte	$30
.byte	$60
.byte	0
! 8270  0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
.byte	$78
.byte	$CC
.byte	$C
.byte	$18
.byte	$30
.byte	0
.byte	$30
.byte	0
! 8271  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
.byte	$7C
.byte	$C6
.byte	$DE
.byte	$DE
.byte	$DE
.byte	$C0
.byte	$78
.byte	0
! 8272  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
.byte	$30
.byte	$78
.byte	$CC
.byte	$CC
.byte	$FC
.byte	$CC
.byte	$CC
.byte	0
! 8273  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
.byte	$FC
.byte	$66
.byte	$66
.byte	$7C
.byte	$66
.byte	$66
.byte	$FC
.byte	0
! 8274  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
.byte	$3C
.byte	$66
.byte	$C0
.byte	$C0
.byte	$C0
.byte	$66
.byte	$3C
.byte	0
! 8275  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
.byte	$F8
.byte	$6C
.byte	$66
.byte	$66
.byte	$66
.byte	$6C
.byte	$F8
.byte	0
! 8276  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
.byte	$FE
.byte	$62
.byte	$68
.byte	$78
.byte	$68
.byte	$62
.byte	$FE
.byte	0
! 8277  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
.byte	$FE
.byte	$62
.byte	$68
.byte	$78
.byte	$68
.byte	$60
.byte	$F0
.byte	0
! 8278  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
.byte	$3C
.byte	$66
.byte	$C0
.byte	$C0
.byte	$CE
.byte	$66
.byte	$3E
.byte	0
! 8279  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$FC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	0
! 8280  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
.byte	$78
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8281  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
.byte	$1E
.byte	$C
.byte	$C
.byte	$C
.byte	$CC
.byte	$CC
.byte	$78
.byte	0
! 8282  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
.byte	$E6
.byte	$66
.byte	$6C
.byte	$78
.byte	$6C
.byte	$66
.byte	$E6
.byte	0
! 8283  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
.byte	$F0
.byte	$60
.byte	$60
.byte	$60
.byte	$62
.byte	$66
.byte	$FE
.byte	0
! 8284  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
.byte	$C6
.byte	$EE
.byte	$FE
.byte	$FE
.byte	$D6
.byte	$C6
.byte	$C6
.byte	0
! 8285  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
.byte	$C6
.byte	$E6
.byte	$F6
.byte	$DE
.byte	$CE
.byte	$C6
.byte	$C6
.byte	0
! 8286  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
.byte	$38
.byte	$6C
.byte	$C6
.byte	$C6
.byte	$C6
.byte	$6C
.byte	$38
.byte	0
! 8287  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
.byte	$FC
.byte	$66
.byte	$66
.byte	$7C
.byte	$60
.byte	$60
.byte	$F0
.byte	0
! 8288  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
.byte	$78
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$DC
.byte	$78
.byte	$1C
.byte	0
! 8289  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
.byte	$FC
.byte	$66
.byte	$66
.byte	$7C
.byte	$6C
.byte	$66
.byte	$E6
.byte	0
! 8290  0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
.byte	$78
.byte	$CC
.byte	$E0
.byte	$70
.byte	$1C
.byte	$CC
.byte	$78
.byte	0
! 8291  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
.byte	$FC
.byte	$B4
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8292  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$FC
.byte	0
! 8293  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
.byte	$30
.byte	0
! 8294  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
.byte	$C6
.byte	$C6
.byte	$C6
.byte	$D6
.byte	$FE
.byte	$EE
.byte	$C6
.byte	0
! 8295  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
.byte	$C6
.byte	$C6
.byte	$6C
.byte	$38
.byte	$38
.byte	$6C
.byte	$C6
.byte	0
! 8296  0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8297  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
.byte	$FE
.byte	$C6
.byte	$8C
.byte	$18
.byte	$32
.byte	$66
.byte	$FE
.byte	0
! 8298  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
.byte	$78
.byte	$60
.byte	$60
.byte	$60
.byte	$60
.byte	$60
.byte	$78
.byte	0
! 8299  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
.byte	$C0
.byte	$60
.byte	$30
.byte	$18
.byte	$C
.byte	6
.byte	2
.byte	0
! 8300  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
.byte	$78
.byte	$18
.byte	$18
.byte	$18
.byte	$18
.byte	$18
.byte	$78
.byte	0
! 8301  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
.byte	$10
.byte	$38
.byte	$6C
.byte	$C6
.byte	0
.byte	0
.byte	0
.byte	0
! 8302  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	$FF
! 8303  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	$30
.byte	$30
.byte	$18
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8304  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
.byte	0
.byte	0
.byte	$78
.byte	$C
.byte	$7C
.byte	$CC
.byte	$76
.byte	0
! 8305  0xe0, 0x60, 0x60, 0x7c, 0x6
.byte	$E0
.byte	$60
.byte	$60
.byte	$7C
! 8305 6, 0x66, 0xdc, 0x00,
.byte	$66
.byte	$66
.byte	$DC
.byte	0
! 8306  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
.byte	0
.byte	0
.byte	$78
.byte	$CC
.byte	$C0
.byte	$CC
.byte	$78
.byte	0
! 8307  0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
.byte	$1C
.byte	$C
.byte	$C
.byte	$7C
.byte	$CC
.byte	$CC
.byte	$76
.byte	0
! 8308  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
.byte	0
.byte	0
.byte	$78
.byte	$CC
.byte	$FC
.byte	$C0
.byte	$78
.byte	0
! 8309  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
.byte	$38
.byte	$6C
.byte	$60
.byte	$F0
.byte	$60
.byte	$60
.byte	$F0
.byte	0
! 8310  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
.byte	0
.byte	0
.byte	$76
.byte	$CC
.byte	$CC
.byte	$7C
.byte	$C
.byte	$F8
! 8311  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
.byte	$E0
.byte	$60
.byte	$6C
.byte	$76
.byte	$66
.byte	$66
.byte	$E6
.byte	0
! 8312  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
.byte	$30
.byte	0
.byte	$70
.byte	$30
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8313  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
.byte	$C
.byte	0
.byte	$C
.byte	$C
.byte	$C
.byte	$CC
.byte	$CC
.byte	$78
! 8314  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
.byte	$E0
.byte	$60
.byte	$66
.byte	$6C
.byte	$78
.byte	$6C
.byte	$E6
.byte	0
! 8315  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
.byte	$70
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8316  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
.byte	0
.byte	0
.byte	$CC
.byte	$FE
.byte	$FE
.byte	$D6
.byte	$C6
.byte	0
! 8317  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
.byte	0
.byte	0
.byte	$F8
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	0
! 8318  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
.byte	0
.byte	0
.byte	$78
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
.byte	0
! 8319  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
.byte	0
.byte	0
.byte	$DC
.byte	$66
.byte	$66
.byte	$7C
.byte	$60
.byte	$F0
! 8320  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
.byte	0
.byte	0
.byte	$76
.byte	$CC
.byte	$CC
.byte	$7C
.byte	$C
.byte	$1E
! 8321  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
.byte	0
.byte	0
.byte	$DC
.byte	$76
.byte	$66
.byte	$60
.byte	$F0
.byte	0
! 8322  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
.byte	0
.byte	0
.byte	$7C
.byte	$C0
.byte	$78
.byte	$C
.byte	$F8
.byte	0
! 8323  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
.byte	$10
.byte	$30
.byte	$7C
.byte	$30
.byte	$30
.byte	$34
.byte	$18
.byte	0
! 8324  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
.byte	0
.byte	0
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$76
.byte	0
! 8325  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
.byte	0
.byte	0
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
.byte	$30
.byte	0
! 8326  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
.byte	0
.byte	0
.byte	$C6
.byte	$D6
.byte	$FE
.byte	$FE
.byte	$6C
.byte	0
! 8327  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
.byte	0
.byte	0
.byte	$C6
.byte	$6C
.byte	$38
.byte	$6C
.byte	$C6
.byte	0
! 8328  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
.byte	0
.byte	0
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$7C
.byte	$C
.byte	$F8
! 8329  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
.byte	0
.byte	0
.byte	$FC
.byte	$98
.byte	$30
.byte	$64
.byte	$FC
.byte	0
! 8330  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
.byte	$1C
.byte	$30
.byte	$30
.byte	$E0
.byte	$30
.byte	$30
.byte	$1C
.byte	0
! 8331  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
.byte	$18
.byte	$18
.byte	$18
.byte	0
.byte	$18
.byte	$18
.byte	$18
.byte	0
! 8332  0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
.byte	$E0
.byte	$30
.byte	$30
.byte	$1C
.byte	$30
.byte	$30
.byte	$E0
.byte	0
! 8333  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	$76
.byte	$DC
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8334  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
.byte	0
.byte	$10
.byte	$38
.byte	$6C
.byte	$C6
.byte	$C6
.byte	$FE
.byte	0
! 8335 };
!BCC_EOS
! 8336 #asm
!BCC_ASM
.org 0xcc00
bios_table_area_end:
! 8339 endasm
!BCC_ENDASM
! 8340 
.784:
.793:
.ascii	"no PCI device with class code 0x%02x%04x"
.ascii	" found at index %d"
.byte	$A
.byte	0
.782:
.794:
.ascii	"PCI device %04x:%04x not found at index "
.ascii	"%d"
.byte	$A
.byte	0
.77C:
.795:
.ascii	"bad PCI vendor ID %04x"
.byte	$A
.byte	0
.778:
.796:
.ascii	"unsupported PCI BIOS function 0x%02x"
.byte	$A
.byte	0
.774:
.797:
.ascii	"PCI BIOS: PCI not present"
.byte	$A
.byte	0
.759:
.798:
.ascii	"Booting from %x:%x"
.byte	$A
.byte	0
.744:
.799:
.ascii	"Invalid boot device (0x%x)"
.byte	$A
.byte	0
.741:
.79A:
.ascii	"No bootable device."
.byte	$A
.byte	0
.72B:
.79B:
.ascii	"set_diskette_current_cyl(): drive > 1"
.byte	$A
.byte	0
.726:
.79C:
.ascii	"int13_diskette: unsupported AH=%02x"
.byte	$A
.byte	0
.714:
.79D:
.ascii	"floppy: int13: bad floppy type"
.byte	$A
.byte	0
.6FC:
.79E:
.ascii	"int13_diskette_function: write error"
.byte	$A
.byte	0
.6F6:
.79F:
.ascii	"int13_diskette: ctrl not ready"
.byte	$A
.byte	0
.6DB:
.7A0:
.ascii	"int13_diskette_function: read error"
.byte	$A
.byte	0
.6D5:
.7A1:
.ascii	"int13_diskette: ctrl not ready"
.byte	$A
.byte	0
.6C3:
.7A2:
.ascii	"int13_diskette: ctrl not ready"
.byte	$A
.byte	0
.6AE:
.7A3:
.ascii	"int13_diskette: read/write/verify: param"
.ascii	"eter out of range"
.byte	$A
.byte	0
.64C:
.7A4:
.ascii	"int13_cdemu function AH=%02x unsupported"
.ascii	", returns fail"
.byte	$A
.byte	0
.634:
.7A5:
.ascii	"int13_cdemu: function %02x, error %02x !"
.byte	$A
.byte	0
.616:
.7A6:
.ascii	"int13_cdemu: function %02x, emulation no"
.ascii	"t active for DL= %02x"
.byte	$A
.byte	0
.612:
.7A7:
.ascii	"int13_eltorito: unsupported AH=%02x"
.byte	$A
.byte	0
.60D:
.7A8:
.ascii	"Int13 eltorito call with AX=%04x. Please"
.ascii	" report"
.byte	$A
.byte	0
.602:
.7A9:
.ascii	"int13_cdrom: unsupported AH=%02x"
.byte	$A
.byte	0
.5BB:
.7AA:
.ascii	"int13_cdrom: function %02x, status %02x "
.ascii	"!"
.byte	$A
.byte	0
.5B5:
.7AB:
.ascii	"int13_cdrom: function %02x. Can't use 64"
.ascii	"bits lba"
.byte	$A
.byte	0
.59B:
.7AC:
.ascii	"int13_cdrom: function %02x, unmapped dev"
.ascii	"ice for ELDL=%02x"
.byte	$A
.byte	0
.598:
.7AD:
.ascii	"int13_cdrom: function %02x, ELDL out of "
.ascii	"range %02x"
.byte	$A
.byte	0
.590:
.7AE:
.ascii	"int13_harddisk: function %02xh unsupport"
.ascii	"ed, returns fail"
.byte	$A
.byte	0
.58A:
.7AF:
.ascii	"int13_harddisk: function %02xh unimpleme"
.ascii	"nted, returns success"
.byte	$A
.byte	0
.549:
.7B0:
.ascii	"int13_harddisk: function %02x, error %02"
.ascii	"x !"
.byte	$A
.byte	0
.540:
.7B1:
.ascii	"int13_harddisk: function %02x. LBA out o"
.ascii	"f range"
.byte	$A
.byte	0
.53C:
.7B2:
.ascii	"int13_harddisk: function %02x. LBA out o"
.ascii	"f range"
.byte	$A
.byte	0
.52E:
.7B3:
.ascii	"format disk track called"
.byte	$A
.byte	0
.52C:
.7B4:
.ascii	"int13_harddisk: function %02x, error %02"
.ascii	"x !"
.byte	$A
.byte	0
.521:
.7B5:
.ascii	"int13_harddisk: function %02x, parameter"
.ascii	"s out of range %04x/%04x/%04x!"
.byte	$A
.byte	0
.51C:
.7B6:
.ascii	"int13_harddisk: function %02x, parameter"
.ascii	" out of range!"
.byte	$A
.byte	0
.50C:
.7B7:
.ascii	"int13_harddisk: function %02x, unmapped "
.ascii	"device for ELDL=%02x"
.byte	$A
.byte	0
.509:
.7B8:
.ascii	"int13_harddisk: function %02x, ELDL out "
.ascii	"of range %02x"
.byte	$A
.byte	0
.4F6:
.7B9:
.ascii	"KBD: int09h_handler(): scancode & asciic"
.ascii	"ode are zero?"
.byte	$A
.byte	0
.4DE:
.7BA:
.ascii	"KBD: int09h_handler(): unknown scancode "
.ascii	"read: 0x%02x!"
.byte	$A
.byte	0
.4B3:
.7BB:
.ascii	"KBD: int09 handler: AL=0"
.byte	$A
.byte	0
.4B0:
.7BC:
.ascii	"setkbdcomm"
.byte	0
.4A9:
.7BD:
.ascii	"sendmouse"
.byte	0
.4A6:
.7BE:
.ascii	"enabmouse"
.byte	0
.49F:
.7BF:
.ascii	"enabmouse"
.byte	0
.49C:
.7C0:
.ascii	"inhibmouse"
.byte	0
.495:
.7C1:
.ascii	"inhibmouse"
.byte	0
.488:
.7C2:
.ascii	"KBD: unsupported int 16h function %02x"
.byte	$A
.byte	0
.477:
.7C3:
.ascii	"KBD: int16h: out of keyboard input"
.byte	$A
.byte	0
.449:
.7C4:
.ascii	"KBD: int16h: out of keyboard input"
.byte	$A
.byte	0
.436:
.7C5:
.ascii	"*** int 15h function AX=%04x, BX=%04x no"
.ascii	"t yet supported!"
.byte	$A
.byte	0
.40F:
.7C6:
.ascii	"*** int 15h function AX=%04x, BX=%04x no"
.ascii	"t yet supported!"
.byte	$A
.byte	0
.403:
.7C7:
.ascii	"INT 15h C2 AL=6, BH=%02x"
.byte	$A
.byte	0
.3ED:
.7C8:
.ascii	"Mouse status returned %02x (should be ac"
.ascii	"k)"
.byte	$A
.byte	0
.3DD:
.7C9:
.ascii	"Mouse status returned %02x (should be ac"
.ascii	"k)"
.byte	$A
.byte	0
.3DA:
.7CA:
.ascii	"Mouse status returned %02x (should be ac"
.ascii	"k)"
.byte	$A
.byte	0
.3B8:
.7CB:
.ascii	"Mouse reset returned %02x (should be ack"
.ascii	")"
.byte	$A
.byte	0
.38F:
.7CC:
.ascii	"*** int 15h function AX=%04x, BX=%04x no"
.ascii	"t yet supported!"
.byte	$A
.byte	0
.38D:
.7CD:
.ascii	"EISA BIOS not present"
.byte	$A
.byte	0
.389:
.7CE:
.ascii	"*** int 15h function AH=bf not yet suppo"
.ascii	"rted!"
.byte	$A
.byte	0
.371:
.7CF:
.ascii	"int15: Func 24h, subfunc %02xh, A20 gate"
.ascii	" control not supported"
.byte	$A
.byte	0
.30B:
.7D0:
.ascii	"ata_is_ready returned %d"
.byte	$A
.byte	0
.2F5:
.7D1:
.ascii	"%dMB medium detected"
.byte	$A
.byte	0
.2F0:
.7D2:
.ascii	"Unsupported sector size %u"
.byte	$A
.byte	0
.2EB:
.7D3:
.ascii	"Waiting for device to detect medium... "
.byte	0
.2DD:
.7D4:
.ascii	"not implemented for non-ATAPI device"
.byte	$A
.byte	0
.2A3:
.7D5:
.ascii	"ata_cmd_packet: DATA_OUT not supported y"
.ascii	"et"
.byte	$A
.byte	0
.253:
.7D6:
.byte	$A
.byte	0
.24E:
.7D7:
.ascii	"master"
.byte	0
.24D:
.7D8:
.ascii	" slave"
.byte	0
.24C:
.7D9:
.ascii	"ata%d %s: Unknown device"
.byte	$A
.byte	0
.24A:
.7DA:
.ascii	" ATAPI-%d Device"
.byte	$A
.byte	0
.248:
.7DB:
.ascii	" ATAPI-%d CD-Rom/DVD-Rom"
.byte	$A
.byte	0
.244:
.7DC:
.ascii	"%c"
.byte	0
.23D:
.7DD:
.ascii	"master"
.byte	0
.23C:
.7DE:
.ascii	" slave"
.byte	0
.23B:
.7DF:
.ascii	"ata%d %s: "
.byte	0
.239:
.7E0:
.ascii	" ATA-%d Hard-Disk (%4u GBytes)"
.byte	$A
.byte	0
.237:
.7E1:
.ascii	" ATA-%d Hard-Disk (%4u MBytes)"
.byte	$A
.byte	0
.233:
.7E2:
.ascii	"%c"
.byte	0
.22C:
.7E3:
.ascii	"master"
.byte	0
.22B:
.7E4:
.ascii	" slave"
.byte	0
.22A:
.7E5:
.ascii	"ata%d %s: "
.byte	0
.1FF:
.7E6:
.ascii	"ata-detect: Failed to detect ATAPI devic"
.ascii	"e"
.byte	$A
.byte	0
.1FA:
.7E7:
.ascii	" LCHS=%d/%d/%d"
.byte	$A
.byte	0
.1DA:
.7E8:
.ascii	"r-echs"
.byte	0
.1D8:
.7E9:
.ascii	"large"
.byte	0
.1D6:
.7EA:
.ascii	"lba"
.byte	0
.1D4:
.7EB:
.ascii	"none"
.byte	0
.1CA:
.7EC:
.ascii	"ata%d-%d: PCHS=%u/%d/%d translation="
.byte	0
.1C0:
.7ED:
.ascii	"ata-detect: Failed to detect ATA device"
.byte	$A
.byte	0
.19F:
.7EE:
.ascii	"IDE time out"
.byte	$A
.byte	0
.163:
.7EF:
.ascii	"S3 resume jump to %x:%x"
.byte	$A
.byte	0
.15F:
.7F0:
.ascii	"S3 resume called %x 0x%lx"
.byte	$A
.byte	0
.159:
.7F1:
.ascii	"%s"
.byte	$A
.byte	0
.158:
.7F2:
.ascii	"INT18: BOOT FAILURE"
.byte	$A
.byte	0
.157:
.7F3:
.ascii	"NMI Handler called"
.byte	$A
.byte	0
.156:
.7F4:
.ascii	"CDROM boot failure code : %04x"
.byte	$A
.byte	0
.155:
.7F5:
.byte	$A,$A
.byte	0
.154:
.7F6:
.ascii	": could not read the boot disk"
.byte	0
.152:
.7F7:
.ascii	": not a bootable disk"
.byte	0
.14D:
.7F8:
.ascii	"Boot failed"
.byte	0
.14C:
.7F9:
.ascii	"Bad drive type"
.byte	$A
.byte	0
.148:
.7FA:
.ascii	"..."
.byte	$A
.byte	0
.147:
.7FB:
.ascii	" [%S]"
.byte	0
.143:
.7FC:
.ascii	"Booting from %s"
.byte	0
.142:
.7FD:
.ascii	"Bad drive type"
.byte	$A
.byte	0
.13C:
.7FE:
.byte	$A
.byte	0
.130:
.7FF:
.byte	$A
.byte	0
.12F:
.800:
.ascii	" [%S]"
.byte	0
.12C:
.801:
.ascii	"%s"
.byte	0
.12A:
.802:
.ascii	"%s"
.byte	$A
.byte	0
.123:
.803:
.ascii	"%d. "
.byte	0
.11E:
.804:
.ascii	"Select boot device:"
.byte	$A,$A
.byte	0
.115:
.805:
.ascii	"Press F12 for boot menu."
.byte	$A,$A
.byte	0
.109:
.806:
.ascii	"apmbios pcibios eltorito "
.byte	$A,$A
.byte	0
.108:
.807:
.ascii	"10/11/09"
.byte	0
.107:
.808:
.ascii	"Bochs BIOS - build: %s"
.byte	$A
.ascii	"%s"
.byte	$A
.ascii	"Options: "
.byte	0
.106:
.809:
.ascii	"Returned from s3_resume."
.byte	$A
.byte	0
.105:
.80A:
.ascii	"Unimplemented shutdown status: %02x"
.byte	$A
.byte	0
.104:
.80B:
.ascii	"Keyboard error:%u"
.byte	$A
.byte	0
.8D:
.80C:
.ascii	"bios_printf: unknown format"
.byte	$A
.byte	0
.41:
.80D:
.ascii	"FATAL: "
.byte	0
.bss

! 0 errors detected
